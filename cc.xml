This file is a merged representation of a subset of the codebase, containing specifically included files and files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: Cargo.toml, Cargo.lock, src/**/*.rs, tests/**/*.rs, *.md, scripts/**/*.sh, samples/**/*.rhai
- Files matching these patterns are excluded: target/, docs/, .git/, **/*.wav, **/*.png, **/*.jpg, context.xml, context-*.xml, diff.patch, diff-*.patch, sync_report.md, .driver_prompt.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
samples/
  01_fundamentals/
    basic.rhai
    psychoacoustic_test.rhai
    readme_example.rhai
    spawn_basics.rhai
    tone_generator.rhai
  02_mechanisms/
    agent_interaction.rhai
    rhythmic_sync.rhai
    spectral_gap.rhai
  03_structures/
    autumn_cycle.rhai
    basic_progression.rhai
    cadence_ii_v_i.rhai
    tension_resolution.rhai
  04_ecosystems/
    drift_flow.rhai
    emergent_harmony.rhai
    mirror_dualism.rhai
    symbiotic_field.rhai
scripts/
  generate_rhai_docs.sh
src/
  audio/
    buffer.rs
    mod.rs
    output.rs
    writer.rs
  core/
    stream/
      dorsal.rs
      harmonicity.rs
      mod.rs
      roughness.rs
    a_weighting.rs
    db.rs
    density.rs
    erb.rs
    fft.rs
    harmonic_ratios.rs
    harmonicity_kernel.rs
    harmonicity_worker.rs
    landscape_spectral.rs
    landscape.rs
    log2space.rs
    modulation.rs
    nsgt_kernel.rs
    nsgt_rt.rs
    nsgt.rs
    peak_extraction.rs
    phase.rs
    psycho_state.rs
    roughness_kernel.rs
    roughness_worker.rs
    timebase.rs
    utils.rs
  life/
    sound/
      any_backend.rs
      control.rs
      events.rs
      mod.rs
      modal_engine.rs
      voice.rs
    api.rs
    articulation_core.rs
    conductor.rs
    control.rs
    gate_clock.rs
    individual.rs
    intent.rs
    lifecycle.rs
    meta.rs
    mod.rs
    perceptual.rs
    phonation_engine.rs
    pitch_controller.rs
    pitch_core.rs
    population.rs
    predictive_spectrum.rs
    scenario.rs
    schedule_renderer.rs
    scripting.rs
    social_density.rs
    sound_body.rs
    sound_voice.rs
    tests_organic.rs
    tests.rs
    world_model.rs
  synth/
    mod.rs
    modes.rs
    resonator.rs
    util.rs
  ui/
    mod.rs
    plots.rs
    viewdata.rs
    windows.rs
  app.rs
  cli.rs
  config.rs
  core.rs
  lib.rs
  main.rs
tests/
  agent_intents.rs
  compile_only_samples.rs
  control_rate_dt_invariance.rs
  gate_clock.rs
  intent_board.rs
  intent_renderer_body_snapshot.rs
  intent_renderer_limiter.rs
  intent_renderer_onset.rs
  log2space_scan_invariants.rs
  phonation_rate_is_time_based.rs
  pitchcore_candidates.rs
  post_intent_action.rs
  run_script_samples.rs
  samples_no_legacy_keys.rs
  samples_parse.rs
  schedule_renderer_cutoff.rs
  schedule_renderer_rhythm_signal.rs
  schedule_renderer_short_duration.rs
  sound_voice_note_off_at_onset.rs
  spawn_birth_once.rs
AGENTS.md
Cargo.toml
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="samples/01_fundamentals/readme_example.rhai">
for i in 0..5 {
	spawn("a", 1);
	wait(0.5);
}
end_at(5)
</file>

<file path="samples/01_fundamentals/tone_generator.rhai">
spawn("tone", 1);
end_at(2);
</file>

<file path="scripts/generate_rhai_docs.sh">
#!/usr/bin/env bash
set -euo pipefail

repo_root="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "${repo_root}"

cargo run --example gen_schemas
cargo run --example generate_script_docs
mkdir -p web/static/docs
mdbook build docs/rhai_book
</file>

<file path="src/audio/buffer.rs">
// Generic audio buffer type to support mono/stereo interleaved data
#[derive(Clone, Debug)]
pub struct AudioBuffer {
    pub channels: usize,
    pub samples: Vec<f32>,
}

impl AudioBuffer {
    pub fn mono(samples: Vec<f32>) -> Self {
        Self {
            channels: 1,
            samples,
        }
    }

    pub fn stereo(left: Vec<f32>, right: Vec<f32>) -> Self {
        assert_eq!(left.len(), right.len());
        let mut interleaved = Vec::with_capacity(left.len() * 2);
        for (l, r) in left.into_iter().zip(right.into_iter()) {
            interleaved.push(l);
            interleaved.push(r);
        }
        Self {
            channels: 2,
            samples: interleaved,
        }
    }
}
</file>

<file path="src/audio/writer.rs">
use std::sync::Arc;

use crossbeam_channel::Receiver;
use hound::{SampleFormat, WavSpec, WavWriter};

pub struct WavOutput {
    // Writer is kept alive in the thread
}

impl WavOutput {
    pub fn run(
        rx: Receiver<Arc<[f32]>>,
        path: String,
        sample_rate: u32,
    ) -> std::thread::JoinHandle<()> {
        std::thread::spawn(move || {
            let spec = WavSpec {
                channels: 1,
                sample_rate,
                bits_per_sample: 16,
                sample_format: SampleFormat::Int,
            };
            let mut writer = WavWriter::create(path, spec).expect("create wav");

            while let Ok(samples) = rx.recv() {
                for &s in samples.iter() {
                    let v = (s.clamp(-1.0, 1.0) * i16::MAX as f32) as i16;
                    writer.write_sample(v).unwrap();
                }
            }

            writer.finalize().unwrap();
        })
    }
}
</file>

<file path="src/core/stream/dorsal.rs">
use crate::core::modulation::{NeuralRhythms, RhythmEngine};
use tracing::debug;

/// Dorsal Stream (Where/How Pathway)
/// Handles fast articulation processing, rhythm extraction, and motor synchronization.
///
/// Features:
/// - Low-latency synchronous processing.
/// - 3-Band Crossover Flux detection (Low/Mid/High).
/// - Non-linear sensitivity boost for ambient signals.
pub struct DorsalStream {
    dynamics: RhythmEngine,
    // IIR Filter States
    lp_low_state: f32, // ~200Hz
    lp_mid_state: f32, // ~3000Hz
    prev_band_energy: [f32; 3],
    delta_env: f32,
    last_metrics: DorsalMetrics,
    fs: f32,
    vitality: f32,
    debug_timer: f32,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct DorsalMetrics {
    pub e_low: f32,
    pub e_mid: f32,
    pub e_high: f32,
    pub flux: f32,
}

impl DorsalStream {
    pub fn new(fs: f32) -> Self {
        Self {
            dynamics: RhythmEngine::default(),
            lp_low_state: 0.0,
            lp_mid_state: 0.0,
            prev_band_energy: [0.0; 3],
            delta_env: 0.0,
            last_metrics: DorsalMetrics::default(),
            fs,
            vitality: 1.0,
            debug_timer: 0.0,
        }
    }

    /// Process audio chunk synchronously.
    /// Returns the updated NeuralRhythms immediately.
    pub fn process(&mut self, audio: &[f32]) -> NeuralRhythms {
        if audio.is_empty() {
            return self.dynamics.last();
        }

        // --- 1. Sub-band Flux Calculation ---

        // Coefficients for 1-pole filters
        // Low crossover: 200 Hz
        let alpha_low = 1.0 - (-2.0 * std::f32::consts::PI * 200.0 / self.fs).exp();
        // Mid/High crossover: 3000 Hz
        let alpha_mid = 1.0 - (-2.0 * std::f32::consts::PI * 3000.0 / self.fs).exp();

        let mut e_low = 0.0;
        let mut e_mid = 0.0;
        let mut e_high = 0.0;

        for &x in audio {
            // Low Band
            self.lp_low_state += alpha_low * (x - self.lp_low_state);
            let l = self.lp_low_state;

            // Mid Band boundary
            self.lp_mid_state += alpha_mid * (x - self.lp_mid_state);
            let mh_boundary = self.lp_mid_state;

            let band_l = l;
            let band_m = mh_boundary - l;
            let band_h = x - mh_boundary;

            e_low += band_l * band_l;
            e_mid += band_m * band_m;
            e_high += band_h * band_h;
        }

        // Normalize energy by chunk length
        let inv_len = 1.0 / audio.len() as f32;
        let currents = [e_low * inv_len, e_mid * inv_len, e_high * inv_len];

        // Sum positive flux across bands
        let mut raw_flux = 0.0;
        for (i, &cur) in currents.iter().enumerate() {
            let diff = cur - self.prev_band_energy[i];
            if diff > 0.0 {
                raw_flux += diff;
            }
            self.prev_band_energy[i] = cur;
        }
        self.last_metrics = DorsalMetrics {
            e_low: currents[0],
            e_mid: currents[1],
            e_high: currents[2],
            flux: raw_flux,
        };

        // --- 2. Non-linear Boost (Simulating Neural Activation) ---
        // High gain (500.0) + tanh saturation to detect ambient shifts
        let drive = (raw_flux * 500.0).tanh();
        let u_theta = drive.clamp(0.0, 1.0);

        // --- 3. Update Oscillators ---
        let dt = audio.len() as f32 / self.fs;
        let tau_delta = 0.6;
        let alpha = 1.0 - (-dt / tau_delta).exp();
        self.delta_env += alpha * (u_theta - self.delta_env);
        let u_delta = self.delta_env.clamp(0.0, 1.0);

        self.debug_timer += dt;
        if self.debug_timer >= 1.0 {
            debug!(
                target: "rhythm::dorsal",
                raw_flux,
                drive,
                u_theta,
                u_delta,
                dt,
                vitality = self.vitality
            );
            self.debug_timer = 0.0;
        }

        self.dynamics.update(dt, u_theta, u_delta, self.vitality)
    }

    pub fn reset(&mut self) {
        self.dynamics = RhythmEngine::default();
        self.lp_low_state = 0.0;
        self.lp_mid_state = 0.0;
        self.prev_band_energy = [0.0; 3];
        self.delta_env = 0.0;
        self.last_metrics = DorsalMetrics::default();
        self.vitality = 1.0;
        self.debug_timer = 0.0;
    }

    pub fn set_vitality(&mut self, v: f32) {
        self.vitality = v.clamp(0.0, 1.0);
    }

    pub fn last_metrics(&self) -> DorsalMetrics {
        self.last_metrics
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn dorsal_detects_click_train() {
        let fs = 44_100.0;
        let hop = 512;
        let dur_sec = 2.5;
        let total = (fs * dur_sec) as usize;
        let mut sig = vec![0.0f32; total];
        let period = 1.0 / 6.0;
        let click_len = 0.003;
        let freq = 3000.0;
        for i in 0..total {
            let t = i as f32 / fs;
            let phase = t % period;
            if phase < click_len {
                sig[i] = (std::f32::consts::TAU * freq * t).sin() * 0.8;
            }
        }

        let mut dorsal = DorsalStream::new(fs);
        let mut max_u_theta: f32 = 0.0;
        let mut last = NeuralRhythms::default();
        let mut idx = 0;
        while idx < total {
            let end = (idx + hop).min(total);
            last = dorsal.process(&sig[idx..end]);
            let raw_flux = dorsal.last_metrics().flux;
            let drive = (raw_flux * 500.0).tanh();
            max_u_theta = max_u_theta.max(drive);
            idx = end;
        }

        assert!(
            max_u_theta > 0.05,
            "expected u_theta to rise above 0.05, got {max_u_theta}"
        );
        assert!(
            last.theta.mag > 0.04,
            "expected theta.mag to rise, got {}",
            last.theta.mag
        );
        assert!(
            (last.theta.freq_hz - 6.0).abs() < 1.5,
            "expected theta.freq_hz near 6Hz, got {}",
            last.theta.freq_hz
        );
    }
}
</file>

<file path="src/core/stream/harmonicity.rs">
use crate::core::harmonicity_kernel::HarmonicityKernel;
use crate::core::landscape::LandscapeUpdate;
use crate::core::log2space::Log2Space;

/// Harmonicity Stream: accepts log2 spectra and applies the H-kernel.
pub struct HarmonicityStream {
    kernel: HarmonicityKernel,
    space: Log2Space,
}

impl HarmonicityStream {
    pub fn new(space: Log2Space, kernel: HarmonicityKernel) -> Self {
        Self { kernel, space }
    }

    pub fn update_params(&mut self, upd: LandscapeUpdate) {
        if upd.mirror.is_some() || upd.limit.is_some() {
            let mut params = self.kernel.params;
            if let Some(m) = upd.mirror {
                params.mirror_weight = m;
            }
            if let Some(l) = upd.limit {
                params.param_limit = l;
            }
            self.kernel = HarmonicityKernel::new(&self.space, params);
        }
    }

    /// Process log2 amplitude spectrum and compute harmonicity scan.
    /// Returns `(h_scan, log_amps)`.
    pub fn process(&mut self, spectrum_log: &[f32]) -> (Vec<f32>, Vec<f32>) {
        assert_eq!(
            spectrum_log.len(),
            self.space.n_bins(),
            "harmonicity spectrum must match log2 space"
        );
        let amps_log = spectrum_log.to_vec();
        let (h_scan, _) = self
            .kernel
            .potential_h_from_log2_spectrum(&amps_log, &self.space);
        (h_scan, amps_log)
    }
}
</file>

<file path="src/core/stream/mod.rs">
pub mod dorsal;
pub mod harmonicity;
pub mod roughness;
</file>

<file path="src/core/a_weighting.rs">
//! A-weighting helpers for amplitude and power domains.

use crate::core::utils::a_weighting_gain;

/// A-weighting power gain (amplitude gain squared).
pub fn a_weighting_gain_pow(f_hz: f32) -> f32 {
    let g = a_weighting_gain(f_hz);
    g * g
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::utils::a_weighting_gain;

    #[test]
    fn a_weighting_gain_pow_matches_square() {
        let f = 1000.0;
        let g = a_weighting_gain(f);
        let g_pow = a_weighting_gain_pow(f);
        assert!((g_pow - g * g).abs() < 1e-6);
    }

    #[test]
    fn a_weighting_gain_pow_is_finite_and_near_unity_at_1khz() {
        let g_pow = a_weighting_gain_pow(1000.0);
        assert!(g_pow.is_finite());
        assert!((g_pow - 1.0).abs() < 0.05, "g_pow={g_pow}");
    }
}
</file>

<file path="src/core/db.rs">
//! dB conversion helpers with explicit power/amplitude semantics.
//! - Power uses 10*log10(·) and dB to ratio uses /10.
//! - Amplitude uses 20*log10(·) and dB to ratio uses /20.
//!   EPS_POWER is applied to avoid log10(0).

/// Minimum power floor for log conversions.
pub const EPS_POWER: f32 = 1e-20;

/// Convert dB to a power ratio.
pub fn db_to_power_ratio(db: f32) -> f32 {
    10.0_f32.powf(db / 10.0)
}

/// Convert dB to an amplitude ratio.
pub fn db_to_amp_ratio(db: f32) -> f32 {
    10.0_f32.powf(db / 20.0)
}

/// Convert power ratio to dB (10*log10).
pub fn power_to_db(p: f32) -> f32 {
    10.0 * (p.max(EPS_POWER)).log10()
}

/// Convert amplitude ratio to dB (20*log10).
pub fn amp_to_db(a: f32) -> f32 {
    20.0 * (a.max(EPS_POWER.sqrt())).log10()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn db_to_power_ratio_basics() {
        assert!((db_to_power_ratio(0.0) - 1.0).abs() < 1e-4);
        assert!((db_to_power_ratio(10.0) - 10.0).abs() < 1e-4);
    }

    #[test]
    fn db_to_amp_ratio_basics() {
        assert!((db_to_amp_ratio(0.0) - 1.0).abs() < 1e-4);
        assert!((db_to_amp_ratio(6.0206) - 2.0).abs() < 1e-4);
    }

    #[test]
    fn power_to_db_basics() {
        assert!((power_to_db(1.0) - 0.0).abs() < 1e-4);
        assert!((power_to_db(10.0) - 10.0).abs() < 1e-4);
    }
}
</file>

<file path="src/core/density.rs">
//! Density/mass helpers for ERB (or other u-axis) representations.
//! density: per-u (e.g., per ERB); mass: integral of density over du.

/// Integrate a density over du to produce total mass.
pub fn density_to_mass(density: &[f32], du: &[f32]) -> f32 {
    density.iter().zip(du.iter()).map(|(d, du)| d * du).sum()
}

/// Convert peak masses into a delta density vector.
/// peaks: (idx, mass)
pub fn peaks_mass_to_delta_density(len: usize, peaks: &[(usize, f32)], du: &[f32]) -> Vec<f32> {
    let mut out = vec![0.0f32; len];
    if du.len() < len {
        return out;
    }
    for &(idx, mass) in peaks {
        if idx >= len {
            continue;
        }
        let step = du[idx];
        debug_assert!(step > 0.0, "du must be positive");
        if step <= 0.0 {
            continue;
        }
        out[idx] += mass / step;
    }
    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use rand::{Rng, SeedableRng};

    #[test]
    fn peaks_mass_round_trip_preserves_total_mass() {
        let len = 64;
        let mut rng = rand::rngs::StdRng::seed_from_u64(42);
        let du: Vec<f32> = (0..len).map(|_| rng.random_range(0.01..0.2)).collect();

        let mut peaks = Vec::new();
        let mut total_mass = 0.0f32;
        for _ in 0..20 {
            let idx = rng.random_range(0..len);
            let mass = rng.random_range(0.1..2.0);
            peaks.push((idx, mass));
            total_mass += mass;
        }

        let delta_density = peaks_mass_to_delta_density(len, &peaks, &du);
        let mass2 = density_to_mass(&delta_density, &du);
        let diff = (mass2 - total_mass).abs();
        assert!(diff < 1e-5, "mass diff {diff}");
    }
}
</file>

<file path="src/core/fft.rs">
use rustfft::{FftPlanner, num_complex::Complex32};

/// Symmetric Hann window (offline/filter design)
/// w[i] = 0.5 * (1 - cos(2πi/(N-1)))
#[inline]
pub fn hann_window_symmetric(n: usize) -> Vec<f32> {
    match n {
        0 => Vec::new(),
        1 => vec![1.0],
        _ => {
            let two_pi = std::f32::consts::PI * 2.0;
            let denom = (n - 1) as f32;
            let mut w = Vec::with_capacity(n);
            for i in 0..n {
                let phi = two_pi * i as f32 / denom;
                w.push(0.5 * (1.0 - phi.cos()));
            }
            w
        }
    }
}

/// Symmetric 4-term Blackman-Harris window for peak detection.
/// Side lobes reach about -92 dB, which is excellent for reducing false peaks,
/// but the main lobe is wider than a Hann window.
#[inline]
pub fn blackman_harris_window_symmetric(n: usize) -> Vec<f32> {
    match n {
        0 => Vec::new(),
        1 => vec![1.0],
        _ => {
            let two_pi = std::f64::consts::PI * 2.0;
            let denom = (n - 1) as f64;
            let a0 = 0.35875_f64;
            let a1 = 0.48829_f64;
            let a2 = 0.14128_f64;
            let a3 = 0.01168_f64;
            let mut w = Vec::with_capacity(n);
            for i in 0..n {
                let phi = two_pi * i as f64 / denom;
                let w_i = a0 - a1 * phi.cos() + a2 * (2.0 * phi).cos() - a3 * (3.0 * phi).cos();
                w.push(w_i.max(0.0) as f32);
            }
            w
        }
    }
}

/// Periodic Hann window (for FFT/STFT, COLA)
/// w[i] = 0.5 * (1 - cos(2πi/N))
#[inline]
pub fn hann_window_periodic(n: usize) -> Vec<f32> {
    match n {
        0 => Vec::new(),
        1 => vec![1.0],
        _ => {
            let two_pi = std::f32::consts::PI * 2.0;
            let n_f = n as f32;
            let mut w = Vec::with_capacity(n);
            for i in 0..n {
                let phi = two_pi * i as f32 / n_f;
                w.push(0.5 * (1.0 - phi.cos()));
            }
            w
        }
    }
}

/// Apply Hann window to a real buffer.
/// Returns U = mean(w²) ≈ 3/8 for normalization.
pub fn apply_hann_window_real(buf: &mut [f32]) -> f32 {
    let n = buf.len();
    if n <= 1 {
        return 1.0;
    }

    let win = hann_window_periodic(n);
    let mut sum_sq = 0.0;
    for (x, &w) in buf.iter_mut().zip(&win) {
        *x *= w;
        sum_sq += w * w;
    }
    sum_sq / n as f32
}

/// Apply Hann window to a complex buffer.
/// Returns Welch factor U = Σw² / N.
pub fn apply_hann_window_complex(buf: &mut [Complex32]) -> f32 {
    let n = buf.len();
    if n <= 1 {
        return 1.0;
    }
    let win = hann_window_periodic(n);
    let mut sum_sq = 0.0;
    for (x, &w) in buf.iter_mut().zip(&win) {
        *x *= w;
        sum_sq += w * w;
    }
    sum_sq / n as f32
}

// ======================================================================
// Inverse STFT (OLA-based)
// ======================================================================

pub struct Istft {
    pub n: usize,
    pub hop: usize,
    pub window: Vec<f32>,
    ifft: std::sync::Arc<dyn rustfft::Fft<f32>>,
    tmp: Vec<Complex32>,
    ola_buffer: Vec<f32>,
    write_pos: usize,
}

impl Istft {
    pub fn new(n: usize, hop: usize) -> Self {
        assert!(hop == n / 2);
        let mut planner = FftPlanner::<f32>::new();
        let ifft = planner.plan_fft_inverse(n);
        let window = hann_window_periodic(n);

        Self {
            n,
            hop,
            window,
            ifft,
            tmp: vec![Complex32::new(0.0, 0.0); n],
            ola_buffer: vec![0.0; n],
            write_pos: 0,
        }
    }

    pub fn process(&mut self, spec_half: &[Complex32]) -> Vec<f32> {
        let n = self.n;
        assert_eq!(spec_half.len(), n / 2 + 1);

        // Reconstruct Hermitian symmetry
        self.tmp[..=n / 2].copy_from_slice(&spec_half[..=n / 2]);
        for k in 1..n / 2 {
            self.tmp[n - k] = self.tmp[k].conj();
        }

        // IFFT
        self.ifft.process(&mut self.tmp);
        let inv_n = 1.0 / n as f32;

        // Apply window
        let mut win_frame = vec![0.0f32; n];
        for (i, win) in win_frame.iter_mut().enumerate().take(n) {
            *win = self.tmp[i].re * inv_n * self.window[i];
        }

        // Overlap-add
        for (i, acc) in win_frame.iter().enumerate().take(n) {
            let idx = (self.write_pos + i) % n;
            self.ola_buffer[idx] += *acc;
        }
        self.write_pos = (self.write_pos + self.hop) % n;

        // Output next hop
        let mut out = vec![0.0; self.hop];
        for (i, sample) in out.iter_mut().enumerate().take(self.hop) {
            let idx = (self.write_pos + i) % n;
            *sample = self.ola_buffer[idx];
            self.ola_buffer[idx] = 0.0;
        }
        out
    }
}

// ======================================================================
// FFT-based convolution ("same" mode)
// ======================================================================

/// FFT convolution with "same" output length (SciPy-compatible).
pub fn fft_convolve_same(x: &[f32], h: &[f32]) -> Vec<f32> {
    let nx = x.len();
    let nh = h.len();
    if nx == 0 || nh == 0 {
        return Vec::new();
    }

    // Use direct convolution for small signals
    let direct_limit: usize = 16_384;
    if nx.saturating_mul(nh) <= direct_limit {
        return conv_same_direct(x, h);
    }

    // Linear convolution via FFT
    let n_full = nx + nh - 1;
    let n_fft = n_full.next_power_of_two();

    let mut xa = vec![Complex32::new(0.0, 0.0); n_fft];
    let mut hb = vec![Complex32::new(0.0, 0.0); n_fft];

    for (i, &v) in x.iter().enumerate() {
        xa[i].re = v;
    }
    for (i, &v) in h.iter().enumerate() {
        hb[i].re = v;
    }

    let mut planner = FftPlanner::<f32>::new();
    let fft = planner.plan_fft_forward(n_fft);
    let ifft = planner.plan_fft_inverse(n_fft);

    fft.process(&mut xa);
    fft.process(&mut hb);

    // Multiply spectra
    for i in 0..n_fft {
        xa[i] *= hb[i];
    }

    // IFFT and scale
    ifft.process(&mut xa);
    let scale = 1.0 / n_fft as f32;

    let mut y_full = vec![0.0f32; n_full];
    for i in 0..n_full {
        y_full[i] = xa[i].re * scale;
    }

    // Crop "same" segment
    let start = (nh - 1) / 2;
    y_full[start..start + nx].to_vec()
}

#[inline]
fn conv_same_direct(x: &[f32], h: &[f32]) -> Vec<f32> {
    let nx = x.len();
    let nh = h.len();
    let n_full = nx + nh - 1;
    let mut y_full = vec![0.0f32; n_full];

    for i in 0..nx {
        let xi = x[i];
        for j in 0..nh {
            y_full[i + j] += xi * h[j];
        }
    }

    let start = (nh - 1) / 2;
    y_full[start..start + nx].to_vec()
}

pub fn linear_convolve_fft(a: &[f32], k: &[f32]) -> Vec<f32> {
    use rustfft::{FftPlanner, num_complex::Complex32};
    let n = a.len();
    let m = k.len();
    let l = (n + m - 1).next_power_of_two();
    let mut planner = FftPlanner::<f32>::new();
    let fft = planner.plan_fft_forward(l);
    let ifft = planner.plan_fft_inverse(l);

    let mut aspec = vec![Complex32::new(0.0, 0.0); l];
    let mut kspec = vec![Complex32::new(0.0, 0.0); l];
    for i in 0..n {
        aspec[i].re = a[i];
    }
    for i in 0..m {
        kspec[i].re = k[i];
    }

    fft.process(&mut aspec);
    fft.process(&mut kspec);
    for i in 0..l {
        aspec[i] *= kspec[i];
    }
    ifft.process(&mut aspec);

    let scale = 1.0 / (l as f32);
    let mut y = vec![0.0f32; n + m - 1];
    for i in 0..y.len() {
        y[i] = aspec[i].re * scale;
    }
    y
}

/// Compute analytic signal (Hilbert transform).
/// Returns complex output: real=input, imag=Hilbert(x).
pub fn hilbert(x: &[f32]) -> Vec<Complex32> {
    let n = x.len().next_power_of_two();
    let mut buf: Vec<Complex32> = x.iter().map(|&v| Complex32::new(v, 0.0)).collect();
    buf.resize(n, Complex32::new(0.0, 0.0));

    let mut planner = FftPlanner::new();
    let fft = planner.plan_fft_forward(n);
    let ifft = planner.plan_fft_inverse(n);

    // Forward FFT
    fft.process(&mut buf);

    // Frequency-domain multiplier
    let mut h = vec![Complex32::new(0.0, 0.0); n];
    if n > 0 {
        h[0] = Complex32::new(1.0, 0.0);
        if n.is_multiple_of(2) {
            h[n / 2] = Complex32::new(1.0, 0.0);
            for entry in h.iter_mut().take(n / 2).skip(1) {
                *entry = Complex32::new(2.0, 0.0);
            }
        } else {
            for entry in h.iter_mut().take(n.div_ceil(2)).skip(1) {
                *entry = Complex32::new(2.0, 0.0);
            }
        }
    }

    // Apply H and inverse FFT
    for (z, &w) in buf.iter_mut().zip(&h) {
        *z *= w;
    }
    ifft.process(&mut buf);

    // Normalize
    let scale = 1.0 / n as f32;
    buf.iter_mut().for_each(|z| *z *= scale);

    buf
}

// ======================================================================
// Utility
// ======================================================================

pub fn bin_freqs_hz(fs: f32, n: usize) -> Vec<f32> {
    (0..=n / 2).map(|k| k as f32 * fs / n as f32).collect()
}

// ======================================================================
// Tests
// ======================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;
    use rustfft::num_complex::Complex32;

    // ----- helpers -----

    // Reference "same" via explicit linear convolution then crop.
    fn same_ref(x: &[f32], h: &[f32]) -> Vec<f32> {
        let n = x.len();
        let m = h.len();
        let mut full = vec![0.0f32; n + m - 1];
        for i in 0..n {
            let xi = x[i];
            for j in 0..m {
                full[i + j] += xi * h[j];
            }
        }
        let start = (m - 1) / 2;
        full[start..start + n].to_vec()
    }

    // ==============================
    // Hann window: symmetric/periodic
    // ==============================

    #[test]
    fn test_hann_window_symmetric_sum() {
        let n = 1024;
        let w = hann_window_symmetric(n);
        assert!(w.iter().all(|&v| v >= 0.0));

        // Endpoints ~0 (allow small FP drift)
        assert!(w.first().unwrap().abs() < 1e-5, "first sample not ~0");
        assert!(w.last().unwrap().abs() < 1e-5, "last sample not ~0");

        // Energy check: mean(w^2) ≈ 3/8
        let u: f32 = w.iter().map(|&x| x * x).sum::<f32>() / n as f32;
        assert!((u - 0.375).abs() < 1e-3, "mean-square mismatch: {u}");
    }

    #[test]
    fn hann_window_periodic_props() {
        use std::f32::consts::PI;
        let n = 1024;
        let w = hann_window_periodic(n);

        // Non-negative; first sample ~0
        assert!(w.iter().all(|&v| v >= 0.0));
        assert!(w[0].abs() < 1e-5, "first sample not ~0");

        // Last sample close to closed-form value
        let last_expected = 0.5 * (1.0 - (2.0 * PI * ((n as f32 - 1.0) / n as f32)).cos());
        assert!(
            (w[n - 1] - last_expected).abs() < 1e-4,
            "last sample diff too large: got {}, expected {}",
            w[n - 1],
            last_expected
        );

        // Welch power normalization U ≈ 3/8
        let u: f32 = w.iter().map(|&x| x * x).sum::<f32>() / n as f32;
        assert!(
            (u - 0.375).abs() < 0.001,
            "mean-square mismatch: {} (expected ~0.375)",
            u
        );

        // COLA (hop=N/2): overlap-add is ~flat
        let hop = n / 2;
        let mut sum = vec![0.0f32; n + hop];
        for i in 0..n {
            sum[i] += w[i];
            sum[i + hop] += w[i];
        }
        let mid = n / 2;
        let avg = sum[mid - 32..mid + 32].iter().sum::<f32>() / 64.0;
        assert!((avg - 1.0).abs() < 0.01, "OLA not flat enough: avg={avg}");
    }

    #[test]
    fn hann_window_periodic_mean_is_half() {
        // For the periodic Hann, mean(w) = 0.5 exactly in discrete-time.
        let n = 1024;
        let w = hann_window_periodic(n);
        let mean = w.iter().sum::<f32>() / n as f32;
        assert!((mean - 0.5).abs() < 1e-6, "mean={}", mean);
    }

    #[test]
    fn hann_window_periodic_pairwise_sum_is_one() {
        // For hop = N/2, w[i] + w[i+N/2] = 1 for all i (up to FP).
        let n = 1024;
        let hop = n / 2;
        let w = hann_window_periodic(n);
        let mut max_err = 0.0f32;
        for i in 0..hop {
            let err = (w[i] + w[i + hop] - 1.0).abs();
            if err > max_err {
                max_err = err;
            }
        }
        assert!(max_err < 1e-6, "max_err={}", max_err);
    }

    #[test]
    fn hann_window_small_n_edges() {
        // N=1 policy in this codebase: return [1.0]
        assert_eq!(hann_window_symmetric(1), vec![1.0]);
        assert_eq!(hann_window_periodic(1), vec![1.0]);

        // N=2: symmetric=[0,0]; periodic=[0,1]
        assert_eq!(hann_window_symmetric(2), vec![0.0, 0.0]);
        let w2p = hann_window_periodic(2);
        assert!(w2p[0].abs() < 1e-7);
        assert!((w2p[1] - 1.0).abs() < 1e-7);
    }

    // ==============================
    // Blackman-Harris window: symmetric
    // ==============================

    #[test]
    fn blackman_harris_window_symmetric_props() {
        let n = 1024;
        let w = blackman_harris_window_symmetric(n);
        assert_eq!(w.len(), n);
        assert!(w.iter().all(|&v| v >= -1e-6));

        // Endpoints ~0 (allow small FP drift for coefficient rounding)
        assert!(w.first().unwrap().abs() < 1e-4, "first sample not ~0");
        assert!(w.last().unwrap().abs() < 1e-4, "last sample not ~0");

        // Symmetry
        let max_err = (0..n / 2)
            .map(|i| (w[i] - w[n - 1 - i]).abs())
            .fold(0.0f32, f32::max);
        assert!(max_err < 1e-6, "symmetry max_err={max_err}");
    }

    #[test]
    fn blackman_harris_window_small_n_edges() {
        assert_eq!(blackman_harris_window_symmetric(1), vec![1.0]);
        let w2 = blackman_harris_window_symmetric(2);
        assert_eq!(w2.len(), 2);
    }

    #[test]
    fn blackman_harris_window_sidelobe_level() {
        let n = 1024;
        let nfft = 16_384;
        let w = blackman_harris_window_symmetric(n);

        let mut buf = vec![Complex32::new(0.0, 0.0); nfft];
        for (i, &v) in w.iter().enumerate() {
            buf[i].re = v;
        }
        let mut planner = FftPlanner::<f32>::new();
        let fft = planner.plan_fft_forward(nfft);
        fft.process(&mut buf);

        let half = nfft / 2;
        let mags: Vec<f32> = buf[..half].iter().map(|z| z.norm()).collect();
        let peak = mags.iter().copied().fold(0.0f32, f32::max).max(1e-20);

        let thr = peak * 1e-4;
        let mut k = 1usize;
        while k < half && mags[k] >= thr {
            k += 1;
        }
        assert!(k < half, "main lobe extends too far");

        let side = mags[k..].iter().copied().fold(0.0f32, f32::max);
        if side > 0.0 {
            let side_db = 20.0 * (side / peak).log10();
            assert!(side_db < -70.0, "side lobe too high: {side_db:.2} dB");
        }
    }

    // ==============================
    // Window application
    // ==============================

    #[test]
    fn apply_hann_window_complex_props() {
        let n = 1024usize;

        // Input: linear ramp in the real part
        let mut buf: Vec<Complex32> = (0..n)
            .map(|i| Complex32::new(i as f32 / n as f32, 0.0))
            .collect();

        // Recreate the same periodic Hann
        let w: Vec<f32> = (0..n)
            .map(|i| 0.5 * (1.0 - (2.0 * std::f32::consts::PI * i as f32 / n as f32).cos()))
            .collect();

        // Reference U = mean(w^2)
        let u_ref: f32 = w.iter().map(|&v| v * v).sum::<f32>() / n as f32;

        // Apply and get U
        let u = apply_hann_window_complex(&mut buf);
        assert!((u - u_ref).abs() < 1e-3, "U mismatch: got {u}, ref {u_ref}");

        // Compare mean square to exact discrete expectation
        let expected_mean_sq: f32 = (0..n)
            .map(|i| {
                let x = i as f32 / n as f32;
                (x * w[i]).powi(2)
            })
            .sum::<f32>()
            / n as f32;

        let mean_sq: f32 = buf.iter().map(|z| z.re * z.re).sum::<f32>() / n as f32;
        let rel_err = (mean_sq - expected_mean_sq).abs() / expected_mean_sq.max(1e-12);
        assert!(
            rel_err < 5e-3,
            "mean_sq={mean_sq}, expected={expected_mean_sq}, rel_err={rel_err:.3e}"
        );

        // Endpoints
        let last_expected = ((n - 1) as f32 / n as f32) * w[n - 1];
        assert!(buf[0].re.abs() < 1e-7, "start not ~0: {}", buf[0].re);
        let diff_end = (buf[n - 1].re - last_expected).abs();
        assert!(
            diff_end < 1e-5 || buf[n - 1].re == 0.0,
            "end mismatch: got {}, expected {}, diff={diff_end}",
            buf[n - 1].re,
            last_expected
        );

        // Hann is non-negative
        assert!(
            buf.iter().all(|z| z.re >= 0.0),
            "Negative real samples found"
        );
    }

    #[test]
    fn apply_hann_window_real_returns_mean_square() {
        // For a buffer of ones, mean(x·w)^2 equals mean(w^2) = U.
        let n = 2048;
        let mut ones = vec![1.0f32; n];
        let u = apply_hann_window_real(&mut ones);
        let mean_sq: f32 = ones.iter().map(|&v| v * v).sum::<f32>() / n as f32;
        assert!((mean_sq - u).abs() < 1e-6, "mean_sq={}, U={}", mean_sq, u);
        assert!((u - 0.375).abs() < 1e-3);
    }

    // ==============================
    // FFT-based convolution ("same")
    // ==============================

    #[test]
    fn fft_convolve_same_impulse() {
        let x = vec![1.0, 0.0, 0.0, 0.0];
        let h = vec![0.0, 1.0, 0.0, 0.0];
        let y = fft_convolve_same(&x, &h);

        // Sum preserved (simple sanity)
        let sum_x: f32 = x.iter().sum();
        let sum_y: f32 = y.iter().sum();
        assert_relative_eq!(sum_x, sum_y, epsilon = 1e-6);

        // One peak, same length
        assert_eq!(y.len(), x.len());
        let max_i = y
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.total_cmp(b.1))
            .unwrap()
            .0;
        assert!(max_i < y.len());
    }

    #[test]
    fn fft_convolve_same_identity_with_centered_odd_kernel() {
        // With h = [0,1,0] (centered odd), "same" must equal x.
        let n = 64;
        let x: Vec<f32> = (0..n).map(|i| ((i as f32) * 0.1).sin()).collect();
        let h = vec![0.0, 1.0, 0.0];
        let y = fft_convolve_same(&x, &h);
        for (a, b) in y.iter().zip(x.iter()) {
            assert!((a - b).abs() < 1e-6);
        }
    }

    #[test]
    fn fft_convolve_same_matches_reference_small() {
        // Small sizes choose direct path; must match reference exactly.
        let n = 64;
        let m = 31; // odd
        let x: Vec<f32> = (0..n).map(|i| ((i as f32) * 0.013).sin()).collect();
        let h: Vec<f32> = (0..m).map(|i| ((i as f32) * 0.07).cos()).collect();

        let y = fft_convolve_same(&x, &h);
        let y_ref = same_ref(&x, &h);

        assert_eq!(y.len(), n);
        let max_err = y
            .iter()
            .zip(y_ref.iter())
            .map(|(a, b)| (a - b).abs())
            .fold(0.0, f32::max);
        assert!(max_err < 1e-6, "max_err={}", max_err);
    }

    #[test]
    fn fft_convolve_same_matches_reference_even_kernel() {
        // Even-length kernel; "same" cropping must still match reference.
        let n = 256;
        let m = 4; // even
        let x: Vec<f32> = (0..n).map(|i| ((i as f32) * 0.02).sin()).collect();
        let h = vec![0.25f32; m]; // simple box
        let y = fft_convolve_same(&x, &h);
        let y_ref = same_ref(&x, &h);

        let mae = y
            .iter()
            .zip(y_ref.iter())
            .map(|(a, b)| (a - b).abs())
            .sum::<f32>()
            / (n as f32);
        assert!(mae < 2e-6, "mae={}", mae);
    }

    #[test]
    fn fft_convolve_same_gaussian() {
        let n = 128;
        let mut g = vec![0.0; n];
        for i in 0..n {
            let x = (i as f32 - n as f32 / 2.0) / 10.0;
            g[i] = (-x * x).exp();
        }
        let y = fft_convolve_same(&g, &g);
        assert!(y[n / 2] > y[n / 4]); // center peak larger
    }

    #[test]
    fn fft_convolve_same_rect() {
        let x = vec![1.0; 32];
        let h = vec![1.0; 32];
        let y = fft_convolve_same(&x, &h);
        assert!(y.iter().all(|&v| v >= 0.0));
        let mid = y[y.len() / 2];
        assert!(mid > 10.0);
    }

    fn conv_naive(a: &[f32], b: &[f32]) -> Vec<f32> {
        let n = a.len();
        let m = b.len();
        let mut y = vec![0.0f32; n + m - 1];
        for i in 0..n {
            for j in 0..m {
                y[i + j] += a[i] * b[j];
            }
        }
        y
    }

    fn assert_close(a: &[f32], b: &[f32], tol: f32) {
        assert_eq!(
            a.len(),
            b.len(),
            "length mismatch: {} vs {}",
            a.len(),
            b.len()
        );
        for (i, (u, v)) in a.iter().zip(b.iter()).enumerate() {
            let d = (u - v).abs();
            assert!(
                d <= tol,
                "idx {} diff {} exceeds tol {}; u={}, v={}",
                i,
                d,
                tol,
                u,
                v
            );
        }
    }

    fn seq(len: usize, w1: f32, w2: f32) -> Vec<f32> {
        // deterministic, diverse values without RNG
        (0..len)
            .map(|i| {
                let x = i as f32;
                (x * w1).sin() + 0.25 * (x * w2).cos() + 0.1 * (x * (w1 + w2)).sin()
            })
            .collect()
    }

    #[test]
    fn length_and_values_match_naive_small_cases() {
        let cases = [
            (1usize, 1usize),
            (2, 3),
            (3, 2),
            (5, 5),
            (8, 13),
            (16, 7),
            (31, 9),
            (64, 33),
        ];
        for (n, m) in cases {
            let a = seq(n, 0.13, 0.07);
            let b = seq(m, 0.21, 0.05);
            let y_fft = linear_convolve_fft(&a, &b);
            let y_nv = conv_naive(&a, &b);
            assert_eq!(y_fft.len(), n + m - 1);
            assert_close(&y_fft, &y_nv, 1e-5);
        }
    }

    #[test]
    fn commutativity_holds() {
        let a = seq(37, 0.17, 0.11);
        let b = seq(23, 0.09, 0.06);
        let y_ab = linear_convolve_fft(&a, &b);
        let y_ba = linear_convolve_fft(&b, &a);
        assert_close(&y_ab, &y_ba, 1e-5);
    }

    #[test]
    fn impulse_and_shift() {
        // delta at 0 -> identity
        let b = seq(19, 0.12, 0.03);
        let y = linear_convolve_fft(&[1.0], &b);
        assert_close(&y, &b, 1e-6);

        // delta at index j -> right shift by j
        let j = 7usize;
        let mut a = vec![0.0f32; j + 1];
        a[j] = 1.0;
        let y = linear_convolve_fft(&a, &b);
        assert_eq!(y.len(), a.len() + b.len() - 1);
        // y[0..j] == 0
        assert!(y[..j].iter().all(|&v| v.abs() < 1e-6));
        // y[j..j+b.len()] == b
        assert_close(&y[j..j + b.len()], &b, 1e-6);
    }

    #[test]
    fn ones_rectangular_triangle() {
        // ones * ones -> triangle with plateau when lengths differ
        let a = vec![1.0f32; 5];
        let b = vec![1.0f32; 3];
        let y = linear_convolve_fft(&a, &b);
        let expected = vec![1.0, 2.0, 3.0, 3.0, 3.0, 2.0, 1.0];
        assert_close(&y, &expected, 1e-6);
    }

    #[test]
    fn primes_non_power_of_two_lengths_match_naive() {
        // hard case for FFT sizing and zero-padding
        let a = seq(97, 0.131, 0.071);
        let b = seq(113, 0.083, 0.047);
        let y_fft = linear_convolve_fft(&a, &b);
        let y_nv = conv_naive(&a, &b);
        assert_eq!(y_fft.len(), a.len() + b.len() - 1);
        assert_close(&y_fft, &y_nv, 2e-5);
    }

    #[test]
    fn zeros_propagate() {
        let a = vec![0.0f32; 17];
        let b = seq(9, 0.2, 0.15);
        let y = linear_convolve_fft(&a, &b);
        assert!(y.iter().all(|&v| v.abs() < 1e-7));
    }

    // ==============================
    // Hilbert transform
    // ==============================

    #[test]
    fn hilbert_signal_cosine() {
        use std::f32::consts::PI;

        let n = 1024; // power-of-two to match current implementation
        let freq = 5.0;
        let dt = 0.01;
        let signal: Vec<f32> = (0..n)
            .map(|i| (2.0 * PI * freq * i as f32 * dt).cos())
            .collect();

        let analytic = hilbert(&signal);
        assert_eq!(analytic.len(), signal.len());

        // Real part ≈ input
        let mse_real: f32 = signal
            .iter()
            .zip(analytic.iter())
            .map(|(a, b)| (a - b.re).powi(2))
            .sum::<f32>()
            / n as f32;
        assert!(mse_real < 1e-6, "Real part mismatch too large: {mse_real}");

        // Envelope ≈ 1 in the central region
        let start = n / 4;
        let end = 3 * n / 4;
        let avg_mag: f32 = analytic[start..end]
            .iter()
            .map(|c| (c.re.powi(2) + c.im.powi(2)).sqrt())
            .sum::<f32>()
            / (end - start) as f32;
        assert!((avg_mag - 1.0).abs() < 0.05, "Average magnitude {avg_mag}");
    }

    // ==============================
    // Utility
    // ==============================

    #[test]
    fn bin_freqs_hz_props() {
        let fs = 48000.0f32;
        let n = 1024usize;
        let f = bin_freqs_hz(fs, n);
        assert_eq!(f.len(), n / 2 + 1);
        assert!(f.windows(2).all(|w| w[1] > w[0]));
        assert!((f[0] - 0.0).abs() < 1e-12);
        assert!((f.last().unwrap() - fs / 2.0).abs() < 1e-6);
    }

    // ==============================
    // ISTFT (OLA)
    // ==============================

    #[test]
    fn istft_ola_dc_reconstruction_after_warmup() {
        // Feed pure-DC spectra; after one hop warmup, output should be ~1.0.
        let n = 1024;
        let hop = n / 2;
        let mut istft = Istft::new(n, hop);

        let mut out_all = Vec::new();
        for _ in 0..4 {
            let mut spec_half = vec![Complex32::new(0.0, 0.0); n / 2 + 1];
            // DC bin amplitude = n so that IFFT (1/n scaling) yields 1.0 samples.
            spec_half[0] = Complex32::new(n as f32, 0.0);
            out_all.extend(istft.process(&spec_half));
        }

        // Drop the first hop as warmup
        let steady = &out_all[hop..];
        let max_dev = steady.iter().map(|&v| (v - 1.0).abs()).fold(0.0, f32::max);
        assert!(max_dev < 2e-3, "max_dev={}", max_dev);
    }
}
</file>

<file path="src/core/harmonicity_kernel.rs">
//! core/harmonicity_kernel.rs
//! Common Root (Sibling) Harmonicity Kernel on Log2Space.
//!
//! This implementation generates a perc_potential_H landscape based on the physiological
//! mechanism of "Common Root" detection (approximating autocorrelation).
//!
//! Algorithm: "Sibling Projection"
//! 1. **Downward Projection (Root Search)**:
//!    Estimate the "Virtual Root" spectrum from the environment.
//!    If energy exists at f, it implies potential roots at f/2, f/3...
//!    (e.g., Env 200Hz -> Roots at 100Hz, 66Hz...)
//!
//! 2. **Upward Projection (Harmonic Resonance)**:
//!    From the estimated roots, project their natural harmonics.
//!    (e.g., Root 100Hz -> Stability at 100Hz, 200Hz, 300Hz, 400Hz...)
//!
//! Result:
//! An input of 200Hz naturally creates stability peaks at:
//! - 100Hz (Subharmonic)
//! - 400Hz (Octave)
//! - 300Hz (Perfect 5th via 100Hz root)
//! - 500Hz (Major 3rd via 100Hz root)
//!   ...without using any hardcoded ratio templates.

//!   core/harmonicity_kernel.rs
//!   Optimized Sibling Harmonicity Kernel.
//!
//! Uses a "Shift-and-Add" approach with pre-calculated bounds
//! to ensure O(N) efficiency and SIMD-friendly loops.

use crate::core::log2space::Log2Space;

#[derive(Clone, Copy, Debug)]
pub struct HarmonicityParams {
    /// Downward projections for root candidates.
    pub num_subharmonics: u32,
    /// Upward projections for harmonic candidates.
    pub num_harmonics: u32,
    /// Global cap on iteration count (overrides per-path counts if smaller).
    pub param_limit: u32,
    /// Decay exponent for Path A (common root path).
    pub rho_common_root: f32,
    /// Decay exponent for Path B (common overtone/undertone path).
    pub rho_common_overtone: f32,
    /// Gaussian smoothing width in cents on log2 spectrum.
    pub sigma_cents: f32,
    /// Normalize output to peak of 1.0.
    pub normalize_output: bool,
    /// Blend ratio: 0 = Path A only, 1 = Path B only.
    pub mirror_weight: f32,
    /// Apply absolute-frequency gating for TFS roll-off.
    pub freq_gate: bool,
    /// Frequency pivot for TFS gate (Hz).
    pub tfs_f_pl_hz: f32,
    /// Slope of TFS gate.
    pub tfs_eta: f32,
}

impl Default for HarmonicityParams {
    fn default() -> Self {
        Self {
            num_subharmonics: 10,
            num_harmonics: 8,
            param_limit: 16,
            rho_common_root: 0.4,
            rho_common_overtone: 0.2,
            sigma_cents: 3.0, // Slightly wider peaks to ease sampling
            normalize_output: true,
            mirror_weight: 0.3,
            freq_gate: false,
            tfs_f_pl_hz: 4500.0,
            tfs_eta: 4.0,
        }
    }
}

#[derive(Clone, Debug)]
pub struct HarmonicityKernel {
    pub bins_per_oct: u32,
    pub params: HarmonicityParams,
    smooth_kernel: Vec<f32>,
    pad_bins: usize, // Internal padding size
    limit: u32,
}

impl HarmonicityKernel {
    pub fn new(space: &Log2Space, params: HarmonicityParams) -> Self {
        let limit = Self::effective_limit(&params);

        // 1. Pre-calculate smoothing kernel
        let sigma_bins = params.sigma_cents / 1200.0 * space.bins_per_oct as f32;
        let half_width = (2.5 * sigma_bins).ceil() as usize;
        let width = 2 * half_width + 1;
        let mut k = vec![0.0f32; width];
        let mut sum = 0.0;
        for (i, kv) in k.iter_mut().enumerate().take(width) {
            let x = (i as isize - half_width as isize) as f32;
            *kv = (-0.5 * (x / sigma_bins).powi(2)).exp();
            sum += *kv;
        }
        for v in &mut k {
            *v /= sum;
        }

        // 2. Pre-calculate necessary padding
        // pad_bins must allow shifting both down (roots) and up (overtone mirror path).
        let max_oct = (limit as f32).max(1.0).log2();
        let pad_bins = (max_oct * space.bins_per_oct as f32).ceil() as usize;

        Self {
            bins_per_oct: space.bins_per_oct,
            params,
            smooth_kernel: k,
            pad_bins,
            limit,
        }
    }

    /// The core function: Env -> Roots -> Landscape
    pub fn potential_h_from_log2_spectrum(
        &self,
        envelope: &[f32],
        space: &Log2Space,
    ) -> (Vec<f32>, f32) {
        let n_bins = envelope.len();
        let bins_per_oct = self.bins_per_oct as f32;
        let mirror = self.params.mirror_weight.clamp(0.0, 1.0);
        let limit = self.limit.max(1);

        // Step 0: Smooth Input (O(N))
        let smeared_env = self.convolve_smooth(envelope);

        // Buffer for Virtual Roots / Overtones (centered with padding on both sides)
        let padding = self.pad_bins;
        let center_offset = padding as f32;
        let buf_len = n_bins + 2 * padding;
        let mut root_spectrum = vec![0.0f32; buf_len];
        let mut overtone_spectrum = vec![0.0f32; buf_len];

        // === Path A: Common Root / Overtone Series (down then up) ===
        for k in 1..=limit {
            let shift_bins = (k as f32).log2() * bins_per_oct;
            let weight = (k as f32).powf(-self.params.rho_common_root);
            let offset = center_offset - shift_bins;
            Self::accumulate_shifted(&smeared_env, &mut root_spectrum, offset, weight);
        }

        let mut landscape_a = vec![0.0f32; n_bins];
        for m in 1..=limit {
            let shift_bins = (m as f32).log2() * bins_per_oct;
            let weight = (m as f32).powf(-self.params.rho_common_root);
            let offset = shift_bins - center_offset;
            Self::accumulate_shifted(&root_spectrum, &mut landscape_a, offset, weight);
        }

        // === Path B: Common Overtone / Undertone Series (up then down) ===
        for k in 1..=limit {
            let shift_bins = (k as f32).log2() * bins_per_oct;
            let weight = (k as f32).powf(-self.params.rho_common_overtone);
            let offset = center_offset + shift_bins;
            Self::accumulate_shifted(&smeared_env, &mut overtone_spectrum, offset, weight);
        }

        let mut landscape_b = vec![0.0f32; n_bins];
        for m in 1..=limit {
            let shift_bins = (m as f32).log2() * bins_per_oct;
            let weight = (m as f32).powf(-self.params.rho_common_overtone);
            let offset = -shift_bins - center_offset;
            Self::accumulate_shifted(&overtone_spectrum, &mut landscape_b, offset, weight);
        }

        // Blend A/B
        let mut landscape = vec![0.0f32; n_bins];
        for i in 0..n_bins {
            landscape[i] = (1.0 - mirror) * landscape_a[i] + mirror * landscape_b[i];
        }

        // Step 3: Post-processing
        let mut max_val = 1e-12;
        let do_gate = self.params.freq_gate;
        let do_norm = self.params.normalize_output;

        // Combined loop for gating and max-finding (Auto-vectorized)
        for (i, v) in landscape.iter_mut().enumerate().take(n_bins) {
            if do_gate {
                *v *= Self::absfreq_gate(space.freq_of_index(i), &self.params);
            }
            if *v > max_val {
                max_val = *v;
            }
        }

        if do_norm {
            let scale = 1.0 / max_val;
            for v in &mut landscape {
                *v *= scale;
            }
            max_val = 1.0;
        }

        (landscape, max_val)
    }
    fn effective_limit(params: &HarmonicityParams) -> u32 {
        let fallback = params.num_subharmonics.max(params.num_harmonics).max(1);
        let limit = if params.param_limit == 0 {
            fallback
        } else {
            params.param_limit
        };
        limit.max(1)
    }
    /// Optimized Shift-and-Add with safe bounds checking.
    /// dst[i + offset] += src[i] * weight
    fn accumulate_shifted(src: &[f32], dst: &mut [f32], offset: f32, weight: f32) {
        let offset_i = offset.floor() as isize;
        let frac = offset - offset_i as f32;
        let w0 = weight * (1.0 - frac);
        let w1 = weight * frac;

        // Calculate valid iteration range for 'i' (index in src)
        // Constraints:
        // 1. 0 <= i < src.len()
        // 2. 0 <= i + offset_i < dst.len() - 1 (Need space for w1 interpolation)

        // Lower bound: i >= 0 AND i >= -offset_i
        let start_i = 0.max(-offset_i);

        // Upper bound (exclusive): i < src.len() AND i < dst.len() - 1 - offset_i
        let end_i = (src.len() as isize).min(dst.len() as isize - 1 - offset_i);

        // If range is invalid/empty, do nothing
        if start_i >= end_i {
            return;
        }

        let start = start_i as usize;
        let len = (end_i - start_i) as usize;

        // Destination start index
        // Since start >= -offset_i, (start + offset_i) is guaranteed >= 0
        let dst_start = (start as isize + offset_i) as usize;

        // Create slices for the hot loop (avoids bounds check inside loop)
        let src_slice = &src[start..start + len];
        let dst_slice = &mut dst[dst_start..dst_start + len + 1];

        for (k, &val) in src_slice.iter().enumerate() {
            // Unsafe get_unchecked could be used here for max speed,
            // but standard indexing is safe and fast enough due to slice bounds.
            dst_slice[k] += val * w0;
            dst_slice[k + 1] += val * w1;
        }
    }

    fn convolve_smooth(&self, input: &[f32]) -> Vec<f32> {
        // Convolution is heavy, but here kernel is small.
        // Optimization: Use separate loop for the main part to avoid boundary checks.
        let n = input.len();
        let mut output = vec![0.0; n];
        let k_len = self.smooth_kernel.len();
        let half = k_len / 2;

        // Naive but clear implementation.
        // For very large N, FFT conv is better, but here N ~ 200-4000, kernel ~ 5-10.
        // Direct convolution is faster.
        for (i, out_val) in output.iter_mut().enumerate().take(n) {
            let mut acc = 0.0;
            let start_k = half.saturating_sub(i);
            let end_k = if i + half >= n {
                k_len - (i + half - n + 1)
            } else {
                k_len
            };

            for j in start_k..end_k {
                let input_idx = i + j - half;
                acc += input[input_idx] * self.smooth_kernel[j];
            }
            *out_val = acc;
        }
        output
    }

    #[inline]
    fn absfreq_gate(f_hz: f32, p: &HarmonicityParams) -> f32 {
        1.0 / (1.0 + (f_hz / p.tfs_f_pl_hz).powf(p.tfs_eta))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::log2space::Log2Space;
    use plotters::prelude::*;
    use std::fs::File;
    use std::path::Path;

    #[test]
    fn test_minor_triad_lcm_reach() {
        let space = Log2Space::new(80.0, 2000.0, 180);
        let mut params = HarmonicityParams::default();
        params.mirror_weight = 1.0;
        let hk = HarmonicityKernel::new(&space, params);

        let mut env = vec![0.0; space.n_bins()];
        let triad = [200.0, 240.0, 300.0]; // 10:12:15 (Just minor triad)
        for &f in &triad {
            if let Some(idx) = space.index_of_freq(f) {
                env[idx] = 1.0;
            }
        }

        let (landscape, _) = hk.potential_h_from_log2_spectrum(&env, &space);
        let triad_indices: Vec<usize> = triad
            .iter()
            .filter_map(|&f| space.index_of_freq(f))
            .collect();

        let triad_max = triad_indices
            .iter()
            .map(|&i| landscape[i])
            .fold(0.0f32, f32::max);
        let other_max = landscape
            .iter()
            .enumerate()
            .filter(|(i, _)| !triad_indices.contains(i))
            .map(|(_, &v)| v)
            .fold(0.0f32, f32::max);

        assert!(
            triad_max >= other_max * 0.9,
            "Mirror path should reinforce triad members via common overtone"
        );
        for idx in triad_indices {
            assert!(
                landscape[idx] > 1e-3,
                "Triad bin should accumulate stability"
            );
        }
    }

    #[test]
    fn test_param_limit_caps_iterations() {
        let space = Log2Space::new(50.0, 800.0, 160);
        let mut params_full = HarmonicityParams::default();
        params_full.normalize_output = false;
        params_full.param_limit = 6;
        let hk_full = HarmonicityKernel::new(&space, params_full);

        let mut params_limited = params_full;
        params_limited.param_limit = 1;
        let hk_limited = HarmonicityKernel::new(&space, params_limited);

        let mut env = vec![0.0; space.n_bins()];
        if let Some(idx) = space.index_of_freq(200.0) {
            env[idx] = 1.0;
        }

        let (land_full, _) = hk_full.potential_h_from_log2_spectrum(&env, &space);
        let (land_limited, _) = hk_limited.potential_h_from_log2_spectrum(&env, &space);

        let idx_300 = space.index_of_freq(300.0).expect("bin exists");
        let ratio = land_limited[idx_300] / land_full[idx_300].max(1e-6);
        assert!(
            ratio < 0.9,
            "Higher-order peaks should diminish when param_limit is small (ratio={ratio})"
        );
    }

    #[test]
    fn test_sibling_consonance_creation() {
        // Input: 200Hz.
        // We expect peaks at:
        // - 100Hz (Root)
        // - 400Hz (Octave)
        // - 300Hz (Perfect 5th via 100Hz root)

        let space = Log2Space::new(50.0, 800.0, 200);
        let params = HarmonicityParams::default();

        let hk = HarmonicityKernel::new(&space, params);

        let mut env = vec![0.0; space.n_bins()];
        let idx_200 = space.index_of_freq(200.0).unwrap();
        env[idx_200] = 1.0;

        let (landscape, _) = hk.potential_h_from_log2_spectrum(&env, &space);

        let idx_300 = space.index_of_freq(300.0).unwrap();
        let idx_283 = space.index_of_freq(283.0).unwrap(); // Dissonant (Tritone-ish)

        // 300Hz should be stable because:
        // 200 -> Root 100.
        // Root 100 -> Harmonic 300.
        assert!(
            landscape[idx_300] > 0.2,
            "300Hz (Perfect 5th) should be a peak"
        );
        assert!(
            landscape[idx_300] > landscape[idx_283] * 1.5,
            "5th should be much more stable than tritone"
        );
    }

    #[test]
    fn test_complex_ratios_detection() {
        // Test: Can we detect 7:4 (Harmonic 7th) and 6:5 (Minor 3rd)?

        let space = Log2Space::new(20.0, 1600.0, 100);
        let params = HarmonicityParams::default();

        let hk = HarmonicityKernel::new(&space, params);

        let mut env = vec![0.0; space.n_bins()];
        let f_input = 400.0;
        if let Some(idx) = space.index_of_freq(f_input) {
            env[idx] = 1.0;
        }

        let (landscape, _) = hk.potential_h_from_log2_spectrum(&env, &space);

        let idx_m3 = space.index_of_freq(400.0 * 1.2).unwrap(); // 6:5
        let idx_h7 = space.index_of_freq(400.0 * 1.75).unwrap(); // 7:4

        // Tritone (approx 1.414).
        // Note: This is close to 7:5 (1.40), so it will have significant potential!
        let idx_tritone = space.index_of_freq(400.0 * 1.414).unwrap();

        println!("Potential at 6:5 (m3): {}", landscape[idx_m3]);
        println!("Potential at 7:4 (h7): {}", landscape[idx_h7]);
        println!("Potential at Tritone:  {}", landscape[idx_tritone]);

        assert!(
            landscape[idx_m3] > landscape[idx_tritone] * 1.1,
            "6:5 should be more stable than tritone"
        );
        assert!(
            landscape[idx_h7] > landscape[idx_tritone] * 1.1,
            "7:4 should be more stable than tritone"
        );
    }

    #[test]
    #[ignore]
    fn plot_sibling_landscape_png() {
        let space = Log2Space::new(20.0, 8000.0, 200);

        let p = HarmonicityParams::default();
        let hk = HarmonicityKernel::new(&space, p);

        let mut env = vec![0.0; space.n_bins()];
        let f_input = 440.0;
        if let Some(idx) = space.index_of_freq(f_input) {
            env[idx] = 1.0;
        }

        let (y, _) = hk.potential_h_from_log2_spectrum(&env, &space);
        let xs: Vec<f32> = (0..space.n_bins())
            .map(|i| space.freq_of_index(i))
            .collect();

        let out_path = Path::new("target/test_sibling_landscape.png");
        let root = BitMapBackend::new(out_path, (1200, 600)).into_drawing_area();
        root.fill(&WHITE).unwrap();

        let mut chart = ChartBuilder::on(&root)
            .caption(
                format!("Sibling Landscape (Input: {}Hz)", f_input),
                ("sans-serif", 20),
            )
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(40)
            .build_cartesian_2d(20.0f32..8000.0f32, 0.0f32..1.05f32)
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("Frequency [Hz]")
            .y_desc("Potential (0.0 - 1.0)")
            .y_labels(10)
            .draw()
            .unwrap();

        chart
            .draw_series(LineSeries::new(
                xs.iter().zip(y.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))
            .unwrap();

        // Mark expected mergent ratios
        let markers = vec![
            (f_input * 1.5, "3:2", RED),
            (f_input * 1.25, "5:4", MAGENTA),
            (f_input * 0.5, "1:2", GREEN),
            (f_input * 2.0, "2:1", GREEN),
        ];

        for (freq, _label, color) in markers {
            chart
                .draw_series(std::iter::once(PathElement::new(
                    vec![(freq, 0.0), (freq, 1.0)],
                    color.mix(0.5),
                )))
                .unwrap();
        }

        root.present().unwrap();
        assert!(File::open(out_path).is_ok());
    }
}
</file>

<file path="src/core/harmonicity_worker.rs">
use std::sync::Arc;

use crossbeam_channel::{Receiver, Sender};

use crate::core::landscape::LandscapeUpdate;
use crate::core::stream::harmonicity::HarmonicityStream;

/// Result payload from the harmonicity worker:
/// `(frame_id, h_scan, body_log_spectrum)`.
pub type HarmonicityResult = (u64, Vec<f32>, Vec<f32>);

/// Harmonicity worker: receives mixed log2 spectral bodies, computes harmonicity only, and
/// publishes the result for the main thread to merge.
pub fn run(
    mut stream: HarmonicityStream,
    spectrum_rx: Receiver<(u64, Arc<[f32]>)>,
    result_tx: Sender<HarmonicityResult>,
    update_rx: Receiver<LandscapeUpdate>,
) {
    while let Ok((mut frame_id, mut spectrum_body)) = spectrum_rx.recv() {
        // Drain backlog and keep only the most recent spectrum to avoid fixed lag.
        for (latest_id, latest_body) in spectrum_rx.try_iter() {
            frame_id = latest_id;
            spectrum_body = latest_body;
        }

        for upd in update_rx.try_iter() {
            stream.update_params(upd);
        }

        let (h_scan, amps_log) = stream.process(spectrum_body.as_ref());
        let _ = result_tx.try_send((frame_id, h_scan, amps_log));
    }
}
</file>

<file path="src/core/landscape_spectral.rs">
//! Shared spectral front-end for landscape processing.
//! NSGT power -> peak extraction -> delta + loudness -> leaky normalization.

use crate::core::a_weighting;
use crate::core::density;
use crate::core::landscape::LandscapeParams;
use crate::core::log2space::Log2Space;
use crate::core::peak_extraction::{Peak, PeakExtractConfig, extract_peaks_density_with_grid};
use crate::core::roughness_kernel::erb_grid;

#[derive(Clone, Debug)]
pub struct SpectralFrame {
    pub subjective_intensity: Vec<f32>,
    pub loudness_mass: f32,
    pub peaks_raw: Vec<Peak>,
}

pub struct SpectralFrontEnd {
    space: Log2Space,
    erb: Vec<f32>,
    du: Vec<f32>,
    loudness_weights_pow: Vec<f32>,
    norm_state: Vec<f32>,
    peak_cfg: PeakExtractConfig,
}

impl SpectralFrontEnd {
    pub fn new(space: Log2Space, _params: &LandscapeParams) -> Self {
        let (erb, du) = erb_grid(&space);
        let loudness_weights_pow = space
            .centers_hz
            .iter()
            .map(|&f| a_weighting::a_weighting_gain_pow(f))
            .collect::<Vec<f32>>();
        let n = space.n_bins();
        Self {
            space,
            erb,
            du,
            loudness_weights_pow,
            norm_state: vec![0.0; n],
            peak_cfg: PeakExtractConfig::nsgt_default(),
        }
    }

    pub fn reset(&mut self) {
        self.norm_state.fill(0.0);
    }

    pub fn process_nsgt_power(
        &mut self,
        nsgt_power: &[f32],
        dt_sec: f32,
        params: &LandscapeParams,
    ) -> SpectralFrame {
        debug_assert_eq!(nsgt_power.len(), self.space.n_bins());
        assert_eq!(nsgt_power.len(), self.du.len());

        let exp = params.loudness_exp.max(0.01);
        let tau_s = params.tau_ms.max(1.0) * 1e-3;
        let a = (-dt_sec / tau_s).exp();
        let ref_power = params.ref_power.max(1e-12);

        let mut raw_density = vec![0.0f32; nsgt_power.len()];
        for (i, &pow) in nsgt_power.iter().enumerate() {
            let dui = self.du[i].max(1e-12);
            let density = (pow / dui).max(0.0);
            raw_density[i] = density;
        }

        let peaks =
            extract_peaks_density_with_grid(&raw_density, &self.erb, &self.du, &self.peak_cfg);

        let mut subj_density_delta = vec![0.0f32; nsgt_power.len()];
        for peak in &peaks {
            if peak.bin_idx >= self.du.len() {
                continue;
            }
            let dui = self.du[peak.bin_idx];
            if dui <= 0.0 {
                continue;
            }
            let weight_pow = self.loudness_weights_pow[peak.bin_idx];
            let subj_mass = ((peak.mass * weight_pow) / ref_power).powf(exp);
            subj_density_delta[peak.bin_idx] += subj_mass / dui;
        }

        let mut subjective_intensity = vec![0.0f32; nsgt_power.len()];
        for i in 0..nsgt_power.len() {
            let y = a * self.norm_state[i] + (1.0 - a) * subj_density_delta[i];
            self.norm_state[i] = y;
            subjective_intensity[i] = y;
        }

        let loudness_mass = density::density_to_mass(&subjective_intensity, &self.du);

        SpectralFrame {
            subjective_intensity,
            loudness_mass,
            peaks_raw: peaks,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::harmonicity_kernel::{HarmonicityKernel, HarmonicityParams};
    use crate::core::landscape::{LandscapeParams, RoughnessScalarMode};
    use crate::core::log2space::Log2Space;
    use crate::core::roughness_kernel::{KernelParams, RoughnessKernel};

    fn build_params(fs: f32, space: &Log2Space) -> LandscapeParams {
        LandscapeParams {
            fs,
            max_hist_cols: 1,
            alpha: 0.0,
            roughness_kernel: RoughnessKernel::new(KernelParams::default(), 0.005),
            harmonicity_kernel: HarmonicityKernel::new(space, HarmonicityParams::default()),
            roughness_scalar_mode: RoughnessScalarMode::Total,
            roughness_half: 0.1,
            consonance_roughness_weight: 0.5,
            loudness_exp: 1.0,
            ref_power: 1.0,
            tau_ms: 1.0,
            roughness_k: 1.0,
            roughness_ref_f0_hz: 1000.0,
            roughness_ref_sep_erb: 0.25,
            roughness_ref_mass_split: 0.5,
            roughness_ref_eps: 1e-12,
        }
    }

    fn build_frontend(fs: f32) -> (SpectralFrontEnd, LandscapeParams) {
        let space = Log2Space::new(200.0, 4000.0, 12);
        let params = build_params(fs, &space);
        let frontend = SpectralFrontEnd::new(space, &params);
        (frontend, params)
    }

    #[test]
    fn loudness_scales_with_power_input() {
        let fs = 48_000.0;
        let (mut frontend, params) = build_frontend(fs);
        let n = frontend.space.n_bins();
        let mut base = vec![0.0f32; n];
        let peak = n / 2;
        base[peak] = 1.0;
        let scaled: Vec<f32> = base.iter().map(|v| v * 4.0).collect();

        let out1 = frontend.process_nsgt_power(&base, 1.0, &params);
        let mut frontend2 = SpectralFrontEnd::new(frontend.space.clone(), &params);
        let out2 = frontend2.process_nsgt_power(&scaled, 1.0, &params);

        let v1 = out1.subjective_intensity[peak];
        assert!(v1 > 1e-6, "unexpected near-zero normalized power");
        let ratio = out2.subjective_intensity[peak] / v1;
        assert!(
            (ratio - 4.0).abs() < 0.1,
            "expected ~4x scaling for power input, got {ratio:.3}"
        );
    }

    #[test]
    fn a_weighting_uses_power_gain() {
        let fs = 48_000.0;
        let (frontend, _params) = build_frontend(fs);
        let i = frontend.loudness_weights_pow.len() / 2;
        let f = frontend.space.centers_hz[i];
        let expected = a_weighting::a_weighting_gain_pow(f);
        let got = frontend.loudness_weights_pow[i];
        assert!(
            (got - expected).abs() < 1e-6,
            "expected A-weighting power gain, got {got:.6} vs {expected:.6}"
        );
    }
}
</file>

<file path="src/core/modulation.rs">
use std::f32::consts::TAU;
use tracing::debug;

use crate::core::phase::wrap_pm_pi;

fn smoothstep(lo: f32, hi: f32, x: f32) -> f32 {
    if hi <= lo {
        return 0.0;
    }
    let t = ((x - lo) / (hi - lo)).clamp(0.0, 1.0);
    t * t * (3.0 - 2.0 * t)
}

#[derive(Clone, Copy, Debug, Default)]
pub struct RhythmBand {
    pub phase: f32,   // wrapped [-pi, pi]
    pub freq_hz: f32, // tracked tempo
    pub mag: f32,     // presence
    pub alpha: f32,   // precision
    pub beta: f32,    // prediction error
}

#[derive(Clone, Copy, Debug, Default)]
pub struct NeuralRhythms {
    pub theta: RhythmBand,
    pub delta: RhythmBand,
    pub env_open: f32,
    pub env_level: f32,
}

#[derive(Clone, Copy, Debug)]
pub struct AdaptiveRhythmParams {
    pub f_min_hz: f32,
    pub f_max_hz: f32,
    pub init_hz: f32,
    pub eta_mag: f32,
    pub eta_omega: f32,
    pub eta_phi: f32,
    pub tau_beta: f32,
    pub alpha_k: f32,
    pub noise_floor: f32,
    pub shape_p: f32,
}

#[derive(Clone, Debug)]
pub struct AdaptiveRhythm {
    pub phi: f32,   // unwrapped phase
    pub omega: f32, // rad/s
    pub mag: f32,
    pub beta: f32,
    pub alpha: f32,
    // Parameters
    f_min_hz: f32,
    f_max_hz: f32,
    eta_mag: f32,
    eta_omega: f32,
    eta_phi: f32,
    tau_beta: f32,
    alpha_k: f32,
    noise_floor: f32,
    shape_p: f32,
}

impl AdaptiveRhythm {
    pub fn new(params: AdaptiveRhythmParams) -> Self {
        let init_hz = params.init_hz.clamp(params.f_min_hz, params.f_max_hz);
        Self {
            phi: 0.0,
            omega: TAU * init_hz,
            mag: 0.1,
            beta: 0.0,
            alpha: 0.5,
            f_min_hz: params.f_min_hz,
            f_max_hz: params.f_max_hz,
            eta_mag: params.eta_mag,
            eta_omega: params.eta_omega,
            eta_phi: params.eta_phi,
            tau_beta: params.tau_beta,
            alpha_k: params.alpha_k,
            noise_floor: params.noise_floor,
            shape_p: params.shape_p,
        }
    }

    fn template(&self, phi: f32) -> f32 {
        let c = phi.cos();
        if c <= 0.0 { 0.0 } else { c.powf(self.shape_p) }
    }

    fn template_prime(&self, phi: f32) -> f32 {
        let c = phi.cos();
        if c <= 0.0 {
            0.0
        } else {
            let base = c.powf(self.shape_p - 1.0);
            -self.shape_p * base * phi.sin()
        }
    }

    pub fn update(&mut self, dt: f32, u: f32, vitality: f32) -> RhythmBand {
        let dt = dt.max(1e-4);
        let v = vitality.clamp(0.0, 1.0);
        let u = u.clamp(0.0, 1.0);

        let phi_wrapped = wrap_pm_pi(self.phi);
        let g = self.template(phi_wrapped);
        let y = self.mag * g;
        let r = u - y;

        let a_beta = (-dt / self.tau_beta.max(1e-4)).exp();
        let target_beta = (r * r).clamp(0.0, 1.0);
        self.beta = a_beta * self.beta + (1.0 - a_beta) * target_beta;
        self.beta = self.beta.clamp(0.0, 1.0);

        let alpha_raw = 1.0 / (1.0 + self.alpha_k * self.beta + self.noise_floor);
        self.alpha = alpha_raw.clamp(0.0, 1.0);

        // Vitality scales learning rates with a non-zero floor to avoid stalling.
        let v_scale = 0.5 + 0.5 * v;
        let eta_mag = self.eta_mag * v_scale;
        let eta_omega = self.eta_omega * v_scale;
        let eta_phi = self.eta_phi * v_scale;

        self.mag += eta_mag * self.alpha * r * g;
        self.mag = self.mag.clamp(0.0, 1.0);

        let grad = self.alpha * r * self.mag * self.template_prime(phi_wrapped);
        self.omega += eta_omega * grad;
        let min_omega = TAU * self.f_min_hz;
        let max_omega = TAU * self.f_max_hz;
        self.omega = self.omega.clamp(min_omega, max_omega);

        self.phi += (self.omega + eta_phi * grad) * dt;
        let phi_out = wrap_pm_pi(self.phi);

        RhythmBand {
            phase: phi_out,
            freq_hz: self.omega / TAU,
            mag: self.mag,
            alpha: self.alpha,
            beta: self.beta,
        }
    }

    fn clamp_omega(&self, omega: f32) -> f32 {
        let min_omega = TAU * self.f_min_hz;
        let max_omega = TAU * self.f_max_hz;
        omega.clamp(min_omega, max_omega)
    }
}

#[derive(Clone, Debug)]
pub struct RhythmEngine {
    pub theta: AdaptiveRhythm,
    pub delta: AdaptiveRhythm,
    last: NeuralRhythms,
    debug_timer: f32,
    metrics_timer: f32,
    prev_u_theta: f32,
    onset_baseline: f32,
    onset_var: f32,
    onset_timer: f32,
    onset_sum_cos: f32,
    onset_sum_sin: f32,
    onset_count: u32,
    time_since_last_onset: f32,
    ioi_ema: f32,
    ioi_valid: bool,
    last_ioi: f32,
    last_phase_err: f32,
}

impl Default for RhythmEngine {
    fn default() -> Self {
        // Defaults: theta 3-12 Hz, delta 0.2-3 Hz; tau_beta=0.12/0.3s; eta_mag=0.45/0.35,
        // eta_omega=0.08/0.05, eta_phi=0.04/0.03 to keep adaptation stable.
        let theta = AdaptiveRhythm::new(AdaptiveRhythmParams {
            f_min_hz: 3.0,
            f_max_hz: 12.0,
            init_hz: 6.0,
            eta_mag: 0.45,
            eta_omega: 0.08,
            eta_phi: 0.04,
            tau_beta: 0.12,
            alpha_k: 4.0,
            noise_floor: 0.02,
            shape_p: 4.0,
        });
        let delta = AdaptiveRhythm::new(AdaptiveRhythmParams {
            f_min_hz: 0.2,
            f_max_hz: 3.0,
            init_hz: 1.0,
            eta_mag: 0.35,
            eta_omega: 0.05,
            eta_phi: 0.03,
            tau_beta: 0.3,
            alpha_k: 3.0,
            noise_floor: 0.03,
            shape_p: 4.0,
        });
        Self {
            theta,
            delta,
            last: NeuralRhythms::default(),
            debug_timer: 0.0,
            metrics_timer: 0.0,
            prev_u_theta: 0.0,
            onset_baseline: 0.0,
            onset_var: 0.0,
            onset_timer: 0.0,
            onset_sum_cos: 0.0,
            onset_sum_sin: 0.0,
            onset_count: 0,
            time_since_last_onset: 0.0,
            ioi_ema: 0.0,
            ioi_valid: false,
            last_ioi: 0.0,
            last_phase_err: 0.0,
        }
    }
}

impl RhythmEngine {
    pub fn new() -> Self {
        Self::default()
    }

    pub fn update(&mut self, dt: f32, u_theta: f32, u_delta: f32, vitality: f32) -> NeuralRhythms {
        let phi_before = self.theta.phi;
        let phase_before = wrap_pm_pi(phi_before);
        let omega_before = self.theta.omega;
        let tau = 1.0;
        let a = (-dt / tau).exp();
        self.onset_baseline = a * self.onset_baseline + (1.0 - a) * u_theta;
        let dev = u_theta - self.onset_baseline;
        self.onset_var = a * self.onset_var + (1.0 - a) * dev * dev;
        let std = self.onset_var.max(1e-6).sqrt();
        let onset_th_raw = self.onset_baseline + 2.0 * std;
        let onset_th = onset_th_raw.clamp(0.01, 0.95);
        let refractory = 0.08;
        self.onset_timer = (self.onset_timer - dt).max(0.0);
        self.time_since_last_onset += dt;
        let mut onset_fired = false;
        let mut onset_phase = phase_before;
        if self.onset_timer <= 0.0 && self.prev_u_theta < onset_th && u_theta >= onset_th {
            let denom = (u_theta - self.prev_u_theta).max(1e-6);
            let frac = ((onset_th - self.prev_u_theta) / denom).clamp(0.0, 1.0);
            onset_phase = wrap_pm_pi(phi_before + omega_before * dt * frac);
            self.onset_sum_cos += onset_phase.cos();
            self.onset_sum_sin += onset_phase.sin();
            self.onset_count += 1;
            self.onset_timer = refractory;
            onset_fired = true;
        }
        self.prev_u_theta = u_theta;

        let mut theta = self.theta.update(dt, u_theta, vitality);
        if onset_fired {
            let ioi = self.time_since_last_onset;
            let ioi_ok = (0.05..=0.5).contains(&ioi);
            if ioi_ok {
                if !self.ioi_valid {
                    self.ioi_ema = ioi;
                    self.ioi_valid = true;
                } else {
                    self.ioi_ema = self.ioi_ema + (ioi - self.ioi_ema) * 0.25;
                }
                self.last_ioi = ioi;
                let omega_meas = TAU / self.ioi_ema.max(1e-4);
                self.theta.omega = self.theta.omega + (omega_meas - self.theta.omega) * 0.35;
                self.theta.omega = self.theta.clamp_omega(self.theta.omega);
                let phase_err = onset_phase;
                self.last_phase_err = phase_err;
                self.theta.phi -= 0.5 * phase_err;
            }
            self.time_since_last_onset = 0.0;
            theta = RhythmBand {
                phase: wrap_pm_pi(self.theta.phi),
                freq_hz: self.theta.omega / TAU,
                mag: self.theta.mag,
                alpha: self.theta.alpha,
                beta: self.theta.beta,
            };
        }
        let delta = self.delta.update(dt, u_delta, vitality);
        let env_wave = 0.5 + 0.5 * delta.phase.cos();
        let delta_conf = (delta.mag * delta.alpha).clamp(0.0, 1.0);
        let env_open = compute_env_open(delta.phase, delta.mag, delta.alpha);
        let env_level = u_delta.clamp(0.0, 1.0);

        self.debug_timer += dt;
        if self.debug_timer >= 1.0 {
            debug!(
                target: "rhythm::engine",
                u_theta,
                u_delta,
                theta_freq_hz = theta.freq_hz,
                theta_mag = theta.mag,
                theta_alpha = theta.alpha,
                theta_beta = theta.beta,
                theta_phase = theta.phase,
                delta_freq_hz = delta.freq_hz,
                delta_mag = delta.mag,
                delta_alpha = delta.alpha,
                delta_beta = delta.beta,
                delta_phase = delta.phase,
                delta_conf,
                env_wave,
                env_open,
                env_level
            );
            self.debug_timer = 0.0;
        }

        self.metrics_timer += dt;
        if self.metrics_timer >= 1.0 {
            let (plv, mean_phase) = if self.onset_count > 0 {
                let sum_cos = self.onset_sum_cos;
                let sum_sin = self.onset_sum_sin;
                let denom = self.onset_count as f32;
                let plv = (sum_cos * sum_cos + sum_sin * sum_sin).sqrt() / denom;
                (plv, sum_sin.atan2(sum_cos))
            } else {
                (0.0, 0.0)
            };
            debug!(
                target: "rhythm::metrics",
                onset_count = self.onset_count,
                onset_plv_theta = plv,
                onset_mean_phase_theta = mean_phase,
                onset_th,
                u_theta,
                onset_baseline = self.onset_baseline,
                onset_std = std,
                theta_ioi_last = self.last_ioi,
                theta_ioi_ema = self.ioi_ema,
                theta_freq_from_ioi = if self.ioi_valid {
                    1.0 / self.ioi_ema.max(1e-4)
                } else {
                    0.0
                },
                theta_phase_err_at_onset = self.last_phase_err,
                theta_freq_hz = theta.freq_hz,
                theta_alpha = theta.alpha,
                theta_beta = theta.beta
            );
            self.metrics_timer = 0.0;
            self.onset_sum_cos = 0.0;
            self.onset_sum_sin = 0.0;
            self.onset_count = 0;
        }

        self.last = NeuralRhythms {
            theta,
            delta,
            env_open,
            env_level,
        };
        self.last
    }

    pub fn last(&self) -> NeuralRhythms {
        self.last
    }
}

fn compute_env_open(delta_phase: f32, delta_mag: f32, delta_alpha: f32) -> f32 {
    let env_wave = 0.5 + 0.5 * delta_phase.cos();
    let delta_conf = (delta_mag * delta_alpha).clamp(0.0, 1.0);
    let min_depth = 0.15;
    let mag_scale = smoothstep(0.02, 0.08, delta_mag);
    let depth = (min_depth + (1.0 - min_depth) * delta_conf) * (0.2 + 0.8 * mag_scale);
    (1.0 - depth * (1.0 - env_wave)).clamp(0.0, 1.0)
}

impl NeuralRhythms {
    pub fn advance_in_place(&mut self, dt: f32) {
        if dt <= 0.0 {
            return;
        }
        self.theta.phase = wrap_pm_pi(self.theta.phase + TAU * self.theta.freq_hz * dt);
        self.delta.phase = wrap_pm_pi(self.delta.phase + TAU * self.delta.freq_hz * dt);
        self.env_open = compute_env_open(self.delta.phase, self.delta.mag, self.delta.alpha);
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn theta_locks_to_pulse_rate() {
        let mut engine = RhythmEngine::default();
        let dt = 0.01;
        let mut t = 0.0;
        for _ in 0..3000 {
            let phase = (t * 5.0) % 1.0;
            let u_theta = if phase < 0.1 { 1.0 } else { 0.0 };
            let u_delta = 0.2;
            engine.update(dt, u_theta, u_delta, 1.0);
            t += dt;
        }
        let freq = engine.last().theta.freq_hz;
        assert!(
            (freq - 5.0).abs() < 1.0,
            "theta should converge near 5Hz, got {freq}"
        );
    }

    #[test]
    fn delta_tracks_slow_envelope() {
        let mut engine = RhythmEngine::default();
        let dt = 0.02;
        let mut t = 0.0;
        for _ in 0..2000 {
            let u_theta = 0.0;
            let u_delta = 0.5 + 0.5 * (TAU * 0.5 * t).sin();
            engine.update(dt, u_theta, u_delta, 1.0);
            t += dt;
        }
        let freq = engine.last().delta.freq_hz;
        assert!(
            (freq - 0.5).abs() < 0.4,
            "delta should sit near 0.5Hz, got {freq}"
        );
    }

    #[test]
    fn env_level_tracks_u_delta_when_confidence_low() {
        let mut engine = RhythmEngine::default();
        engine.delta.mag = 0.0;
        engine.delta.alpha = 0.0;
        engine.delta.beta = 1.0;
        engine.delta.phi = 0.0;
        engine.delta.omega = TAU;
        let u_delta = 0.7;
        let rhythms = engine.update(0.01, 0.0, u_delta, 1.0);
        assert!(
            (rhythms.env_level - u_delta).abs() < 0.1,
            "env_level should stay near u_delta when delta confidence is low"
        );
        assert!(
            (rhythms.env_open - 1.0).abs() < 0.2,
            "env_open should stay open when delta confidence is low"
        );
    }

    #[test]
    fn env_open_modulates_when_confidence_high() {
        let mut engine = RhythmEngine::default();
        engine.delta.mag = 1.0;
        engine.delta.alpha = 1.0;
        engine.delta.beta = 0.0;
        engine.delta.phi = 0.0;
        engine.delta.omega = TAU;
        let mut min_env: f32 = 1.0;
        let mut max_env: f32 = 0.0;
        for _ in 0..8 {
            let r = engine.update(0.25, 0.0, 1.0, 1.0);
            min_env = min_env.min(r.env_open);
            max_env = max_env.max(r.env_open);
        }
        assert!(
            (max_env - min_env) > 0.2,
            "env_open should oscillate when delta confidence is high"
        );
    }

    #[test]
    fn theta_phase_locks_to_pulse_train_plv() {
        let mut engine = RhythmEngine::default();
        let dt = 0.01;
        let mut t = 0.0;
        let mut sum_cos = 0.0;
        let mut sum_sin = 0.0;
        let mut count: f32 = 0.0;
        for _ in 0..4000 {
            let phase = (t * 6.0) % 1.0;
            let u_theta = if phase < 0.05 { 1.0 } else { 0.0 };
            let rhythms = engine.update(dt, u_theta, 0.4, 1.0);
            if t > 2.0 && phase < 0.01 {
                sum_cos += rhythms.theta.phase.cos();
                sum_sin += rhythms.theta.phase.sin();
                count += 1.0;
            }
            t += dt;
        }
        let plv = (sum_cos * sum_cos + sum_sin * sum_sin).sqrt() / count.max(1.0);
        let mean_phase = sum_sin.atan2(sum_cos);
        assert!(plv > 0.9, "expected PLV > 0.9, got {plv}");
        assert!(
            mean_phase.abs() < 0.3,
            "expected mean phase near 0, got {mean_phase}"
        );
    }

    #[test]
    fn theta_tracks_constant_8hz_pulse_train() {
        let mut engine = RhythmEngine::default();
        let dt = 0.01;
        let mut t = 0.0;
        for _ in 0..3000 {
            let phase = (t * 8.0) % 1.0;
            let u_theta = if phase < 0.05 { 1.0 } else { 0.0 };
            engine.update(dt, u_theta, 0.4, 1.0);
            t += dt;
        }
        let freq = engine.last().theta.freq_hz;
        assert!(
            (freq - 8.0).abs() < 0.5,
            "expected theta near 8Hz, got {freq}"
        );
    }

    #[test]
    fn theta_tracks_step_change_6_to_8() {
        let mut engine = RhythmEngine::default();
        let dt = 0.01;
        let mut t = 0.0;
        for _ in 0..500 {
            let phase = (t * 6.0) % 1.0;
            let u_theta = if phase < 0.05 { 1.0 } else { 0.0 };
            engine.update(dt, u_theta, 0.4, 1.0);
            t += dt;
        }
        for _ in 0..500 {
            let phase = (t * 8.0) % 1.0;
            let u_theta = if phase < 0.05 { 1.0 } else { 0.0 };
            engine.update(dt, u_theta, 0.4, 1.0);
            t += dt;
        }
        let freq = engine.last().theta.freq_hz;
        assert!(
            (freq - 8.0).abs() < 0.5,
            "expected theta near 8Hz after step, got {freq}"
        );
    }

    #[test]
    fn neuralrhythms_advance_wraps_phase() {
        let mut rhythms = NeuralRhythms {
            theta: RhythmBand {
                phase: 0.0,
                freq_hz: 1.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            delta: RhythmBand {
                phase: 0.0,
                freq_hz: 1.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            env_open: 1.0,
            env_level: 0.5,
        };
        for _ in 0..4 {
            rhythms.advance_in_place(0.25);
        }
        assert!(
            rhythms.theta.phase.abs() < 1e-4,
            "theta phase should wrap to 0"
        );
        assert!(
            rhythms.delta.phase.abs() < 1e-4,
            "delta phase should wrap to 0"
        );
    }

    #[test]
    fn neuralrhythms_env_open_updates_with_delta_phase() {
        let mut rhythms = NeuralRhythms {
            theta: RhythmBand {
                phase: 0.0,
                freq_hz: 1.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            delta: RhythmBand {
                phase: 0.0,
                freq_hz: 1.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            env_open: 1.0,
            env_level: 0.5,
        };
        let env_before = rhythms.env_open;
        rhythms.advance_in_place(0.1);
        let env_after = rhythms.env_open;
        assert!(env_after.is_finite());
        assert!(env_after >= 0.0 && env_after <= 1.0);
        assert!(
            (env_before - env_after).abs() > 1e-4,
            "env_open should respond to delta phase advance"
        );
    }
}
</file>

<file path="src/core/nsgt_kernel.rs">
//! core/nsgt_kernel.rs — Log2-axis NSGT (kernel-based, one-FFT-per-frame)
//!
//! Overview
//! -----
//! - For each band k, we precompute a time-domain kernel h_k[n] = w_k[n] * exp(+j 2*pi f_k n / fs),
//!   zero-pad it to length Nfft, center it, and take FFT -> K_k[nu] (frequency-domain kernel).
//! - For each frame, compute X[nu] = FFT{x_frame} only once, and obtain
//!   C_k = (1/Nfft) * sum_nu X[nu] * conj(K_k[nu]) = sum_n x[n] * conj(h_k[n]),
//!   so conj(h_k[n]) contains the standard analysis factor exp(-j omega n).
//! - K_k is **sparsified** by thresholding: we store only (index, weight) of nonzero bins for fast accumulation.
//!
//! Design Notes
//! -----
//! - Frame length is fixed to Nfft. hop is a single global value based on overlap (shared across all bands).
//! - Use a symmetric Blackman-Harris window for each band with length L_k. Normalization by /U_k is already applied.
//! - Complex linear interpolation is unnecessary (the kernel itself represents the continuous frequency).

use crate::core::fft::blackman_harris_window_symmetric;
use crate::core::log2space::Log2Space;
use rustfft::{FftPlanner, num_complex::Complex32};
use serde::{Deserialize, Serialize};
use std::sync::Arc;

// =====================================================
// Config structures
// =====================================================
const MIN_WIN_LEN: usize = 16;

/// NSGT configuration (log2-axis, analysis-only).
#[derive(Clone, Copy, Debug)]
pub struct NsgtLog2Config {
    /// Sampling rate [Hz]
    pub fs: f32,
    /// Overlap ratio in [0, 0.95). 0.5 = 50% overlap (default-good)
    pub overlap: f32,
    pub nfft_override: Option<usize>,
    /// Kernel time alignment within the FFT frame.
    pub kernel_align: KernelAlign,
}

impl Default for NsgtLog2Config {
    fn default() -> Self {
        Self {
            fs: 48_000.0,
            overlap: 0.5,
            nfft_override: None,
            kernel_align: KernelAlign::Center,
        }
    }
}

/// Time placement of kernels within the FFT frame.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum KernelAlign {
    #[default]
    Center,
    Right,
}

/// Frequency-dependent cap on analysis window length.
#[derive(Clone, Copy, Debug)]
pub struct WinLenCap {
    /// Apply cap at and above this frequency [Hz].
    pub pivot_hz: f32,
    /// Maximum window length above pivot [s].
    pub max_len_above_s: f32,
}

impl WinLenCap {
    /// Cap length in samples (rounded), clamped to < nfft and normalized.
    pub fn cap_samples(&self, fs: f32, nfft: usize) -> usize {
        let raw = (self.max_len_above_s * fs).round().max(1.0) as usize;
        finalize_win_len(raw, nfft)
    }
}

fn finalize_win_len(mut len: usize, nfft: usize) -> usize {
    let nfft_cap = nfft.saturating_sub(1).max(1);
    if len < MIN_WIN_LEN {
        len = MIN_WIN_LEN;
    }
    if len > nfft_cap {
        len = nfft_cap;
    }
    if len.is_multiple_of(2) {
        len = len.saturating_sub(1);
    }
    if len < 3 {
        len = 3.min(nfft_cap);
    }
    len
}

/// Band descriptor on log2 axis.
#[derive(Clone, Debug)]
pub struct NsgtBand {
    pub f_hz: f32,
    pub win_len: usize,
    pub hop: usize,
    pub window: Vec<f32>,
    pub log2_hz: f32,
    pub q: f32,
}

/// Analysis result for one band.
#[derive(Clone, Debug)]
pub struct BandCoeffs {
    pub coeffs: Vec<Complex32>,
    pub t_sec: Vec<f32>,
    pub f_hz: f32,
    pub log2_hz: f32,
    pub win_len: usize,
    pub hop: usize,
}

/// Power accumulation mode for RT NSGT.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum PowerMode {
    /// Coherent power (includes cross terms): |Σ X[k] * conj(K[k])|^2.
    Coherent,
    /// Incoherent power (no cross terms): Σ |X[k]|^2 * |K[k]|^2.
    Incoherent,
}

#[derive(Clone, Debug)]
pub struct KernelBand {
    pub f_hz: f32,
    pub log2_hz: f32,
    pub win_len: usize, // L_k
    pub enbw_hz: f32,
    // frequency-domain kernel (sparse): store (bin index, conj(K_k[bin])) for computation
    pub spec_conj_sparse: Option<Vec<(usize, Complex32)>>,
    // frequency-domain kernel power (sparse): store (bin index, |K_k[bin]|^2)
    pub spec_pow_sparse: Option<Vec<(usize, f32)>>,
}

#[derive(Clone)]
pub struct NsgtKernelLog2 {
    pub cfg: NsgtLog2Config,
    pub space: Log2Space,
    pub power_mode: PowerMode,
    nfft: usize,
    hop: usize,
    fft: Arc<dyn rustfft::Fft<f32>>,
    bands: Vec<KernelBand>,
}

impl NsgtKernelLog2 {
    /// Kernel-based NSGT
    ///
    /// - Nfft is set to the next power of two of max(L_k) (multiplied by `zpad_pow2`, default=2).
    /// - hop is based on Nfft (shared across all bands): hop = round((1-overlap)*Nfft)
    /// - win_len_cap limits high-frequency window length without clamping Q, preserving
    ///   time resolution when bins_per_oct is increased.
    pub fn new(
        cfg: NsgtLog2Config,
        space: Log2Space,
        win_len_cap: Option<WinLenCap>,
        power_mode: PowerMode,
    ) -> Self {
        assert!(
            cfg.overlap >= 0.0 && cfg.overlap < 0.99,
            "Overlap must be in [0,0.99)"
        );

        let fs = cfg.fs;
        let bpo = space.bins_per_oct as f32;
        let raw_q = 1.0 / (2f32.powf(1.0 / bpo) - 1.0);
        let q_min = 5.0;
        let q_max = 80.0;
        // With a frequency-dependent window cap, do not clamp q_max. This allows
        // higher Q (better peak separation) without increasing high-frequency window length.
        let q = if win_len_cap.is_some() {
            raw_q.max(q_min)
        } else {
            raw_q.clamp(q_min, q_max)
        };

        // Calculate L_k for each band. With win_len_cap, high-frequency windows are capped
        // to preserve time resolution while allowing higher Q via bins_per_oct.
        // With fixed nfft_override, low bands may still hit nfft-1.
        let win_lengths: Vec<usize> = space
            .centers_hz
            .iter()
            .map(|&f| {
                let mut len = (q * fs / f).round().max(1.0) as usize;
                if let Some(cap) = win_len_cap
                    && f >= cap.pivot_hz
                {
                    let cap_raw = (cap.max_len_above_s * fs).round().max(1.0) as usize;
                    len = len.min(cap_raw);
                }
                len
            })
            .collect();

        // Nfft determination: next power of two based on max L_k (zero-padding to sharpen the kernel)
        let zpad_pow2: usize = 2;
        let max_win_len = *win_lengths.iter().max().unwrap_or(&1024);

        let mut nfft = if let Some(n) = cfg.nfft_override {
            n
        } else {
            (max_win_len * zpad_pow2).next_power_of_two().max(1024)
        };

        // upper limit for practical use (to avoid excessively large FFT)
        if nfft > 1 << 18 {
            nfft = 1 << 18;
        }

        let hop = ((1.0 - cfg.overlap) * nfft as f32).round().max(1.0) as usize;

        let mut planner = FftPlanner::<f32>::new();
        let fft = planner.plan_fft_forward(nfft);

        // Precompute kernels for each band (frequency domain, conjugated and sparsified)
        let mut bands: Vec<KernelBand> = Vec::with_capacity(space.centers_hz.len());
        for ((&f, &log2_f), &win_len) in space
            .centers_hz
            .iter()
            .zip(space.centers_log2.iter())
            .zip(win_lengths.iter())
        {
            // Apply constraints: cap (if any), nfft limit, odd length, and minimum length.
            // With win_len_cap, the cap dominates high frequencies to preserve time resolution
            // even when bins_per_oct (Q) is increased.
            let win_len_req = finalize_win_len(win_len, nfft);

            let window = blackman_harris_window_symmetric(win_len_req);
            let sum_w = window.iter().copied().sum::<f32>().max(1e-12);
            let sum_w2 = window.iter().map(|w| w * w).sum::<f32>();
            let enbw_hz = (fs * sum_w2 / (sum_w * sum_w)).max(1e-12);

            // Circularly shifted kernel h_k[n] = w[n]*exp(+j 2*pi f n/fs) (zero-padded to nfft).
            let mut h = vec![Complex32::new(0.0, 0.0); nfft];
            let center = win_len_req / 2;
            let shift = match cfg.kernel_align {
                KernelAlign::Center => (nfft / 2 + nfft - center) % nfft,
                KernelAlign::Right => nfft - win_len_req,
            };
            for (i, &win) in window.iter().enumerate().take(win_len_req) {
                let w = win / sum_w;
                let ph = 2.0 * std::f32::consts::PI * f * (i as f32) / fs;
                let cplx = Complex32::new(ph.cos(), ph.sin()) * w;
                let idx = (i + shift) % nfft;
                h[idx] = cplx;
            }

            // K_k = FFT{h_k}
            let mut kernel_freq = h.clone();
            fft.process(&mut kernel_freq);

            // Sparsify with a relative magnitude threshold.
            let mut max_mag = 0.0f32;
            for z in &kernel_freq {
                let m = z.norm_sqr();
                if m > max_mag {
                    max_mag = m;
                }
            }
            let tol = (1e-6 * max_mag.sqrt()).max(1e-20);
            let (mut sparse_conj, mut sparse_pow) = (None, None);
            match power_mode {
                PowerMode::Coherent => {
                    let mut v = Vec::new();
                    for (k, &z) in kernel_freq.iter().enumerate() {
                        if z.norm() >= tol {
                            // Keep time-domain alignment (center/right); do not undo the shift here.
                            v.push((k, z.conj()));
                        }
                    }
                    sparse_conj = Some(v);
                }
                PowerMode::Incoherent => {
                    let mut v = Vec::new();
                    for (k, &z) in kernel_freq.iter().enumerate() {
                        if z.norm() >= tol {
                            // |K|^2 does not depend on phase (safe for any alignment).
                            let w_conj = z.conj();
                            v.push((k, w_conj.norm_sqr()));
                        }
                    }
                    sparse_pow = Some(v);
                }
            }

            bands.push(KernelBand {
                f_hz: f,
                log2_hz: log2_f,
                win_len: win_len_req,
                enbw_hz,
                spec_conj_sparse: sparse_conj,
                spec_pow_sparse: sparse_pow,
            });
        }

        Self {
            cfg,
            space,
            power_mode,
            nfft,
            hop,
            fft,
            bands,
        }
    }

    /// Construct with coherent power mode (backwards-compatible default).
    pub fn new_coherent(
        cfg: NsgtLog2Config,
        space: Log2Space,
        win_len_cap: Option<WinLenCap>,
    ) -> Self {
        Self::new(cfg, space, win_len_cap, PowerMode::Coherent)
    }

    pub fn space(&self) -> &Log2Space {
        &self.space
    }
    pub fn nfft(&self) -> usize {
        self.nfft
    }
    pub fn hop(&self) -> usize {
        self.hop
    }
    pub fn bands(&self) -> &[KernelBand] {
        &self.bands
    }
    #[inline]
    pub fn time_ref_sample_in_frame(&self) -> usize {
        match self.cfg.kernel_align {
            KernelAlign::Center => self.nfft / 2,
            KernelAlign::Right => self.nfft.saturating_sub(1),
        }
    }

    /// Analysis: compute X once per frame and accumulate sparse inner products for all bands.
    pub fn analyze(&self, x: &[f32]) -> Vec<BandCoeffs> {
        let fs = self.cfg.fs;
        if x.is_empty() {
            return Vec::new();
        }
        debug_assert!(
            self.power_mode == PowerMode::Coherent,
            "analyze() requires PowerMode::Coherent"
        );

        let nfft = self.nfft;
        let hop = self.hop;

        let n_frames = if x.len() < nfft {
            1
        } else {
            (x.len() - nfft) / hop + 1
        };

        // Output slots.
        let mut out: Vec<BandCoeffs> = self
            .bands
            .iter()
            .map(|b| BandCoeffs {
                coeffs: Vec::with_capacity(n_frames),
                t_sec: Vec::with_capacity(n_frames),
                f_hz: b.f_hz,
                log2_hz: b.log2_hz,
                win_len: b.win_len,
                hop,
            })
            .collect();

        let mut buf = vec![Complex32::new(0.0, 0.0); nfft];

        for frame_idx in 0..n_frames {
            // Rectangular framing; the kernel already contains the analysis window.
            let start = frame_idx * hop;
            for i in 0..nfft {
                let xi = if start + i < x.len() {
                    x[start + i]
                } else {
                    0.0
                };
                buf[i] = Complex32::new(xi, 0.0);
            }

            // X = FFT{x}
            self.fft.process(&mut buf);

            // Sparse inner product per band: C_k = (1/Nfft) * sum X[nu] * conj(K_k[nu]) = sum x[n] * conj(h_k[n]).
            for (b_idx, b) in self.bands.iter().enumerate() {
                let sparse = b
                    .spec_conj_sparse
                    .as_ref()
                    .expect("coherent kernel required for analyze()");
                let mut acc = Complex32::new(0.0, 0.0);
                for &(k, w) in sparse {
                    acc += buf[k] * w;
                }
                acc /= nfft as f32; // 1/Nfft scaling to match rustfft normalization.
                out[b_idx].coeffs.push(acc);
                let t_ref = self.time_ref_sample_in_frame();
                out[b_idx].t_sec.push((start + t_ref) as f32 / fs);
            }
        }

        out
    }

    /// Mean magnitude (envelope). No per-L or per-Hz normalization; caller defines it.
    pub fn analyze_envelope(&self, x: &[f32]) -> Vec<f32> {
        let bands = self.analyze(x);
        bands
            .into_iter()
            .map(|b| {
                let m = b.coeffs.len();
                if m == 0 {
                    0.0
                } else {
                    // Drop one frame at each edge to reduce boundary effects.
                    let (start, end) = if m > 2 { (1, m - 1) } else { (0, m) };
                    let slice = &b.coeffs[start..end];
                    if slice.is_empty() {
                        0.0
                    } else {
                        slice.iter().map(|z| z.norm()).sum::<f32>() / (slice.len() as f32)
                    }
                }
            })
            .collect()
    }

    /// Power spectral density [power/Hz] with ENBW correction (**one-sided**).
    pub fn analyze_psd(&self, x: &[f32]) -> Vec<f32> {
        debug_assert!(
            self.power_mode == PowerMode::Coherent,
            "analyze_psd() requires PowerMode::Coherent"
        );
        self.analyze(x)
            .iter()
            .enumerate()
            .map(|(i, b)| {
                let mean_pow = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                    / (b.coeffs.len().max(1) as f32);
                let enbw_hz = self.bands[i].enbw_hz.max(1e-12);
                // two-sided -> one-sided
                2.0 * (mean_pow / enbw_hz.max(1e-12))
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::phase::wrap_pm_pi;
    use crate::core::utils::{brown_noise, pink_noise, white_noise};
    use approx::assert_relative_eq;

    fn mk_sine(fs: f32, f: f32, secs: f32) -> Vec<f32> {
        let n = (fs * secs).round() as usize;
        (0..n)
            .map(|i| (2.0 * std::f32::consts::PI * f * (i as f32) / fs).sin())
            .collect()
    }

    fn mk_sine_len(fs: f32, f: f32, n: usize) -> Vec<f32> {
        (0..n)
            .map(|i| (2.0 * std::f32::consts::PI * f * (i as f32) / fs).sin())
            .collect()
    }

    fn kernel_sidelobe_db(nfft: usize, sparse: &[(usize, Complex32)]) -> f32 {
        let mut mags = vec![0.0f32; nfft];
        for &(k, z) in sparse {
            if k < nfft {
                mags[k] = z.norm();
            }
        }
        let (k_peak, peak) = mags
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .map(|(k, &v)| (k, v))
            .unwrap();
        let peak = peak.max(1e-20);
        let thr = peak * 1e-4;

        let mut left = k_peak;
        while left > 0 && mags[left - 1] >= thr {
            left -= 1;
        }
        let mut right = k_peak;
        while right + 1 < nfft && mags[right + 1] >= thr {
            right += 1;
        }

        let mut side = 0.0f32;
        for (k, &m) in mags.iter().enumerate() {
            if k < left || k > right {
                if m > side {
                    side = m;
                }
            }
        }
        if side <= 0.0 {
            return f32::NEG_INFINITY;
        }
        20.0 * (side / peak).log10()
    }

    #[test]
    fn power_mode_sparse_storage_is_exclusive() {
        let fs = 48_000.0;
        let space = Log2Space::new(200.0, 4000.0, 12);
        let coherent = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                nfft_override: Some(256),
                ..Default::default()
            },
            space.clone(),
            None,
            PowerMode::Coherent,
        );
        for band in coherent.bands() {
            assert!(band.spec_conj_sparse.is_some());
            assert!(band.spec_pow_sparse.is_none());
        }

        let incoherent = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                nfft_override: Some(256),
                ..Default::default()
            },
            space,
            None,
            PowerMode::Incoherent,
        );
        for band in incoherent.bands() {
            assert!(band.spec_conj_sparse.is_none());
            assert!(band.spec_pow_sparse.is_some());
        }
    }

    #[test]
    fn kernel_sidelobe_level_midband() {
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new_coherent(NsgtLog2Config::default(), space, None);
        let target_hz = 1000.0;
        let (bi, _) = nsgt
            .space()
            .centers_hz
            .iter()
            .enumerate()
            .min_by(|a, b| {
                (a.1 - target_hz)
                    .abs()
                    .partial_cmp(&(b.1 - target_hz).abs())
                    .unwrap()
            })
            .unwrap();

        let band = &nsgt.bands()[bi];
        let sparse = band
            .spec_conj_sparse
            .as_ref()
            .expect("coherent sparse missing");
        let side_db = kernel_sidelobe_db(nsgt.nfft(), sparse);
        assert!(
            side_db < -70.0,
            "kernel side lobe too high: {side_db:.2} dB"
        );
    }

    #[test]
    fn pure_tone_near_target() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                ..Default::default()
            },
            Log2Space::new(20.0, 8000.0, 200),
            None,
        );
        let sig = mk_sine_len(fs, 440.0, nsgt.nfft());
        let bands = nsgt.analyze(&sig);
        let (mut best_f, mut best_val) = (0.0, 0.0);
        for b in &bands {
            let p =
                b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / (b.coeffs.len().max(1) as f32);
            if p > best_val {
                best_val = p;
                best_f = b.f_hz;
            }
        }
        let cents = 1200.0 * (((best_f / 440.0_f32).log2()).abs());
        assert!(
            cents < 60.0,
            "peak off by {:.1} cents @ {:.2} Hz",
            cents,
            best_f
        );
    }

    #[test]
    fn multi_tone_localization() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config::default(),
            Log2Space::new(20.0, 8000.0, 96),
            None,
        );
        for f in [55.0, 110.0, 220.0, 440.0, 880.0, 1760.0] {
            let sig = mk_sine_len(fs, f, nsgt.nfft());
            let bands = nsgt.analyze(&sig);
            let (mut best_f, mut best_val) = (0.0, 0.0);
            for b in &bands {
                let p = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                    / (b.coeffs.len().max(1) as f32);
                if p > best_val {
                    best_val = p;
                    best_f = b.f_hz;
                }
            }
            let cents = 1200.0 * ((best_f / f).log2()).abs();
            assert!(
                cents < 60.0,
                "freq localization failed: input {f} → peak {best_f} ({cents:.1} cents)"
            );
        }
    }

    #[test]
    fn amplitude_linearity() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config::default(),
            Log2Space::new(20.0, 8000.0, 96),
            None,
        );
        let a = mk_sine(fs, 440.0, 1.0);
        let b: Vec<f32> = a.iter().map(|v| v * 2.0).collect();
        let e1: f32 = nsgt.analyze_psd(&a).iter().sum();
        let e2: f32 = nsgt.analyze_psd(&b).iter().sum();
        assert_relative_eq!(e2 / e1, 4.0, epsilon = 0.15, max_relative = 0.15);
    }

    #[test]
    fn win_len_decreases_with_freq() {
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config::default(),
            Log2Space::new(20.0, 8000.0, 96),
            None,
        );
        let lens: Vec<usize> = nsgt.bands().iter().map(|b| b.win_len).collect();
        for w in lens.windows(2) {
            assert!(w[0] >= w[1], "win_len not monotonic: {} < {}", w[0], w[1]);
        }
    }

    #[test]
    fn log2_space_linear_check() {
        let space = Log2Space::new(20.0, 8000.0, 48);
        let diffs: Vec<f32> = space.centers_log2.windows(2).map(|x| x[1] - x[0]).collect();
        let mean = diffs.iter().sum::<f32>() / diffs.len() as f32;
        let var = diffs
            .iter()
            .map(|d| (d - mean).abs() / mean)
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap();
        assert!(var < 1e-3, "log2 spacing nonuniform >0.1%");
    }

    #[test]
    fn empty_signal_returns_empty() {
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config::default(),
            Log2Space::new(20.0, 8000.0, 48),
            None,
        );
        let out = nsgt.analyze(&[]);
        assert!(out.is_empty());
    }

    #[test]
    fn impulse_peak_aligns_with_time_tag() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config {
                fs,
                overlap: 0.98,
                nfft_override: Some(256),
                ..Default::default()
            },
            Log2Space::new(4000.0, 8000.0, 12),
            None,
        );
        let mut sig = vec![0.0f32; 512];
        let imp = 200usize;
        sig[imp] = 1.0;

        let bands = nsgt.analyze(&sig);
        let band = bands.last().expect("no bands returned");
        let (i_peak, _) = band
            .coeffs
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.norm_sqr().partial_cmp(&b.1.norm_sqr()).unwrap())
            .expect("no coefficients returned");

        let t_peak = band.t_sec[i_peak];
        let hop = nsgt.hop() as f32;
        let err = (t_peak * fs - imp as f32).abs();

        assert!(
            err <= hop,
            "impulse peak misaligned: err={err:.2} samples (hop={hop:.2})"
        );
    }

    #[test]
    fn impulse_time_alignment_center_vs_right() {
        let fs = 48_000.0;
        let nfft = 1024;
        let space = Log2Space::new(100.0, 5000.0, 96);
        let target_f = 1000.0;

        let cfg_center = NsgtLog2Config {
            fs,
            overlap: 0.5,
            nfft_override: Some(nfft),
            kernel_align: KernelAlign::Center,
        };
        let nsgt_center = NsgtKernelLog2::new_coherent(cfg_center, space.clone(), None);
        let bi = nsgt_center
            .bands()
            .iter()
            .enumerate()
            .min_by(|a, b| {
                let da = (a.1.f_hz - target_f).abs();
                let db = (b.1.f_hz - target_f).abs();
                da.partial_cmp(&db).unwrap()
            })
            .map(|(i, _)| i)
            .unwrap();

        let hop = nsgt_center.hop();
        let frame_idx = 3usize;
        let start = frame_idx * hop;
        let len = start + nfft + 1;

        let mut sig_center = vec![0.0f32; len];
        let t_imp_center = start + nfft / 2;
        sig_center[t_imp_center] = 1.0;
        let bands_center = nsgt_center.analyze(&sig_center);
        let band_center = &bands_center[bi];
        let (i_peak_center, _) = band_center
            .coeffs
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.norm_sqr().partial_cmp(&b.1.norm_sqr()).unwrap())
            .unwrap();
        assert_eq!(i_peak_center, frame_idx, "center peak frame mismatch");
        let expected_center = (start + nfft / 2) as f32 / fs;
        let got_center = band_center.t_sec[frame_idx];
        assert!(
            (got_center - expected_center).abs() < 1e-9,
            "center t_sec mismatch: got={}, expected={}",
            got_center,
            expected_center
        );

        let cfg_right = NsgtLog2Config {
            fs,
            overlap: 0.5,
            nfft_override: Some(nfft),
            kernel_align: KernelAlign::Right,
        };
        let nsgt_right = NsgtKernelLog2::new_coherent(cfg_right, space, None);
        let win_len = nsgt_right.bands()[bi].win_len;
        let center = win_len / 2;

        let mut sig_right = vec![0.0f32; len];
        let t_imp_right = start + (nfft - win_len + center);
        sig_right[t_imp_right] = 1.0;
        let bands_right = nsgt_right.analyze(&sig_right);
        let band_right = &bands_right[bi];
        let (i_peak_right, _) = band_right
            .coeffs
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.norm_sqr().partial_cmp(&b.1.norm_sqr()).unwrap())
            .unwrap();
        assert_eq!(i_peak_right, frame_idx, "right peak frame mismatch");
        let expected_right = (start + nfft - 1) as f32 / fs;
        let got_right = band_right.t_sec[frame_idx];
        assert!(
            (got_right - expected_right).abs() < 1e-9,
            "right t_sec mismatch: got={}, expected={}",
            got_right,
            expected_right
        );
    }

    #[test]
    fn phase_shift_sign_matches_standard_analysis() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config {
                fs,
                overlap: 0.98,
                nfft_override: Some(512),
                ..Default::default()
            },
            Log2Space::new(4000.0, 8000.0, 12),
            None,
        );

        let bi = nsgt.bands().len() - 1;
        let f = nsgt.bands()[bi].f_hz;
        let omega = 2.0 * std::f32::consts::PI * f / fs;
        let len = nsgt.nfft() * 8;
        let delta = 1usize;
        let delta_f = delta as f32;

        let x0_cos: Vec<f32> = (0..len).map(|n| (omega * n as f32).cos()).collect();
        let x0_sin: Vec<f32> = (0..len).map(|n| (omega * n as f32).sin()).collect();
        let x1_cos: Vec<f32> = (0..len)
            .map(|n| (omega * (n as f32 - delta_f)).cos())
            .collect();
        let x1_sin: Vec<f32> = (0..len)
            .map(|n| (omega * (n as f32 - delta_f)).sin())
            .collect();

        let bands0_cos = nsgt.analyze(&x0_cos);
        let bands0_sin = nsgt.analyze(&x0_sin);
        let bands1_cos = nsgt.analyze(&x1_cos);
        let bands1_sin = nsgt.analyze(&x1_sin);

        let fi = bands0_cos[bi].coeffs.len() / 2;
        let c0_cos = bands0_cos[bi].coeffs[fi];
        let c0_sin = bands0_sin[bi].coeffs[fi];
        let c1_cos = bands1_cos[bi].coeffs[fi];
        let c1_sin = bands1_sin[bi].coeffs[fi];

        let j = Complex32::new(0.0, 1.0);
        let c0 = c0_cos + j * c0_sin;
        let c1 = c1_cos + j * c1_sin;

        assert!(c0.norm() > 1e-3, "base coefficient too small");

        let d = c1 * c0.conj();
        let phase = d.im.atan2(d.re);
        let expected = -omega * delta_f;
        let err = wrap_pm_pi(phase - expected).abs();

        assert!(err < 1e-2, "phase error too large: {err}");
    }

    #[test]
    fn low_vs_high_freq_energy_scaling() {
        // Check that total energy is roughly frequency-independent.
        let fs = 48_000.0;
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new_coherent(NsgtLog2Config::default(), space.clone(), None);

        let sig_low = mk_sine_len(fs, 220.0, nsgt.nfft());
        let sig_high = mk_sine_len(fs, 1760.0, nsgt.nfft());

        let integrate_psd = |x: &[f32]| -> f32 {
            let psd = nsgt.analyze_psd(x);
            let freqs = &space.centers_hz;
            let mut total = 0.0;
            for i in 0..freqs.len() - 1 {
                let df = (freqs[i + 1] - freqs[i]).max(1e-9);
                total += psd[i] * df;
            }
            total
        };

        let p_low = integrate_psd(&sig_low);
        let p_high = integrate_psd(&sig_high);
        let ratio = p_high / p_low;

        assert_relative_eq!(ratio, 1.0, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn parseval_consistency() {
        let fs = 48_000.0;
        let f0 = 880.0;
        let space = Log2Space::new(20.0, 8000.0, 200);
        let nsgt = NsgtKernelLog2::new_coherent(NsgtLog2Config::default(), space.clone(), None);
        let sig = mk_sine_len(fs, f0, nsgt.nfft());

        let e_time = sig.iter().map(|x| x * x).sum::<f32>() / sig.len() as f32;
        let psd = nsgt.analyze_psd(&sig);

        let e_freq = psd
            .iter()
            .zip(space.centers_hz.windows(2))
            .map(|(p, f)| p * (f[1] - f[0]))
            .sum::<f32>();

        assert_relative_eq!(e_freq / e_time, 1.0, epsilon = 0.1);
    }

    #[test]
    fn hop_size_stability() {
        let fs = 48_000.0;
        let space = Log2Space::new(20.0, 8000.0, 96);
        let sig = mk_sine(fs, 440.0, 1.0);

        let e_mean = |overlap: f32| {
            let nsgt = NsgtKernelLog2::new_coherent(
                NsgtLog2Config {
                    fs,
                    overlap,
                    ..Default::default()
                },
                space.clone(),
                None,
            );
            let out = nsgt.analyze(&sig);
            let sum_e: f32 = out
                .iter()
                .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
                .sum();
            let n_frames: usize = out.iter().map(|b| b.coeffs.len()).max().unwrap_or(1);
            if n_frames > 0 {
                sum_e / n_frames as f32
            } else {
                0.0
            }
        };

        let e_half = e_mean(0.5);
        let e_75 = e_mean(0.75);
        assert_relative_eq!(e_half, e_75, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn band_count_matches_space() {
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new_coherent(NsgtLog2Config::default(), space.clone(), None);
        assert_eq!(
            nsgt.bands().len(),
            space.centers_hz.len(),
            "Band count must match Log2Space bin count"
        );
    }

    #[test]
    fn single_tone_peak_shape() {
        let fs = 48_000.0;
        let f0 = 1000.0;
        let space = Log2Space::new(100.0, 5000.0, 200);
        let nsgt = NsgtKernelLog2::new_coherent(NsgtLog2Config::default(), space.clone(), None);
        let sig = mk_sine_len(fs, f0, nsgt.nfft());

        let psd = nsgt.analyze_psd(&sig);
        let freqs = &space.centers_hz;
        let (i_peak, &p_peak) = psd
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .unwrap();
        let f_peak = freqs[i_peak];

        // Peak location should be within +/- 1/12 octave.
        let cents = 1200.0 * ((f_peak / f0).log2()).abs();
        assert!(
            cents < 100.0,
            "peak off by {:.1} cents @ {:.2} Hz",
            cents,
            f_peak
        );

        // Evaluate flanks only outside the main lobe.
        // Use |df| = 2/T (T = win_len / fs) as a conservative main-lobe width scale.
        let win_len = nsgt.bands()[i_peak].win_len as f32; // Lk_req
        let period = win_len / fs;
        let df_zero = 2.0 / period; // [Hz]

        let mut flank_max = 0.0f32;
        let mut flank_count = 0usize;
        for (i, &p) in psd.iter().enumerate() {
            let df = (freqs[i] - f_peak).abs();
            if df >= df_zero {
                flank_max = flank_max.max(p);
                flank_count += 1;
            }
        }
        assert!(
            flank_count > 0,
            "no bins outside main lobe to evaluate flank"
        );

        // Outside the main lobe, expect at least ~10x drop (~10.8 dB).
        assert!(
            p_peak / flank_max > 10.0,
            "peak too broad or flat: peak={}, flank_max={}, df_zero={:.2} Hz, Lk={}",
            p_peak,
            flank_max,
            df_zero,
            win_len as usize
        );
    }

    #[test]
    fn amplitude_scaling_quadratic() {
        let fs = 48_000.0;
        let f0 = 440.0;
        let sig1: Vec<f32> = (0..(fs as usize))
            .map(|i| (2.0 * std::f32::consts::PI * f0 * i as f32 / fs).sin())
            .collect();
        let sig2: Vec<f32> = sig1.iter().map(|x| x * 2.0).collect();

        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new_coherent(NsgtLog2Config::default(), space, None);
        let e1: f32 = nsgt.analyze_psd(&sig1).iter().sum();
        let e2: f32 = nsgt.analyze_psd(&sig2).iter().sum();

        assert_relative_eq!(e2 / e1, 4.0, epsilon = 0.1);
    }

    #[test]
    fn overlap_independence() {
        let fs = 48_000.0;
        let f0 = 880.0;
        let sig = (0..(fs as usize))
            .map(|i| (2.0 * std::f32::consts::PI * f0 * i as f32 / fs).sin())
            .collect::<Vec<_>>();
        let space = Log2Space::new(20.0, 8000.0, 96);

        let energies: Vec<f32> = [0.25, 0.5, 0.75]
            .iter()
            .map(|&ov| {
                let nsgt = NsgtKernelLog2::new_coherent(
                    NsgtLog2Config {
                        fs,
                        overlap: ov,
                        ..Default::default()
                    },
                    space.clone(),
                    None,
                );
                nsgt.analyze_psd(&sig).iter().sum::<f32>()
            })
            .collect();

        let mean = energies.iter().sum::<f32>() / energies.len() as f32;
        for &e in &energies {
            assert_relative_eq!(e / mean, 1.0, epsilon = 0.2);
        }
    }

    #[test]
    fn noise_slope_accuracy() {
        let fs = 48_000.0;
        let n = (fs * 4.0) as usize;

        let white: Vec<f32> = white_noise(n, 1).iter().map(|&v| v as f32).collect();
        let pink: Vec<f32> = pink_noise(n, 1).iter().map(|&v| v as f32).collect();
        let brown: Vec<f32> = brown_noise(n, 1).iter().map(|&v| v as f32).collect();

        let space = Log2Space::new(50.0, 8000.0, 150);
        let nsgt = NsgtKernelLog2::new_coherent(NsgtLog2Config::default(), space.clone(), None);

        let psd_white = nsgt.analyze_psd(&white);
        let psd_pink = nsgt.analyze_psd(&pink);
        let psd_brown = nsgt.analyze_psd(&brown);

        let slope = |psd: &[f32]| {
            let y: Vec<f32> = psd
                .iter()
                .map(|v| crate::core::db::power_to_db(*v))
                .collect();
            let x = &space.centers_log2;
            let (sx, sy, sxx, sxy, n) = x.iter().zip(&y).fold(
                (0.0, 0.0, 0.0, 0.0, 0.0),
                |(sx, sy, sxx, sxy, n), (xv, yv)| {
                    (
                        sx + *xv,
                        sy + *yv,
                        sxx + *xv * *xv,
                        sxy + *xv * *yv,
                        n + 1.0,
                    )
                },
            );
            (n * sxy - sx * sy) / (n * sxx - sx * sx)
        };

        let s_white = slope(&psd_white);
        let s_pink = slope(&psd_pink);
        let s_brown = slope(&psd_brown);

        assert!(s_white.abs() < 0.8, "white slope {s_white}");
        assert!((s_pink + 3.0).abs() < 1.0, "pink slope {s_pink}");
        assert!((s_brown + 6.0).abs() < 1.5, "brown slope {s_brown}");
    }

    #[test]
    fn win_len_cap_applies_above_pivot() {
        let fs = 48_000.0;
        let nfft = 4096;
        let pivot_hz = 2000.0;
        let cap = WinLenCap {
            pivot_hz,
            max_len_above_s: 256.0 / fs,
        };
        let space = Log2Space::new(200.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config {
                fs,
                overlap: 0.9,
                nfft_override: Some(nfft),
                ..Default::default()
            },
            space,
            Some(cap),
        );
        let cap_eff = cap.cap_samples(fs, nfft);

        let mut max_above = 0usize;
        for b in nsgt.bands().iter().filter(|b| b.f_hz >= pivot_hz) {
            assert!(
                b.win_len <= cap_eff,
                "win_len exceeds cap: f_hz={}, win_len={}, cap={}",
                b.f_hz,
                b.win_len,
                cap_eff
            );
            max_above = max_above.max(b.win_len);
        }
        assert!(
            max_above == cap_eff,
            "cap not binding above pivot: max_above={}, cap={}",
            max_above,
            cap_eff
        );
    }

    #[test]
    fn win_len_cap_limits_growth_with_bins_per_oct() {
        let fs = 48_000.0;
        let nfft = 4096;
        let pivot_hz = 2000.0;
        let cap = WinLenCap {
            pivot_hz,
            max_len_above_s: 256.0 / fs,
        };
        let cap_eff = cap.cap_samples(fs, nfft);

        for bpo in [24u32, 96u32] {
            let space = Log2Space::new(200.0, 8000.0, bpo);
            let nsgt = NsgtKernelLog2::new_coherent(
                NsgtLog2Config {
                    fs,
                    overlap: 0.9,
                    nfft_override: Some(nfft),
                    ..Default::default()
                },
                space,
                Some(cap),
            );
            let max_above = nsgt
                .bands()
                .iter()
                .filter(|b| b.f_hz >= pivot_hz)
                .map(|b| b.win_len)
                .max()
                .unwrap_or(0);
            assert!(
                max_above == cap_eff,
                "cap not enforced for bpo={}: max_above={}, cap={}",
                bpo,
                max_above,
                cap_eff
            );
        }
    }

    #[test]
    fn win_len_cap_none_allows_longer_high_band() {
        let fs = 48_000.0;
        let nfft = 4096;
        let pivot_hz = 2000.0;
        let cap = WinLenCap {
            pivot_hz,
            max_len_above_s: 256.0 / fs,
        };
        let cap_eff = cap.cap_samples(fs, nfft);
        let space = Log2Space::new(200.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config {
                fs,
                overlap: 0.9,
                nfft_override: Some(nfft),
                ..Default::default()
            },
            space,
            None,
        );
        let max_above = nsgt
            .bands()
            .iter()
            .filter(|b| b.f_hz >= pivot_hz)
            .map(|b| b.win_len)
            .max()
            .unwrap_or(0);

        assert!(
            max_above > cap_eff,
            "expected uncapped win_len above pivot: max_above={}, cap={}",
            max_above,
            cap_eff
        );
    }

    // ==============================
    // Visualization (plotting): cargo test -- --ignored
    // ==============================

    #[test]
    #[ignore]
    fn plot_nsgt_spectrum_kernel() {
        use plotters::prelude::*;

        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                nfft_override: Some(16_384),
                ..Default::default()
            },
            Log2Space::new(20.0, 8000.0, 200),
            None,
        );
        let sig = mk_sine_len(fs, 440.0, nsgt.nfft());
        let bands = nsgt.analyze(&sig);

        let points: Vec<(f32, f32)> = bands
            .iter()
            .map(|b| {
                let p = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                    / (b.coeffs.len().max(1) as f32);
                (b.log2_hz, p)
            })
            .collect();

        let root =
            BitMapBackend::new("target/nsgt_kernel_spectrum.png", (1500, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let y_max = points.iter().map(|(_, p)| *p).fold(0.0f32, f32::max) * 1.1;

        let mut chart = ChartBuilder::on(&root)
            .caption("NSGT Kernel Spectrum (pure 440Hz)", ("sans-serif", 18))
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(50)
            .build_cartesian_2d((20f32.log2())..(8000f32.log2()), 0f32..y_max)
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("log2(frequency) [oct]")
            .y_desc("mean power")
            .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
            .draw()
            .unwrap();

        chart
            .draw_series(LineSeries::new(points.iter().cloned(), &BLUE))
            .unwrap();

        root.present().unwrap();
    }

    #[test]
    #[ignore]
    fn plot_nsgt_log2_noise_response_kernel() {
        use plotters::prelude::*;

        let fs = 48_000.0;
        let secs = 40.0;
        let n = (fs * secs) as usize;

        let nsgt = NsgtKernelLog2::new_coherent(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                ..Default::default()
            },
            Log2Space::new(35.0, 24_000.0, 100),
            None,
        );

        // Noise generation.
        let white: Vec<f32> = white_noise(n, 42).iter().map(|&v| v as f32).collect();
        let pink: Vec<f32> = pink_noise(n, 42).iter().map(|&v| v as f32).collect();
        let brown: Vec<f32> = brown_noise(n, 42).iter().map(|&v| v as f32).collect();

        // Get per-Hz normalized PSD.
        let w_psd = nsgt.analyze_psd(&white);
        let p_psd = nsgt.analyze_psd(&pink);
        let b_psd = nsgt.analyze_psd(&brown);

        // Convert to dB.
        let to_db = |v: &[f32]| -> Vec<f32> {
            v.iter().map(|x| crate::core::db::power_to_db(*x)).collect()
        };
        let w_db = to_db(&w_psd);
        let p_db = to_db(&p_psd);
        let b_db = to_db(&b_psd);

        let log2x = nsgt.space().centers_log2.clone();

        // Plot.
        let root = BitMapBackend::new("target/nsgt_kernel_noise_psd_db.png", (1500, 1000))
            .into_drawing_area();
        root.fill(&WHITE).unwrap();

        let y_min = w_db
            .iter()
            .chain(&p_db)
            .chain(&b_db)
            .cloned()
            .fold(f32::INFINITY, f32::min);
        let y_max = w_db
            .iter()
            .chain(&p_db)
            .chain(&b_db)
            .cloned()
            .fold(f32::NEG_INFINITY, f32::max);

        let mut chart = ChartBuilder::on(&root)
            .caption(
                "NSGT Kernel PSD (White / Pink / Brown Noise)",
                ("sans-serif", 18),
            )
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(60)
            .build_cartesian_2d(
                (35f32.log2())..(24_000f32.log2()),
                (y_min - 10.0)..(y_max + 10.0),
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("log2(frequency) [oct]")
            .y_desc("Power Spectral Density [dB re 1/Hz]")
            .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
            .draw()
            .unwrap();

        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(w_db.iter().cloned()),
                &BLUE,
            ))
            .unwrap()
            .label("White");

        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(p_db.iter().cloned()),
                &RED,
            ))
            .unwrap()
            .label("Pink");

        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(b_db.iter().cloned()),
                &GREEN,
            ))
            .unwrap()
            .label("Brown");

        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()
            .unwrap();

        root.present().unwrap();
    }
}
</file>

<file path="src/core/peak_extraction.rs">
//! core/peak_extraction.rs — Extract delta-like peaks from ERB-density spectra.
//! density: per-ERB (or per-u) power density; mass: sum(density * du).

use crate::core::db;
use crate::core::density;
use crate::core::log2space::Log2Space;
use crate::core::roughness_kernel::erb_grid;

#[derive(Clone, Debug)]
pub struct Peak {
    pub u_erb: f32,
    pub mass: f32,
    pub bin_idx: usize,
}

#[derive(Clone, Debug)]
pub struct PeakExtractConfig {
    pub max_peaks: Option<usize>,
    /// Power-domain threshold (10*log10), relative to max density.
    pub min_rel_db_power: f32,
    /// Absolute power-density threshold in input units.
    pub min_abs_power_density: Option<f32>,
    /// Power-domain prominence (10*log10) for local peak selection.
    pub min_prominence_db_power: f32,
    /// Mass-domain threshold (10*log10), relative to max peak mass.
    /// Mass is Σ density * du (area), using power-domain dB.
    pub min_rel_mass_db_power: f32,
    /// Optional mass-domain threshold relative to total mass.
    /// Mass is Σ density * du (area), using power-domain dB semantics.
    pub min_mass_fraction: Option<f32>,
    pub min_sep_erb: f32,
}

impl Default for PeakExtractConfig {
    fn default() -> Self {
        Self {
            max_peaks: Some(64),
            min_rel_db_power: -40.0,
            min_abs_power_density: None,
            min_prominence_db_power: 10.0,
            min_rel_mass_db_power: -45.0,
            min_mass_fraction: None,
            min_sep_erb: 0.2,
        }
    }
}

impl PeakExtractConfig {
    pub fn strict() -> Self {
        Self {
            min_mass_fraction: Some(0.05),
            ..Self::default()
        }
    }

    pub fn nsgt_default() -> Self {
        Self {
            max_peaks: Some(32),
            min_rel_db_power: -50.0,
            min_abs_power_density: Some(1e-6),
            min_prominence_db_power: 10.0,
            min_rel_mass_db_power: -50.0,
            min_mass_fraction: Some(0.05),
            min_sep_erb: 0.2,
        }
    }

    pub fn normal() -> Self {
        Self {
            max_peaks: None,
            min_rel_db_power: -60.0,
            min_abs_power_density: None,
            min_prominence_db_power: 3.0,
            min_rel_mass_db_power: -70.0,
            min_mass_fraction: None,
            min_sep_erb: 0.10,
        }
    }
}

fn local_prominence_db_power(power_density: &[f32], idx: usize) -> f32 {
    let peak = power_density[idx];
    if peak <= 0.0 {
        return f32::NEG_INFINITY;
    }

    let mut min_val = peak;
    for j in (0..idx).rev() {
        min_val = min_val.min(power_density[j]);
        if power_density[j] > peak {
            break;
        }
    }
    let left_min = min_val;

    min_val = peak;
    for &v in power_density.iter().skip(idx + 1) {
        min_val = min_val.min(v);
        if v > peak {
            break;
        }
    }
    let right_min = min_val;

    let base = left_min.max(right_min).max(db::EPS_POWER);
    db::power_to_db(peak / base)
}

/// Extract peaks from an ERB power density. Total mass is conserved for the
/// masked spectrum (power >= min_abs), not the original input.
pub fn extract_peaks_density(
    power_density: &[f32],
    space: &Log2Space,
    cfg: &PeakExtractConfig,
) -> Vec<Peak> {
    if power_density.is_empty() || space.centers_hz.is_empty() {
        return vec![];
    }
    assert_eq!(power_density.len(), space.centers_hz.len());

    let (erb, du) = erb_grid(space);
    extract_peaks_density_with_grid(power_density, &erb, &du, cfg)
}

pub fn extract_peaks_density_with_grid(
    power_density: &[f32],
    erb: &[f32],
    du: &[f32],
    cfg: &PeakExtractConfig,
) -> Vec<Peak> {
    if power_density.is_empty() || erb.is_empty() || du.is_empty() {
        return vec![];
    }
    assert_eq!(power_density.len(), erb.len());
    assert_eq!(power_density.len(), du.len());

    let max_power = power_density.iter().cloned().fold(0.0f32, f32::max);
    if max_power <= 0.0 {
        return vec![];
    }

    let min_abs_rel = max_power * db::db_to_power_ratio(cfg.min_rel_db_power);
    let min_abs_abs = cfg.min_abs_power_density.unwrap_or(0.0);
    let min_abs = min_abs_rel.max(min_abs_abs);

    #[derive(Clone, Copy, Debug)]
    struct Candidate {
        idx: usize,
        u_erb: f32,
        power: f32,
    }

    let mut candidates = Vec::new();
    if power_density.len() >= 3 {
        for i in 1..(power_density.len() - 1) {
            let a = power_density[i];
            if a < min_abs {
                continue;
            }
            if a > power_density[i - 1] && a >= power_density[i + 1] {
                let prom_db = local_prominence_db_power(power_density, i);
                if prom_db >= cfg.min_prominence_db_power {
                    candidates.push(Candidate {
                        idx: i,
                        u_erb: erb[i],
                        power: a,
                    });
                }
            }
        }
    }

    if candidates.is_empty() {
        return vec![];
    }

    candidates.sort_by(|a, b| {
        b.power
            .partial_cmp(&a.power)
            .unwrap_or(std::cmp::Ordering::Equal)
    });

    let mut selected: Vec<Candidate> = Vec::new();
    for cand in candidates {
        if selected
            .iter()
            .any(|p| (p.u_erb - cand.u_erb).abs() < cfg.min_sep_erb)
        {
            continue;
        }
        selected.push(cand);
        if let Some(max_peaks) = cfg.max_peaks
            && selected.len() >= max_peaks
        {
            break;
        }
    }

    if selected.is_empty() {
        return vec![];
    }

    let mut mass_sum = vec![0.0f32; selected.len()];
    let mut u_weighted = vec![0.0f32; selected.len()];

    for (j, &power) in power_density.iter().enumerate() {
        if power < min_abs {
            continue;
        }
        let u = erb[j];
        let mut best = 0usize;
        let mut best_d = (u - selected[0].u_erb).abs();
        for (k, sel) in selected.iter().enumerate().skip(1) {
            let d = (u - sel.u_erb).abs();
            if d < best_d {
                best_d = d;
                best = k;
            }
        }
        let mass = power * du[j];
        mass_sum[best] += mass;
        u_weighted[best] += u * mass;
    }

    let max_mass = mass_sum.iter().cloned().fold(0.0f32, f32::max);
    let total_mass: f32 = mass_sum.iter().sum();
    let min_mass_rel = max_mass * db::db_to_power_ratio(cfg.min_rel_mass_db_power);
    let min_mass_total = cfg.min_mass_fraction.map(|frac| total_mass * frac);
    let mut keep: Vec<bool> = mass_sum
        .iter()
        .map(|&mass| {
            let mut remove = mass < min_mass_rel;
            if let Some(min_total) = min_mass_total {
                remove |= mass < min_total;
            }
            !remove
        })
        .collect();

    if keep.iter().all(|&k| !k)
        && max_mass > 0.0
        && let Some((idx, _)) = mass_sum
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap_or(std::cmp::Ordering::Equal))
    {
        keep[idx] = true;
    }

    if keep.iter().any(|&k| k) {
        for i in 0..mass_sum.len() {
            if keep[i] || mass_sum[i] <= 0.0 {
                continue;
            }
            let u_i = selected[i].u_erb;
            let mut best = None;
            let mut best_d = f32::MAX;
            for (k, &is_keep) in keep.iter().enumerate() {
                if !is_keep {
                    continue;
                }
                let d = (selected[k].u_erb - u_i).abs();
                if d < best_d {
                    best_d = d;
                    best = Some(k);
                }
            }
            if let Some(k) = best {
                mass_sum[k] += mass_sum[i];
                u_weighted[k] += u_weighted[i];
                mass_sum[i] = 0.0;
                u_weighted[i] = 0.0;
            }
        }
    }

    let mut peaks = Vec::with_capacity(selected.len());
    for (k, sel) in selected.iter().enumerate() {
        let mass = mass_sum[k];
        if mass <= 0.0 {
            continue;
        }
        let u_erb = u_weighted[k] / mass;
        let bin_idx = sel.idx;
        peaks.push(Peak {
            u_erb,
            mass,
            bin_idx,
        });
    }

    peaks
}

pub fn peaks_to_delta_density(peaks: &[Peak], du: &[f32], len: usize) -> Vec<f32> {
    let peak_masses: Vec<(usize, f32)> = peaks.iter().map(|p| (p.bin_idx, p.mass)).collect();
    density::peaks_mass_to_delta_density(len, &peak_masses, du)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::density;
    use crate::core::log2space::Log2Space;
    use crate::core::roughness_kernel::erb_grid;

    #[test]
    fn small_peaks_are_dropped_and_mass_is_conserved() {
        let space = Log2Space::new(100.0, 2000.0, 64);
        let (_erb, du) = erb_grid(&space);
        let mut density = vec![0.0f32; space.centers_hz.len()];

        let main = density.len() / 2;
        density[main] = 1.0;
        density[main - 2] = 0.05;
        density[main + 2] = 0.08;
        density[main - 3] = 0.01;
        density[main + 3] = 0.02;

        let cfg = PeakExtractConfig {
            max_peaks: None,
            min_rel_db_power: -10.0,
            min_abs_power_density: None,
            min_prominence_db_power: 0.0,
            min_rel_mass_db_power: -50.0,
            min_mass_fraction: None,
            min_sep_erb: 0.1,
        };
        let peaks = extract_peaks_density(&density, &space, &cfg);
        assert_eq!(peaks.len(), 1);

        let max_amp = density.iter().cloned().fold(0.0f32, f32::max);
        let min_abs_rel = max_amp * db::db_to_power_ratio(cfg.min_rel_db_power);
        let min_abs_abs = cfg.min_abs_power_density.unwrap_or(0.0);
        let min_abs = min_abs_rel.max(min_abs_abs);
        let mut masked = vec![0.0f32; density.len()];
        for (i, &a) in density.iter().enumerate() {
            if a >= min_abs {
                masked[i] = a;
            }
        }
        let expected_mass = density::density_to_mass(&masked, &du);
        let diff = (peaks[0].mass - expected_mass).abs();
        assert!(diff < 1e-6, "mass diff {}", diff);
    }

    #[test]
    fn compress_after_aggregate_removes_split_advantage() {
        let space = Log2Space::new(200.0, 2000.0, 48);
        let (_erb, du) = erb_grid(&space);
        let exp = 0.23f32;
        let ref_power = 1.0f32;
        let cfg = PeakExtractConfig {
            max_peaks: None,
            min_rel_db_power: -120.0,
            min_abs_power_density: None,
            min_prominence_db_power: 0.0,
            min_rel_mass_db_power: -70.0,
            min_mass_fraction: None,
            min_sep_erb: 0.2,
        };

        let total_mass = 1.0f32;
        let idx = space.centers_hz.len() / 2;
        let idx2 = idx + 1;

        let mut density_single = vec![0.0f32; space.centers_hz.len()];
        density_single[idx] = total_mass / du[idx].max(1e-12);

        let mut density_split = vec![0.0f32; space.centers_hz.len()];
        density_split[idx] = (total_mass * 0.5) / du[idx].max(1e-12);
        density_split[idx2] = (total_mass * 0.5) / du[idx2].max(1e-12);

        let new_single =
            compress_total_after_aggregate(&density_single, &space, exp, ref_power, &cfg);
        let new_split =
            compress_total_after_aggregate(&density_split, &space, exp, ref_power, &cfg);
        assert!(
            (new_single - new_split).abs() < 1e-6,
            "aggregate mismatch: {} vs {}",
            new_single,
            new_split
        );

        let old_single = compress_total_per_bin(&density_single, &du, exp, ref_power);
        let old_split = compress_total_per_bin(&density_split, &du, exp, ref_power);
        assert!(
            old_split > old_single * 1.01,
            "split should be larger: {} vs {}",
            old_split,
            old_single
        );
    }

    fn compress_total_after_aggregate(
        density: &[f32],
        space: &Log2Space,
        exp: f32,
        ref_power: f32,
        cfg: &PeakExtractConfig,
    ) -> f32 {
        let peaks = extract_peaks_density(density, space, cfg);
        peaks
            .iter()
            .map(|p| (p.mass / ref_power).powf(exp))
            .sum::<f32>()
    }

    fn compress_total_per_bin(density: &[f32], du: &[f32], exp: f32, ref_power: f32) -> f32 {
        density
            .iter()
            .zip(du.iter())
            .map(|(&a, &d)| (a * d / ref_power).powf(exp))
            .sum::<f32>()
    }

    #[test]
    fn side_lobe_peak_dropped_by_mass_filter() {
        let space = Log2Space::new(80.0, 8000.0, 128);
        let (erb, _du) = erb_grid(&space);
        let mut density = vec![0.0f32; erb.len()];

        let center = erb.len() / 2;
        for i in (center - 3)..=(center + 3) {
            let x = (i as f32 - center as f32) / 1.5;
            density[i] = (-0.5 * x * x).exp();
        }
        let side = center + 18;
        density[side] = 0.01;

        let cfg = PeakExtractConfig::strict();
        let peaks = extract_peaks_density(&density, &space, &cfg);

        assert!(peaks.len() >= 1);
        assert!(
            peaks
                .iter()
                .any(|p| (p.bin_idx as isize - center as isize).abs() <= 2),
            "main peak should remain"
        );
        assert!(
            peaks.iter().all(|p| p.bin_idx != side),
            "side-lobe peak should be removed"
        );
    }

    #[test]
    fn strict_reduces_small_spike_count_vs_normal() {
        let space = Log2Space::new(80.0, 8000.0, 128);
        let (erb, _du) = erb_grid(&space);
        let mut density = vec![0.0f32; erb.len()];

        let center = erb.len() / 2;
        for i in (center - 4)..=(center + 4) {
            let x = (i as f32 - center as f32) / 2.0;
            density[i] = (-0.5 * x * x).exp();
        }
        for offset in [-30isize, -18, -9, 9, 18, 30] {
            let idx = (center as isize + offset) as usize;
            density[idx] = 0.01;
        }

        let normal = extract_peaks_density(&density, &space, &PeakExtractConfig::normal());
        let strict = extract_peaks_density(&density, &space, &PeakExtractConfig::strict());
        assert!(normal.len() >= 2, "expected multiple normal peaks");
        assert!(
            strict.len() < normal.len(),
            "expected strict to reduce peaks: normal={} strict={}",
            normal.len(),
            strict.len()
        );
    }

    #[test]
    fn mass_is_conserved_after_mass_filter() {
        let space = Log2Space::new(80.0, 8000.0, 128);
        let (_erb, du) = erb_grid(&space);
        let mut density = vec![0.0f32; space.centers_hz.len()];

        let center = density.len() / 2;
        for i in (center - 4)..=(center + 4) {
            let x = (i as f32 - center as f32) / 2.0;
            density[i] = (-0.5 * x * x).exp();
        }
        let side = center + 20;
        density[side] = 0.4;

        let cfg = PeakExtractConfig {
            min_rel_db_power: -120.0,
            min_prominence_db_power: 0.0,
            min_rel_mass_db_power: -6.0,
            min_mass_fraction: Some(0.05),
            ..PeakExtractConfig::normal()
        };
        let peaks = extract_peaks_density(&density, &space, &cfg);
        let total_mass_in = density::density_to_mass(&density, &du);
        let total_mass_out: f32 = peaks.iter().map(|p| p.mass).sum();
        let diff = (total_mass_in - total_mass_out).abs();
        assert!(diff < 1e-5, "mass diff {}", diff);
    }

    #[test]
    fn mass_filter_keeps_at_least_one_peak() {
        let space = Log2Space::new(200.0, 2000.0, 48);
        let (_erb, _du) = erb_grid(&space);
        let mut density = vec![0.0f32; space.centers_hz.len()];
        let center = density.len() / 2;
        density[center] = 0.1;
        density[center + 4] = 0.08;

        let cfg = PeakExtractConfig {
            max_peaks: None,
            min_rel_db_power: -120.0,
            min_abs_power_density: None,
            min_prominence_db_power: 0.0,
            min_rel_mass_db_power: 3.0,
            min_mass_fraction: Some(0.9),
            min_sep_erb: 0.2,
        };
        let peaks = extract_peaks_density(&density, &space, &cfg);
        assert!(!peaks.is_empty(), "expected at least one peak");
    }

    #[test]
    fn nsgt_default_collapses_small_ripples() {
        let space = Log2Space::new(100.0, 4000.0, 96);
        let (_erb, _du) = erb_grid(&space);
        let mut density = vec![0.0f32; space.centers_hz.len()];
        let center = density.len() / 2;
        density[center] = 1.0;
        density[center - 12] = 0.02;
        density[center + 14] = 0.015;

        let peaks = extract_peaks_density(&density, &space, &PeakExtractConfig::nsgt_default());
        assert_eq!(peaks.len(), 1, "expected one dominant peak");
        assert_eq!(peaks[0].bin_idx, center);
    }

    #[test]
    fn min_abs_power_density_blocks_floor_peaks() {
        let space = Log2Space::new(100.0, 4000.0, 96);
        let (_erb, _du) = erb_grid(&space);
        let mut density = vec![0.0f32; space.centers_hz.len()];
        let center = density.len() / 2;
        density[center] = 1.0;
        density[center - 10] = 0.04;
        density[center + 12] = 0.03;

        let cfg = PeakExtractConfig {
            max_peaks: None,
            min_rel_db_power: -120.0,
            min_abs_power_density: Some(0.05),
            min_prominence_db_power: 0.0,
            min_rel_mass_db_power: -120.0,
            min_mass_fraction: None,
            min_sep_erb: 0.1,
        };
        let peaks = extract_peaks_density(&density, &space, &cfg);
        assert_eq!(peaks.len(), 1, "floor peaks should be ignored");
        assert_eq!(peaks[0].bin_idx, center);
    }

    #[test]
    fn bin_idx_is_stable_across_mass_skew() {
        let space = Log2Space::new(120.0, 4000.0, 64);
        let (erb, _du) = erb_grid(&space);
        let center = erb.len() / 2;

        let mut density_right = vec![0.0f32; erb.len()];
        density_right[center] = 1.0;
        for i in 1..6 {
            density_right[center + i] = 0.95 - 0.05 * i as f32;
        }

        let mut density_left = vec![0.0f32; erb.len()];
        density_left[center] = 1.0;
        for i in 1..6 {
            density_left[center - i] = 0.95 - 0.05 * i as f32;
        }

        let cfg = PeakExtractConfig {
            max_peaks: None,
            min_rel_db_power: -120.0,
            min_abs_power_density: None,
            min_prominence_db_power: 0.0,
            min_rel_mass_db_power: -120.0,
            min_mass_fraction: None,
            min_sep_erb: 0.1,
        };
        let peaks_right = extract_peaks_density(&density_right, &space, &cfg);
        let peaks_left = extract_peaks_density(&density_left, &space, &cfg);
        assert_eq!(peaks_right.len(), 1);
        assert_eq!(peaks_left.len(), 1);
        assert_eq!(peaks_right[0].bin_idx, center);
        assert_eq!(peaks_left[0].bin_idx, center);

        let u_mid = 0.5 * (erb[center] + erb[center + 1]);
        assert!(
            peaks_right[0].u_erb > u_mid || peaks_left[0].u_erb < u_mid,
            "expected centroid skew without bin jitter"
        );
    }
}
</file>

<file path="src/core/phase.rs">
use std::f32::consts::{PI, TAU};

#[inline]
pub fn wrap_0_tau(x: f32) -> f32 {
    x.rem_euclid(TAU)
}

/// Normalize to the range [-PI, PI).
#[inline]
pub fn wrap_pm_pi(x: f32) -> f32 {
    (x + PI).rem_euclid(TAU) - PI
}

#[inline]
pub fn angle_diff_pm_pi(a: f32, b: f32) -> f32 {
    wrap_pm_pi(a - b)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn angle_diff_is_wrapped() {
        let pairs = [
            (0.0, 0.0),
            (TAU, 0.0),
            (PI, -PI),
            (0.25 * PI, -0.25 * PI),
            (3.0 * PI, PI),
        ];
        for (a, b) in pairs {
            let d = angle_diff_pm_pi(a, b);
            assert!(d >= -PI && d < PI, "angle_diff out of range: {d}");
            let d2 = angle_diff_pm_pi(a + TAU, b);
            assert!((d - d2).abs() < 1e-5, "angle_diff periodicity failed");
        }
    }

    #[test]
    fn wrap_0_tau_in_range() {
        let values = [-10.0 * TAU, -TAU, -PI, -0.1, 0.0, PI, TAU, 3.5 * TAU];
        for v in values {
            let w = wrap_0_tau(v);
            assert!(w >= 0.0 && w < TAU, "wrap_0_tau out of range: {w}");
        }
    }

    #[test]
    fn wrap_pm_pi_in_range() {
        let values = [-10.0 * TAU, -TAU, -PI, -0.1, 0.0, PI, TAU, 3.5 * TAU];
        for v in values {
            let w = wrap_pm_pi(v);
            assert!(w >= -PI && w < PI, "wrap_pm_pi out of range: {w}");
        }
    }
}
</file>

<file path="src/core/roughness_worker.rs">
use std::sync::Arc;

use crossbeam_channel::{Receiver, Sender};

use crate::core::landscape::{Landscape, LandscapeUpdate};
use crate::core::stream::roughness::RoughnessStream;

/// Result payload from the roughness worker:
/// `(frame_id, landscape_snapshot)`.
pub type RoughnessResult = (u64, Landscape);

/// Roughness worker: receives time-domain hops, runs NSGT-based audio analysis,
/// and publishes the latest analysis for the main thread to merge.
pub fn run(
    mut stream: RoughnessStream,
    hop_rx: Receiver<(u64, Arc<[f32]>)>,
    result_tx: Sender<RoughnessResult>,
    update_rx: Receiver<LandscapeUpdate>,
) {
    while let Ok((mut frame_id, audio_hop)) = hop_rx.recv() {
        // Drain backlog but *do not* skip audio hops.
        // NSGT-RT maintains an internal ring buffer and assumes time continuity; dropping hops
        // effectively deletes samples and can create broadband artifacts ("mystery peaks").
        let mut hops = Vec::with_capacity(8);
        hops.push(audio_hop);
        for (latest_id, latest_hop) in hop_rx.try_iter() {
            frame_id = latest_id;
            hops.push(latest_hop);
        }

        // Apply parameter updates (roughness params primarily; others are harmless here).
        for upd in update_rx.try_iter() {
            stream.apply_update(upd);
        }

        // Process each hop in-order to preserve the per-hop dt used by the normalizers.
        let mut analysis = stream.process(hops[0].as_ref());
        for hop in &hops[1..] {
            analysis = stream.process(hop.as_ref());
        }
        let _ = result_tx.try_send((frame_id, analysis));
    }
}
</file>

<file path="src/core/utils.rs">
use rand::{Rng, SeedableRng};

/// Calculate A-weighting gain (linear) for a given frequency.
/// Standard curve approximation normalized to 1.0 at 1000 Hz.
pub fn a_weighting_gain(f_hz: f32) -> f32 {
    let f2 = f_hz * f_hz;
    let c1 = 12194.0 * 12194.0;
    let c2 = 20.6 * 20.6;
    let c3 = 107.7 * 107.7;
    let c4 = 737.9 * 737.9;

    let num = c1 * f2 * f2;
    let den = (f2 + c2) * (f2 + c3).sqrt() * (f2 + c4).sqrt() * (f2 + c1);

    let ra = num / den;
    // Normalization: A-weighting at 1kHz is usually 0dB (gain=1.0).
    // The standard formula gives ~0.794 at 1kHz. We normalize so 1kHz = 1.0.
    ra * 1.2589
}

/// Single-sample pink noise (Paul Kellet 3-pole filter).
pub fn pink_noise_tick<R: Rng + ?Sized>(
    rng: &mut R,
    b0: &mut f32,
    b1: &mut f32,
    b2: &mut f32,
) -> f32 {
    let white = rng.random_range(-1.0..1.0);
    *b0 = 0.99765 * *b0 + white * 0.099_046_0;
    *b1 = 0.96300 * *b1 + white * 0.296_516_4;
    *b2 = 0.57000 * *b2 + white * 1.052_691_3;
    let pink = *b0 + *b1 + *b2 + white * 0.1848;
    pink * 0.03
}

// --- noise generators ---
pub fn white_noise(n: usize, seed: u64) -> Vec<f32> {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    (0..n).map(|_| rng.random_range(-1.0..1.0)).collect()
}

/// Pink noise via simple 3-pole filter approximation (Voss–McCartney not required)
pub fn pink_noise(n: usize, seed: u64) -> Vec<f32> {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let mut b0 = 0.0f32;
    let mut b1 = 0.0f32;
    let mut b2 = 0.0f32;
    let mut out = Vec::with_capacity(n);
    for _ in 0..n {
        out.push(pink_noise_tick(&mut rng, &mut b0, &mut b1, &mut b2));
    }
    out
}

/// Brown (red) noise via single-pole low-pass filter (−6 dB/oct)
pub fn brown_noise(n: usize, seed: u64) -> Vec<f32> {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let mut y = 0.0f32;
    let mut out = Vec::with_capacity(n);

    // Simple 1-pole IIR with pole near DC
    // y[n] = a*y[n-1] + (1 - a)*x[n]
    // choose a close to 1.0 to get strong low-frequency emphasis
    let a = 0.995; // ≈ −6 dB/oct

    for _ in 0..n {
        let white = rng.random_range(-1.0..1.0);
        y = a * y + (1.0 - a) * white;
        out.push(y);
    }
    out
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::db;

    #[test]
    fn test_a_weighting_reference_values() {
        let cases = [
            (1000.0, 0.0),   // 0 dB
            (100.0, -19.1),  // approx -19.1 dB
            (20.0, -50.5),   // approx -50.5 dB
            (20000.0, -9.3), // approx -9.3 dB
        ];

        for (f, expected_db) in cases {
            let gain = a_weighting_gain(f);
            let db = db::amp_to_db(gain);
            assert!(
                (db - expected_db).abs() < 0.5,
                "A-weighting mismatch at {} Hz: expected ~{} dB, got {:.2} dB",
                f,
                expected_db,
                db
            );
        }
    }

    #[test]
    #[ignore]
    fn plot_a_weighting_curve() -> Result<(), Box<dyn std::error::Error>> {
        use plotters::prelude::*;
        use std::path::Path;

        let path = Path::new("target/a_weighting_curve.png");
        let root = BitMapBackend::new(path, (1024, 768)).into_drawing_area();
        root.fill(&WHITE)?;

        let mut chart = ChartBuilder::on(&root)
            .caption("A-Weighting Curve (IEC 61672-1)", ("sans-serif", 30))
            .margin(20)
            .x_label_area_size(40)
            .y_label_area_size(50)
            .build_cartesian_2d((20.0f32..24000.0f32).log_scale(), -80.0f32..10.0f32)?;

        chart
            .configure_mesh()
            .x_desc("Frequency [Hz]")
            .y_desc("Gain [dB]")
            .x_labels(10)
            .x_label_formatter(&|v| format!("{:.0}", v))
            .y_label_formatter(&|v| format!("{:.0}", v))
            .draw()?;

        // Plot curve (log-spaced points for smoothness)
        let n_points = 500;
        let log_min = (20.0f32).ln();
        let log_max = (24000.0f32).ln();
        let points: Vec<(f32, f32)> = (0..=n_points)
            .map(|i| {
                let t = i as f32 / n_points as f32;
                let f = (log_min + t * (log_max - log_min)).exp();
                let g = a_weighting_gain(f);
                let db = db::amp_to_db(g);
                (f, db)
            })
            .collect();

        chart
            .draw_series(LineSeries::new(points, &BLUE))?
            .label("A-Weighting")
            .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &BLUE));

        chart
            .configure_series_labels()
            .background_style(&WHITE.mix(0.8))
            .border_style(&BLACK)
            .draw()?;

        root.present()?;
        println!("Saved plot to {:?}", path);
        Ok(())
    }
}
</file>

<file path="src/life/conductor.rs">
use std::collections::VecDeque;

use tracing::info;

use super::population::Population;
use super::scenario::{Action, Scenario, SceneMarker, TimedEvent};
use crate::core::landscape::LandscapeFrame;

#[derive(Debug, Clone)]
pub struct QueuedEvent {
    pub time: f32,
    pub order: u64,
    pub actions: Vec<Action>,
}

#[derive(Debug, Clone)]
struct SceneInfo {
    name: String,
    time: f32,
    order: u64,
}

#[derive(Debug)]
pub struct Conductor {
    event_queue: VecDeque<QueuedEvent>,
    total_duration: f32,
    scenes: Vec<SceneInfo>,
}

impl Conductor {
    pub fn from_scenario(s: Scenario) -> Self {
        let mut scenes: Vec<SceneInfo> = s
            .scene_markers
            .into_iter()
            .map(|SceneMarker { name, time, order }| SceneInfo { name, time, order })
            .collect();
        scenes.sort_by(|a, b| {
            a.time
                .partial_cmp(&b.time)
                .unwrap_or(std::cmp::Ordering::Equal)
                .then_with(|| a.order.cmp(&b.order))
        });

        let mut events: Vec<QueuedEvent> = s
            .events
            .into_iter()
            .map(
                |TimedEvent {
                     time,
                     order,
                     actions,
                 }| QueuedEvent {
                    time,
                    order,
                    actions,
                },
            )
            .collect();

        events.sort_by(|a, b| {
            a.time
                .partial_cmp(&b.time)
                .unwrap_or(std::cmp::Ordering::Equal)
                .then_with(|| a.order.cmp(&b.order))
        });

        let total_duration = s.duration_sec;
        Self {
            event_queue: events.into(),
            total_duration,
            scenes,
        }
    }

    pub fn from_events(events: Vec<QueuedEvent>) -> Self {
        let mut events = events;
        events.sort_by(|a, b| {
            a.time
                .partial_cmp(&b.time)
                .unwrap_or(std::cmp::Ordering::Equal)
                .then_with(|| a.order.cmp(&b.order))
        });
        let total_duration = events.last().map(|ev| ev.time).unwrap_or(0.0);
        Self {
            event_queue: events.into(),
            total_duration,
            scenes: Vec::new(),
        }
    }

    /// Apply any events scheduled up to and including current time.
    ///
    /// Note: spawn placement rules (e.g. minimum ERB distance between fundamentals) are enforced
    /// inside `Population` when handling spawn actions.
    pub fn dispatch_until(
        &mut self,
        time_sec: f32,
        _current_frame: u64,
        landscape: &LandscapeFrame,
        mut roughness_rt: Option<&mut crate::core::stream::roughness::RoughnessStream>,
        population: &mut Population,
        world: &mut crate::life::world_model::WorldModel,
    ) {
        while let Some(ev) = self.event_queue.front() {
            if ev.time > time_sec {
                break;
            }

            let ev = self.event_queue.pop_front().expect("front exists");
            let action_descs: Vec<String> = ev.actions.iter().map(ToString::to_string).collect();
            info!("[t={:.3}] Event: {}", ev.time, action_descs.join(" | "));
            for action in ev.actions {
                match action {
                    crate::life::scenario::Action::PostIntent { .. } => {
                        world.apply_action(&action);
                    }
                    _ => {
                        population.apply_action(action, landscape, roughness_rt.as_deref_mut());
                    }
                }
            }
        }
    }

    pub fn is_done(&self) -> bool {
        self.event_queue.is_empty()
    }

    pub fn total_duration(&self) -> f32 {
        self.total_duration
    }

    pub fn remaining_events(&self) -> usize {
        self.event_queue.len()
    }

    pub fn current_scene_name(&self, time_sec: f32) -> Option<String> {
        let mut current: Option<String> = None;
        for scene in &self.scenes {
            if time_sec + f32::EPSILON >= scene.time {
                current = Some(scene.name.clone());
            } else {
                break;
            }
        }
        current
    }
}
</file>

<file path="src/life/lifecycle.rs">
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

use super::scenario::EnvelopeConfig;
use std::fmt;

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case", deny_unknown_fields)]
pub enum LifecycleConfig {
    Decay {
        #[serde(default = "default_initial_energy")]
        initial_energy: f32,
        half_life_sec: f32,
        #[serde(default = "default_decay_attack")]
        attack_sec: f32,
    },
    Sustain {
        #[serde(default = "default_initial_energy")]
        initial_energy: f32,
        metabolism_rate: f32,
        #[serde(default)]
        recharge_rate: Option<f32>,
        #[serde(default)]
        action_cost: Option<f32>,
        #[serde(default)]
        envelope: EnvelopeConfig,
    },
}

impl Default for LifecycleConfig {
    fn default() -> Self {
        LifecycleConfig::Decay {
            initial_energy: 1.0,
            half_life_sec: 1.0,
            attack_sec: default_decay_attack(),
        }
    }
}

impl LifecycleConfig {
    pub fn create_lifecycle(self) -> Box<dyn Lifecycle> {
        match self {
            LifecycleConfig::Decay {
                initial_energy,
                half_life_sec,
                attack_sec,
            } => Box::new(DecayLifecycle::new(
                initial_energy,
                half_life_sec,
                attack_sec,
            )),
            LifecycleConfig::Sustain {
                initial_energy,
                metabolism_rate,
                envelope,
                ..
            } => Box::new(SustainLifecycle::new(
                initial_energy,
                metabolism_rate,
                envelope,
            )),
        }
    }
}

impl fmt::Display for LifecycleConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            LifecycleConfig::Decay {
                initial_energy,
                half_life_sec,
                attack_sec,
            } => write!(
                f,
                "lifecycle=decay(init={:.2}, half={:.3}s, attack={:.3}s)",
                initial_energy, half_life_sec, attack_sec
            ),
            LifecycleConfig::Sustain {
                initial_energy,
                metabolism_rate,
                recharge_rate,
                action_cost,
                envelope,
            } => write!(
                f,
                "lifecycle=sustain(init={:.2}, metab={:.3}/s, recharge={:.3}, action_cost={:.3}, env=[atk={:.3}s, dec={:.3}s, sus={:.2}])",
                initial_energy,
                metabolism_rate,
                recharge_rate.unwrap_or(0.5),
                action_cost.unwrap_or(0.02),
                envelope.attack_sec,
                envelope.decay_sec,
                envelope.sustain_level
            ),
        }
    }
}

pub trait Lifecycle: Send + Sync + std::fmt::Debug {
    /// Advance lifecycle and compute gain for this frame.
    fn process(&mut self, dt: f32, age: f32) -> f32;
    fn is_alive(&self) -> bool;
}

pub fn default_decay_attack() -> f32 {
    0.01
}

fn default_initial_energy() -> f32 {
    1.0
}

#[derive(Debug)]
pub struct DecayLifecycle {
    energy: f32,
    lambda: f32,
    attack_sec: f32,
}

impl DecayLifecycle {
    pub fn new(initial_energy: f32, half_life_sec: f32, attack_sec: f32) -> Self {
        let half_life_sec = half_life_sec.max(1e-6);
        let lambda = (0.5f32).ln() / half_life_sec;
        Self {
            energy: initial_energy.max(0.0),
            lambda,
            attack_sec: attack_sec.max(1e-6),
        }
    }
}

impl Lifecycle for DecayLifecycle {
    fn process(&mut self, dt: f32, age: f32) -> f32 {
        self.energy *= (self.lambda * dt).exp();
        if self.energy.abs() < 1e-8 {
            self.energy = 0.0;
        }
        let attack_gain = (age / self.attack_sec).min(1.0);
        let gain = self.energy * attack_gain;
        if gain < 1e-6 { 0.0 } else { gain }
    }

    fn is_alive(&self) -> bool {
        self.energy > 1e-4
    }
}

#[derive(Debug)]
pub struct SustainLifecycle {
    energy: f32,
    metabolism_rate: f32,
    envelope: EnvelopeConfig,
    alive: bool,
}

impl SustainLifecycle {
    pub fn new(initial_energy: f32, metabolism_rate: f32, envelope: EnvelopeConfig) -> Self {
        Self {
            energy: initial_energy.max(0.0),
            metabolism_rate,
            envelope,
            alive: true,
        }
    }
}

impl Lifecycle for SustainLifecycle {
    fn process(&mut self, dt: f32, age: f32) -> f32 {
        if self.energy > 0.0 {
            self.energy -= self.metabolism_rate * dt;
            if self.energy < 0.0 {
                self.energy = 0.0;
            }
        }
        if self.energy <= 0.0 {
            self.alive = false;
            return 0.0;
        }

        let env = &self.envelope;
        let attack = env.attack_sec.max(1e-6);
        let decay = env.decay_sec.max(1e-6);
        let sustain = env.sustain_level.clamp(0.0, 1.0);

        let gain_env = if age < attack {
            (age / attack).min(1.0)
        } else if age < attack + decay {
            let t = (age - attack) / decay;
            1.0 + (sustain - 1.0) * t.clamp(0.0, 1.0)
        } else {
            sustain
        };

        let gain = gain_env * self.energy;
        if age < attack + decay && self.energy > 0.0 {
            self.alive = true;
            return gain;
        }

        if self.energy <= 0.0 || (gain <= 1e-6 && age > attack) {
            self.alive = false;
            0.0
        } else {
            self.alive = true;
            gain
        }
    }

    fn is_alive(&self) -> bool {
        self.alive
    }
}
</file>

<file path="src/life/meta.rs">
// Placeholder for environment meta-parameters
#[derive(Clone, Debug, Default)]
pub struct MetaParams {
    pub temperature: f32,
    pub energy: f32,
}
</file>

<file path="src/life/perceptual.rs">
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Default, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct PerceptualConfig {
    pub tau_fast: Option<f32>,
    pub tau_slow: Option<f32>,
    pub w_boredom: Option<f32>,
    pub w_familiarity: Option<f32>,
    pub rho_self: Option<f32>,
    pub boredom_gamma: Option<f32>,
    pub self_smoothing_radius: Option<usize>,
    pub silence_mass_epsilon: Option<f32>,
}

#[derive(Debug, Clone)]
pub struct FeaturesNow {
    pub distribution: Vec<f32>,
    pub mass: f32,
}

impl FeaturesNow {
    pub fn from_subjective_intensity(raw: &[f32]) -> Self {
        let mut distribution = Vec::with_capacity(raw.len());
        let mut sum = 0.0f32;
        for &v in raw {
            let c = v.max(0.0).ln_1p();
            sum += c;
            distribution.push(c);
        }
        if sum > 0.0 {
            let inv = 1.0 / sum;
            for v in &mut distribution {
                *v *= inv;
            }
        }
        Self {
            distribution,
            mass: sum,
        }
    }
}

#[derive(Debug, Clone)]
pub struct PerceptualContext {
    pub tau_fast: f32,
    pub tau_slow: f32,
    pub w_boredom: f32,
    pub w_familiarity: f32,
    pub rho_self: f32,
    pub boredom_gamma: f32,
    pub self_smoothing_radius: usize,
    pub silence_mass_epsilon: f32,
    h_fast: Vec<f32>,
    h_slow: Vec<f32>,
}

impl PerceptualContext {
    pub fn from_config(config: &PerceptualConfig, n_bins: usize) -> Self {
        let tau_fast = config.tau_fast.unwrap_or(0.5).max(1e-3);
        let tau_slow = config.tau_slow.unwrap_or(20.0).max(tau_fast + 1e-3);
        let w_boredom = config.w_boredom.unwrap_or(1.0).max(0.0);
        let w_familiarity = config.w_familiarity.unwrap_or(0.2).max(0.0);
        let rho_self = config.rho_self.unwrap_or(0.15).clamp(0.0, 1.0);
        let boredom_gamma = config.boredom_gamma.unwrap_or(0.5).clamp(0.1, 1.0);
        let self_smoothing_radius = config.self_smoothing_radius.unwrap_or(1);
        let silence_mass_epsilon = config.silence_mass_epsilon.unwrap_or(1e-6).max(0.0);
        Self {
            tau_fast,
            tau_slow,
            w_boredom,
            w_familiarity,
            rho_self,
            boredom_gamma,
            self_smoothing_radius,
            silence_mass_epsilon,
            h_fast: vec![0.0; n_bins],
            h_slow: vec![0.0; n_bins],
        }
    }

    pub fn ensure_len(&mut self, n_bins: usize) {
        if self.h_fast.len() == n_bins {
            return;
        }
        self.h_fast.resize(n_bins, 0.0);
        self.h_slow.resize(n_bins, 0.0);
    }

    pub fn score_adjustment(&self, candidate_idx: usize) -> f32 {
        if candidate_idx >= self.h_fast.len() {
            return 0.0;
        }
        let radius = self
            .self_smoothing_radius
            .min(self.h_fast.len().saturating_sub(1));
        let mut boredom = 0.0f32;
        let mut familiarity = 0.0f32;
        for_each_candidate_weight(candidate_idx, self.h_fast.len(), radius, |idx, w| {
            boredom += self.h_fast[idx] * w;
            familiarity += self.h_slow[idx] * w;
        });
        let curved_boredom = boredom.max(0.0).powf(self.boredom_gamma);
        (self.w_familiarity * familiarity) - (self.w_boredom * curved_boredom)
    }

    pub fn update(&mut self, candidate_idx: usize, features: &FeaturesNow, dt: f32) {
        if self.h_fast.is_empty() || self.h_slow.is_empty() {
            return;
        }
        debug_assert_eq!(features.distribution.len(), self.h_fast.len());
        let dt = dt.max(0.0);
        let a_f = (-dt / self.tau_fast.max(1e-3)).exp();
        let a_s = (-dt / self.tau_slow.max(1e-3)).exp();
        let one_minus_a_f = 1.0 - a_f;
        let one_minus_a_s = 1.0 - a_s;

        let n_bins = self.h_fast.len();
        let env_present = features.mass > self.silence_mass_epsilon;
        let (env_weight, self_weight) = if env_present {
            (1.0 - self.rho_self, self.rho_self)
        } else {
            (0.0, 1.0)
        };

        for (i, (h_fast, h_slow)) in self
            .h_fast
            .iter_mut()
            .zip(self.h_slow.iter_mut())
            .enumerate()
        {
            let x_env = if env_present && i < features.distribution.len() {
                features.distribution[i]
            } else {
                0.0
            };
            let x_env_scaled = env_weight * x_env;
            *h_fast = a_f * *h_fast + one_minus_a_f * x_env_scaled;
            *h_slow = a_s * *h_slow + one_minus_a_s * x_env_scaled;
        }

        if self_weight > 0.0 && candidate_idx < n_bins {
            let (h_fast, h_slow) = (&mut self.h_fast, &mut self.h_slow);
            let radius = self.self_smoothing_radius.min(n_bins.saturating_sub(1));
            for_each_candidate_weight(candidate_idx, n_bins, radius, |idx, w| {
                h_fast[idx] += one_minus_a_f * self_weight * w;
                h_slow[idx] += one_minus_a_s * self_weight * w;
            });
        }
    }
}

fn for_each_candidate_weight(
    candidate_idx: usize,
    n_bins: usize,
    radius: usize,
    mut f: impl FnMut(usize, f32),
) {
    if candidate_idx >= n_bins || n_bins == 0 {
        return;
    }
    let radius = radius.min(n_bins.saturating_sub(1));
    if radius == 0 {
        f(candidate_idx, 1.0);
        return;
    }

    let mut sum = 0.0f32;
    for offset in -(radius as isize)..=(radius as isize) {
        let idx = candidate_idx as isize + offset;
        if idx < 0 || idx >= n_bins as isize {
            continue;
        }
        let dist = offset.unsigned_abs();
        let weight = if radius == 1 {
            if offset == 0 { 0.5 } else { 0.25 }
        } else {
            1.0 - (dist as f32 / (radius as f32 + 1.0))
        };
        if weight > 0.0 {
            sum += weight;
        }
    }

    if sum <= 0.0 {
        return;
    }
    let inv_sum = 1.0 / sum;
    for offset in -(radius as isize)..=(radius as isize) {
        let idx = candidate_idx as isize + offset;
        if idx < 0 || idx >= n_bins as isize {
            continue;
        }
        let dist = offset.unsigned_abs();
        let weight = if radius == 1 {
            if offset == 0 { 0.5 } else { 0.25 }
        } else {
            1.0 - (dist as f32 / (radius as f32 + 1.0))
        };
        if weight > 0.0 {
            f(idx as usize, weight * inv_sum);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::for_each_candidate_weight;

    #[test]
    fn candidate_weights_normalize_and_stay_in_range() {
        let mut sum = 0.0f32;
        let mut max_idx = 0usize;
        for_each_candidate_weight(0, 8, 1, |idx, w| {
            sum += w;
            max_idx = max_idx.max(idx);
        });
        assert!((sum - 1.0).abs() < 1e-6);
        assert!(max_idx < 8);
    }

    #[test]
    fn candidate_weights_preserve_ratio_at_edges() {
        let mut w0 = 0.0f32;
        let mut w1 = 0.0f32;
        for_each_candidate_weight(0, 8, 1, |idx, w| {
            if idx == 0 {
                w0 = w;
            } else if idx == 1 {
                w1 = w;
            }
        });
        assert!(w1 > 0.0);
        assert!((w0 / w1 - 2.0).abs() < 1e-6);
    }

    #[test]
    fn candidate_weights_radius_is_clamped() {
        let mut sum = 0.0f32;
        let mut max_idx = 0usize;
        for_each_candidate_weight(2, 5, 999, |idx, w| {
            sum += w;
            max_idx = max_idx.max(idx);
        });
        assert!((sum - 1.0).abs() < 1e-6);
        assert!(max_idx < 5);
    }
}
</file>

<file path="src/ui/mod.rs">
pub mod plots;
pub mod viewdata;
pub mod windows;
</file>

<file path="src/ui/viewdata.rs">
use std::sync::Arc;

use crate::core::landscape::LandscapeFrame;
use crate::life::world_model::WorldView;

#[derive(Clone, Debug)]
pub struct WaveFrame {
    pub fs: f32,
    pub samples: Arc<[f32]>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecFrame {
    pub spec_hz: Vec<f32>,
    pub amps: Vec<f32>,
}

#[derive(Clone, Copy, Debug, Default)]
pub struct DorsalFrame {
    pub e_low: f32,
    pub e_mid: f32,
    pub e_high: f32,
    pub flux: f32,
}

#[derive(Clone, Debug, Default)]
pub struct AgentStateInfo {
    pub id: u64,
    pub freq_hz: f32,
    pub target_freq: f32,
    pub integration_window: f32,
    pub breath_gain: f32,
    pub consonance: f32,
}

#[derive(Clone, Debug, Default, PartialEq, Eq)]
pub enum PlaybackState {
    #[default]
    NotStarted,
    Playing,
    Finished,
}

#[derive(Clone, Debug, Default)]
pub struct SimulationMeta {
    pub time_sec: f32,
    pub duration_sec: f32,
    pub agent_count: usize,
    pub event_queue_len: usize,
    pub peak_level: f32,
    pub scenario_name: String,
    pub scene_name: Option<String>,
    pub playback_state: PlaybackState,
    pub channel_peak: [f32; 2],
    pub window_peak: [f32; 2],
}

#[derive(Clone, Debug, Default)]
pub struct UiFrame {
    pub wave: WaveFrame,
    pub spec: SpecFrame,
    pub dorsal: DorsalFrame,
    pub landscape: LandscapeFrame,
    pub time_sec: f32,
    pub meta: SimulationMeta,
    pub agents: Vec<AgentStateInfo>,
    pub world: WorldView,
}

impl Default for WaveFrame {
    fn default() -> Self {
        Self {
            fs: 0.0,
            samples: Arc::from(Vec::<f32>::new()),
        }
    }
}
</file>

<file path="tests/run_script_samples.rs">
use std::path::Path;
use std::process::Command;

use walkdir::WalkDir;

#[test]
fn run_headless_scripts() {
    let exe = env!("CARGO_BIN_EXE_conchordal");
    let dir = Path::new("tests/scripts");
    let mut count = 0;

    for entry in WalkDir::new(dir).into_iter().filter_map(Result::ok) {
        let path = entry.path();
        if path.extension().and_then(|s| s.to_str()) != Some("rhai") {
            continue;
        }
        count += 1;
        let stem = path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("script");
        let marker = format!("TEST_OK: {stem}");

        let output = Command::new(exe)
            .env("RUST_LOG", "debug")
            .args(["--nogui", "--play=false"])
            .arg(path)
            .output()
            .unwrap_or_else(|e| panic!("failed to run {}: {e}", path.display()));

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            panic!(
                "script failed ({}): status={} stderr={}",
                path.display(),
                output.status,
                stderr
            );
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        let combined = format!("{stdout}\n{stderr}");
        assert!(
            combined.contains(&marker),
            "marker not found for {}: expected {:?}",
            path.display(),
            marker
        );
    }

    assert!(count > 0, "no .rhai scripts found in tests/scripts");
}
</file>

<file path="src/audio/mod.rs">
pub mod buffer;
pub mod output;
#[cfg(debug_assertions)]
pub mod writer;
</file>

<file path="src/core/stream/roughness.rs">
use crate::core::landscape::RoughnessScalarMode;
use crate::core::landscape::{Landscape, LandscapeParams, LandscapeUpdate};
use crate::core::landscape_spectral::SpectralFrontEnd;
use crate::core::nsgt_rt::RtNsgtKernelLog2;
use crate::core::psycho_state::{
    compute_roughness_reference, normalize_density, roughness_ratio_to_state01,
};
use crate::core::roughness_kernel::erb_grid;

/// Roughness Stream (formerly Ventral).
/// Handles slow spectral analysis focused on roughness.
pub struct RoughnessStream {
    nsgt_rt: RtNsgtKernelLog2,
    params: LandscapeParams,
    spectral_frontend: SpectralFrontEnd,
    roughness_ref_total: f32,
    roughness_ref_peak: f32,

    // Last computed state (roughness-side of the landscape)
    last_landscape: Landscape,
}

impl RoughnessStream {
    pub fn new(params: LandscapeParams, nsgt_rt: RtNsgtKernelLog2) -> Self {
        let spectral_frontend = SpectralFrontEnd::new(nsgt_rt.space().clone(), &params);
        let ref_vals = compute_roughness_reference(&params, nsgt_rt.space());
        let roughness_ref_total = ref_vals.total;
        let roughness_ref_peak = ref_vals.peak;

        Self {
            nsgt_rt: nsgt_rt.clone(),
            params,
            spectral_frontend,
            roughness_ref_total,
            roughness_ref_peak,
            last_landscape: Landscape::new(nsgt_rt.space().clone()),
        }
    }

    /// Access the most recent landscape snapshot without processing.
    pub fn last(&self) -> &Landscape {
        &self.last_landscape
    }

    /// Process audio chunk asynchronously.
    /// Returns the updated Landscape (roughness only).
    pub fn process(&mut self, audio: &[f32]) -> Landscape {
        if audio.is_empty() {
            return self.last_landscape.clone();
        }

        // 1. Update Spectrum (NSGT + Normalization)
        let envelope: Vec<f32> = {
            let env = self.nsgt_rt.process_hop(audio);
            env.to_vec()
        };
        self.last_landscape.nsgt_power = envelope.clone();
        let dt_sec = audio.len() as f32 / self.params.fs;
        let spectral_frame =
            self.spectral_frontend
                .process_nsgt_power(&envelope, dt_sec, &self.params);

        // 2. Compute Roughness
        self.compute_potentials(
            &spectral_frame.subjective_intensity,
            spectral_frame.loudness_mass,
        );

        // 3. Return snapshot
        self.last_landscape.clone()
    }

    fn compute_potentials(&mut self, density: &[f32], loudness_mass: f32) {
        let space = self.nsgt_rt.space();
        let (_erb, du) = erb_grid(space);
        let eps = self.params.roughness_ref_eps.max(1e-12);
        let roughness_k = self.params.roughness_k.max(1e-6);

        // Roughness strength (level-dependent).
        let (r_strength, r_total) = self
            .params
            .roughness_kernel
            .potential_r_from_log2_spectrum(density, space);
        let r_max = r_strength.iter().cloned().fold(0.0f32, f32::max);
        let r_p95 = percentile_95(&r_strength);
        let r_scalar_raw = match self.params.roughness_scalar_mode {
            RoughnessScalarMode::Total => r_total,
            RoughnessScalarMode::Max => r_max,
            RoughnessScalarMode::P95 => r_p95,
        };
        let r_norm = r_scalar_raw / (loudness_mass + eps);

        // Roughness shape (level-invariant).
        let (p_density, mass) = normalize_density(density, &du, eps);
        let (r_shape_raw, r_shape_total) = if mass > eps {
            self.params
                .roughness_kernel
                .potential_r_from_log2_spectrum(&p_density, space)
        } else {
            (vec![0.0; r_strength.len()], 0.0)
        };

        let r_ref_peak = self.roughness_ref_peak.max(eps);
        let r_ref_total = self.roughness_ref_total.max(eps);
        let r01 = r_shape_raw
            .iter()
            .map(|&ri| roughness_ratio_to_state01(ri / r_ref_peak, roughness_k))
            .collect::<Vec<f32>>();
        let r01_scalar = roughness_ratio_to_state01(r_shape_total / r_ref_total, roughness_k);

        self.last_landscape.roughness = r_strength;
        self.last_landscape.roughness_shape_raw = r_shape_raw;
        self.last_landscape.roughness01 = r01;
        self.last_landscape.roughness_total = r_total;
        self.last_landscape.roughness_max = r_max;
        self.last_landscape.roughness_p95 = r_p95;
        self.last_landscape.roughness_scalar_raw = r_scalar_raw;
        self.last_landscape.roughness_norm = r_norm;
        self.last_landscape.roughness01_scalar = r01_scalar;
        self.last_landscape.loudness_mass = loudness_mass;
        self.last_landscape.subjective_intensity = density.to_vec();
    }

    pub fn reset(&mut self) {
        self.nsgt_rt.reset();
        self.spectral_frontend.reset();
        self.last_landscape = Landscape::new(self.nsgt_rt.space().clone());
    }

    pub fn apply_update(&mut self, upd: LandscapeUpdate) {
        if let Some(k) = upd.roughness_k {
            self.params.roughness_k = k.max(1e-6);
        }
    }
}

fn percentile_95(vals: &[f32]) -> f32 {
    if vals.is_empty() {
        return 0.0;
    }
    let mut buf = vals.to_vec();
    let idx = ((buf.len() - 1) as f32 * 0.95).round() as usize;
    let (_, v, _) = buf.select_nth_unstable_by(idx, |a, b| {
        a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal)
    });
    *v
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::harmonicity_kernel::{HarmonicityKernel, HarmonicityParams};
    use crate::core::landscape::{LandscapeParams, RoughnessScalarMode};
    use crate::core::log2space::Log2Space;
    use crate::core::psycho_state::build_roughness_reference_density;
    use crate::core::roughness_kernel::{KernelParams, RoughnessKernel};

    fn build_params(space: &Log2Space) -> LandscapeParams {
        LandscapeParams {
            fs: 48_000.0,
            max_hist_cols: 1,
            alpha: 0.0,
            roughness_kernel: RoughnessKernel::new(KernelParams::default(), 0.005),
            harmonicity_kernel: HarmonicityKernel::new(space, HarmonicityParams::default()),
            roughness_scalar_mode: RoughnessScalarMode::Total,
            roughness_half: 0.1,
            consonance_roughness_weight: 0.5,
            loudness_exp: 1.0,
            ref_power: 1.0,
            tau_ms: 1.0,
            roughness_k: 1.0,
            roughness_ref_f0_hz: 1000.0,
            roughness_ref_sep_erb: 0.25,
            roughness_ref_mass_split: 0.5,
            roughness_ref_eps: 1e-12,
        }
    }

    #[test]
    fn roughness_shape_invariant_to_level() {
        let space = Log2Space::new(80.0, 8000.0, 96);
        let params = build_params(&space);
        let (_erb, du) = erb_grid(&space);

        let mut density = vec![0.0f32; space.n_bins()];
        let mid = density.len() / 2;
        density[mid] = 0.8;
        if mid + 8 < density.len() {
            density[mid + 8] = 0.5;
        }

        let (p1, _) = normalize_density(&density, &du, params.roughness_ref_eps);
        let (r1, _) = params
            .roughness_kernel
            .potential_r_from_log2_spectrum(&p1, &space);

        let scaled: Vec<f32> = density.iter().map(|&v| v * 5.0).collect();
        let (p2, _) = normalize_density(&scaled, &du, params.roughness_ref_eps);
        let (r2, _) = params
            .roughness_kernel
            .potential_r_from_log2_spectrum(&p2, &space);

        for (a, b) in r1.iter().zip(r2.iter()) {
            assert!((a - b).abs() < 1e-6, "shape changed: {a} vs {b}");
        }
    }

    #[test]
    fn reference_maps_to_expected() {
        let space = Log2Space::new(80.0, 8000.0, 96);
        let params = build_params(&space);
        let ref_density = build_roughness_reference_density(&params, &space);
        let (r_shape, r_total) = params
            .roughness_kernel
            .potential_r_from_log2_spectrum_density(&ref_density, &space);
        let ref_vals = compute_roughness_reference(&params, &space);

        let peak = r_shape.iter().copied().fold(0.0f32, f32::max);
        let r01_peak = roughness_ratio_to_state01(peak / ref_vals.peak, params.roughness_k);
        let r01_scalar = roughness_ratio_to_state01(r_total / ref_vals.total, params.roughness_k);
        let expected = 1.0 / (1.0 + params.roughness_k.max(1e-6));

        assert!((r01_scalar - expected).abs() < 1e-5, "scalar {r01_scalar}");
        assert!((r01_peak - expected).abs() < 1e-5, "peak {r01_peak}");
    }

    #[test]
    fn roughness_ratio_handles_nan_and_inf() {
        let k = 0.3;
        assert_eq!(roughness_ratio_to_state01(f32::NAN, k), 0.0);
        assert_eq!(roughness_ratio_to_state01(f32::INFINITY, k), 1.0);
        assert_eq!(roughness_ratio_to_state01(f32::NEG_INFINITY, k), 0.0);
    }

    #[test]
    fn single_peak_has_zero_self_roughness() {
        let space = Log2Space::new(80.0, 8000.0, 96);
        let params = build_params(&space);
        let (_erb, du) = erb_grid(&space);

        let mut density = vec![0.0f32; space.n_bins()];
        let mid = density.len() / 2;
        density[mid] = 1.0;

        let (p_density, _) = normalize_density(&density, &du, params.roughness_ref_eps);
        let (r_shape, _r_total) = params
            .roughness_kernel
            .potential_r_from_log2_spectrum(&p_density, &space);

        assert!(r_shape[mid].abs() < 1e-6, "self roughness {}", r_shape[mid]);
    }
}
</file>

<file path="src/core/erb.rs">
//! core/erb.rs — ERB scale utilities and ErbSpace definition.

use std::f32::consts::LN_10;

/// Converts frequency [Hz] to ERB-rate value.
#[inline]
pub fn hz_to_erb(f_hz: f32) -> f32 {
    // 21.4 * log10(4.37e-3 * f + 1)
    21.4 * ((4.37e-3 * f_hz + 1.0).ln() / LN_10)
}

/// Converts ERB-rate value to frequency [Hz].
#[inline]
pub fn erb_to_hz(e: f32) -> f32 {
    // (10^(e/21.4) - 1) / 4.37e-3
    (((e / 21.4) * LN_10).exp() - 1.0) / 4.37e-3
}

/// Returns ERB bandwidth in Hz (Glasberg & Moore 1990)
#[inline]
pub fn erb_bw_hz(f_hz: f32) -> f32 {
    24.7 * (4.37e-3 * f_hz + 1.0)
}

/// Represents a frequency axis linearly spaced in ERB domain.
#[derive(Clone, Debug)]
pub struct ErbSpace {
    pub f_min: f32,
    pub f_max: f32,
    pub erb_step: f32,
    pub erb_min: f32,
    pub erb_max: f32,
    pub freqs_hz: Vec<f32>,
}

impl ErbSpace {
    /// Create a new ERB-space axis.
    ///
    /// # Arguments
    /// * `f_min` - lowest frequency [Hz]
    /// * `f_max` - highest frequency [Hz]
    /// * `erb_step` - ERB step (smaller → denser sampling)
    pub fn new(f_min: f32, f_max: f32, erb_step: f32) -> Self {
        let erb_min = hz_to_erb(f_min);
        let erb_max = hz_to_erb(f_max);

        let n_points = ((erb_max - erb_min) / erb_step).floor() as usize + 1;

        let mut freqs_hz = Vec::with_capacity(n_points);
        for i in 0..n_points {
            let e = erb_min + i as f32 * erb_step;
            freqs_hz.push(erb_to_hz(e));
        }

        Self {
            f_min,
            f_max,
            erb_step,
            erb_min,
            erb_max,
            freqs_hz,
        }
    }

    /// Convert frequency [Hz] to ERB coordinate.
    #[inline]
    pub fn to_erb(&self, f_hz: f32) -> f32 {
        hz_to_erb(f_hz)
    }

    /// Convert ERB coordinate to frequency [Hz].
    #[inline]
    pub fn to_hz(&self, e: f32) -> f32 {
        erb_to_hz(e)
    }

    /// Return number of ERB bins.
    #[inline]
    pub fn len(&self) -> usize {
        self.freqs_hz.len()
    }

    /// Returns true if there are no ERB bins.
    #[inline]
    pub fn is_empty(&self) -> bool {
        self.freqs_hz.is_empty()
    }

    /// Return reference to frequency vector [Hz].
    #[inline]
    pub fn freqs_hz(&self) -> &[f32] {
        &self.freqs_hz
    }

    pub fn index_of_freq(&self, f_hz: f32) -> usize {
        self.freqs_hz
            .iter()
            .position(|&f| f >= f_hz)
            .unwrap_or(self.freqs_hz.len() - 1)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Round-trip test of hz_to_erb ↔ erb_to_hz conversions.
    #[test]
    fn test_erb_conversion_roundtrip() {
        // Check round-trip accuracy at multiple points.
        for f in [20.0, 100.0, 1000.0, 4000.0, 8000.0, 16000.0] {
            let e = hz_to_erb(f);
            let f2 = erb_to_hz(e);
            let rel_err = (f - f2).abs() / f;
            assert!(
                rel_err < 1e-4,
                "roundtrip mismatch: f={f}, f2={f2}, rel_err={rel_err}"
            );
        }
    }

    /// Check monotonicity and range of ErbSpace.
    #[test]
    fn test_erbspace_creation() {
        let space = ErbSpace::new(50.0, 8000.0, 0.5);
        // Even with a coarse ERB step there should be ample bins.
        assert!(
            space.freqs_hz.len() > 10,
            "too few bins: {}",
            space.freqs_hz.len()
        );
        assert!(space.freqs_hz[0] >= 50.0);
        assert!(
            *space.freqs_hz.last().unwrap() <= 8000.0 + 1e-3 * 8000.0,
            "max freq exceeded"
        );

        // Frequency axis must be strictly increasing.
        let diffs: Vec<f32> = space.freqs_hz.windows(2).map(|w| w[1] - w[0]).collect();
        assert!(diffs.iter().all(|&d| d > 0.0), "non-monotonic freqs");
    }

    /// Validate that hz_to_erb is monotonic and increasing.
    #[test]
    fn test_hz_to_erb_monotonic() {
        let f: Vec<f32> = (1..20).map(|i| i as f32 * 500.0).collect();
        let e: Vec<f32> = f.iter().map(|&x| hz_to_erb(x)).collect();
        assert!(
            e.windows(2).all(|w| w[1] > w[0]),
            "hz_to_erb not strictly increasing"
        );
    }

    /// Verify erb_bw_hz matches Glasberg & Moore expected scaling.
    #[test]
    fn test_erb_bw_reference_values() {
        let bw_1k = erb_bw_hz(1000.0);
        let bw_4k = erb_bw_hz(4000.0);
        // Matches known reference values around 132.6 Hz and 456.4 Hz.
        assert!((bw_1k - 132.6).abs() < 1.0, "bw(1kHz) mismatch: {bw_1k}");
        assert!((bw_4k - 456.4).abs() < 1.0, "bw(4kHz) mismatch: {bw_4k}");
        assert!(bw_4k > bw_1k);
    }

    /// Extreme range test (very wide band)
    #[test]
    fn test_erbspace_extreme_range() {
        let space = ErbSpace::new(20.0, 20000.0, 0.25);
        let n = space.len();
        assert!(n > 100, "unexpectedly few bins for wide band: {n}");
        // Ensure ERB min/max are consistent.
        let e_min = hz_to_erb(20.0);
        let e_max = hz_to_erb(20000.0);
        assert!(
            (space.erb_min - e_min).abs() < 1e-4 && (space.erb_max - e_max).abs() < 1e-4,
            "erb range mismatch: min {} vs {}, max {} vs {}",
            space.erb_min,
            e_min,
            space.erb_max,
            e_max
        );
    }

    #[test]
    fn delta_erb_mapping_matches_exact() {
        use super::*;
        // Check several frequency deltas near 1 kHz.
        let fi = 1000.0f32;
        let steps_hz = [
            -300.0, -150.0, -75.0, -30.0, -15.0, 0.0, 15.0, 30.0, 75.0, 150.0, 300.0,
        ];

        for df_hz in steps_hz {
            let fj = (fi + df_hz).max(1.0);
            let d_exact = hz_to_erb(fj) - hz_to_erb(fi);
            let bw_mid = erb_bw_hz(0.5 * (fi + fj));
            let d_approx = (fj - fi) / bw_mid;

            // Relative error within 3% is OK.
            let denom = d_exact.abs().max(1e-6);
            let rel_err = (d_exact - d_approx).abs() / denom;
            assert!(
                rel_err < 0.03,
                "ΔERB approx mismatch at df={df_hz}: exact={d_exact}, approx={d_approx}, rel_err={rel_err}"
            );
        }
    }
}
</file>

<file path="src/core/harmonic_ratios.rs">
pub const HARMONIC_RATIOS: &[(u16, u16)] = &[
    (1, 1),
    (2, 1),
    (3, 2),
    (4, 3),
    (5, 4),
    (6, 5),
    (5, 3),
    (8, 5),
];

#[inline]
pub fn ratio_to_f32((n, d): (u16, u16)) -> f32 {
    n as f32 / d as f32
}

pub fn fold_to_octave_near(freq: f32, base: f32, lo: f32, hi: f32) -> f32 {
    if !freq.is_finite() || !base.is_finite() || base <= 0.0 {
        return freq;
    }
    let mut f = freq;
    let lo = lo.max(1e-6);
    let hi = hi.max(lo);
    for _ in 0..64 {
        if f >= lo {
            break;
        }
        f *= 2.0;
    }
    for _ in 0..64 {
        if f <= hi {
            break;
        }
        f *= 0.5;
    }
    debug_assert!(f >= lo && f <= hi, "folded freq out of range");
    f
}
</file>

<file path="src/core/nsgt_rt.rs">
//! core/nsgt_rt.rs — Real-time NSGT with per-hop exponential smoothing
//!
//! Design
//! -----
//! - 1 hop = 1 FFT update. A ring buffer (length = nfft) holds the latest samples.
//! - Uses NsgtKernelLog2’s sparse frequency-domain kernels (no per-hop heap alloc).
//! - Per-band exponential integrator: y[n] = (1−α)x[n] + α y[n−1], α = exp(−dt/τ(f)).
//! - τ(f) is mapped low→slow, high→fast via simple f-dependent rule.
//!
//! Notes
//! -----
//! - Instantaneous measure is raw power (coherent or incoherent, fixed at kernel creation).
//! - `process_hop()` accepts ≤ hop samples (short reads are zero-padded) or
//!   > hop (multiple hops processed); returns the last envelope slice.
//! - No per-hop allocations; FFT and scratch buffers are reused.

use crate::core::log2space::Log2Space;
use crate::core::nsgt_kernel::{NsgtKernelLog2, PowerMode};
use rustfft::{FftPlanner, num_complex::Complex32};
use std::sync::Arc;

/// Smoothing configuration.
#[derive(Clone, Copy, Debug)]
pub struct RtConfig {
    /// τ at high frequencies [s].
    pub tau_min: f32,
    /// τ at low frequencies [s].
    pub tau_max: f32,
    /// Reference frequency for mapping τ(f) [Hz].
    pub f_ref: f32,
}

impl Default for RtConfig {
    fn default() -> Self {
        Self {
            tau_min: 0.005,
            tau_max: 0.020,
            f_ref: 200.0,
        }
    }
}

/// Per-band persistent state.
#[derive(Clone, Debug)]
pub struct BandState {
    /// Center frequency [Hz].
    pub f_hz: f32,
    /// Time constant [s].
    pub tau: f32,
    /// α = exp(−dt/τ).
    pub alpha: f32,
    /// ENBW [Hz] (Hann ≈ 1.5*fs/Lk).
    pub enbw_hz: f32,
    /// Smoothed band power (running state).
    pub smooth: f32,
}

/// Real-time kernel analyzer with per-hop update and leaky integration.
#[derive(Clone)]
pub struct RtNsgtKernelLog2 {
    // analysis core
    nsgt: NsgtKernelLog2,
    fs: f32,
    nfft: usize,
    hop: usize,
    dt: f32,

    // runtime buffers (no per-hop alloc)
    ring: Vec<f32>,
    write_pos: usize, // next position to write
    fft: Arc<dyn rustfft::Fft<f32>>,
    fft_buf: Vec<Complex32>,

    // per-band states & cached meta
    bands_state: Vec<BandState>,
    out_env: Vec<f32>,

    // settings
    power_mode: PowerMode,
}

impl RtNsgtKernelLog2 {
    /// Construct with default RtConfig.
    pub fn new(nsgt: NsgtKernelLog2) -> Self {
        Self::with_config(nsgt, RtConfig::default())
    }

    /// Construct with explicit RtConfig.
    pub fn with_config(nsgt: NsgtKernelLog2, cfg: RtConfig) -> Self {
        let fs = nsgt.cfg.fs;
        let nfft = nsgt.nfft();
        let hop = nsgt.hop();
        let dt = hop as f32 / fs;
        let power_mode = nsgt.power_mode;

        // Our own FFT plan (no per-hop allocation; same size as nsgt).
        let mut planner = FftPlanner::<f32>::new();
        let fft = planner.plan_fft_forward(nfft);

        // Build band states (τ mapping and ENBW precompute).
        let bands_state = nsgt
            .bands()
            .iter()
            .map(|b| {
                let f = b.f_hz.max(1e-6); // guard for f=0
                let ratio = (cfg.f_ref / f).clamp(0.0, 1.0);
                let mut tau = cfg.tau_min + (cfg.tau_max - cfg.tau_min) * ratio;
                tau = tau.clamp(cfg.tau_min, cfg.tau_max);
                let alpha = (-dt / tau).exp();
                let enbw_hz = 1.5_f32 * fs / (b.win_len as f32);
                BandState {
                    f_hz: b.f_hz,
                    tau,
                    alpha,
                    enbw_hz,
                    smooth: 0.0,
                }
            })
            .collect::<Vec<_>>();

        Self {
            nsgt,
            fs,
            nfft,
            hop,
            dt,
            ring: vec![0.0; nfft],
            write_pos: 0,
            fft,
            fft_buf: vec![Complex32::new(0.0, 0.0); nfft],
            out_env: vec![0.0; bands_state.len()],
            bands_state,
            power_mode,
        }
    }

    /// Push one hop of audio and return the smoothed band power/PSD slice.
    ///
    /// - If `hop_in.len() == hop()`: normal per-hop update.
    /// - If shorter: zero-padded and still one update.
    /// - If longer: processes multiple hops internally; returns the last envelope.
    pub fn process_hop(&mut self, hop_in: &[f32]) -> &[f32] {
        if hop_in.len() <= self.hop {
            self.write_hop_zero_padded(hop_in);
            self.analyze_one_and_update();
            &self.out_env
        } else {
            // Process multiple hops
            let mut i = 0usize;
            while i + self.hop <= hop_in.len() {
                self.write_hop(&hop_in[i..i + self.hop]);
                self.analyze_one_and_update();
                i += self.hop;
            }
            if i < hop_in.len() {
                self.write_hop_zero_padded(&hop_in[i..]);
                self.analyze_one_and_update();
            }
            &self.out_env
        }
    }

    /// Process an arbitrary block and emit per-hop band power/PSD slices via callback.
    pub fn process_block_emit<F: FnMut(&[f32])>(&mut self, block: &[f32], mut emit: F) {
        let mut i = 0usize;
        while i + self.hop <= block.len() {
            self.write_hop(&block[i..i + self.hop]);
            self.analyze_one_and_update();
            emit(&self.out_env);
            i += self.hop;
        }
        if i < block.len() {
            self.write_hop_zero_padded(&block[i..]);
            self.analyze_one_and_update();
            emit(&self.out_env);
        }
    }

    /// Current smoothed band power/PSD without processing new samples.
    #[inline]
    pub fn current_envelope(&self) -> &[f32] {
        &self.out_env
    }

    /// Accessors
    #[inline]
    pub fn hop(&self) -> usize {
        self.hop
    }
    #[inline]
    pub fn dt(&self) -> f32 {
        self.dt
    }
    #[inline]
    pub fn fs(&self) -> f32 {
        self.fs
    }
    #[inline]
    pub fn nfft(&self) -> usize {
        self.nfft
    }
    /// Center frequencies [Hz].
    pub fn freqs(&self) -> Vec<f32> {
        self.nsgt.bands().iter().map(|b| b.f_hz).collect()
    }
    /// Underlying log2 space.
    #[inline]
    pub fn space(&self) -> &Log2Space {
        self.nsgt.space()
    }

    /// Reconfigure τ mapping and recompute α (no allocation).
    pub fn reconfigure_smoothing(&mut self, tau_min: f32, tau_max: f32, f_ref: f32) {
        let tau_min = tau_min.max(1e-6);
        let tau_max = tau_max.max(tau_min);
        for (b, state) in self.nsgt.bands().iter().zip(self.bands_state.iter_mut()) {
            let f = b.f_hz.max(1e-6);
            let ratio = (f_ref / f).clamp(0.0, 1.0);
            let mut tau = tau_min + (tau_max - tau_min) * ratio;
            tau = tau.clamp(tau_min, tau_max);
            state.tau = tau;
            state.alpha = (-self.dt / tau).exp();
        }
    }

    /// Reset smoothing states and ring buffer.
    pub fn reset(&mut self) {
        for state in &mut self.bands_state {
            state.smooth = 0.0;
        }
        for x in &mut self.ring {
            *x = 0.0;
        }
        self.write_pos = 0;
        for z in &mut self.fft_buf {
            *z = Complex32::new(0.0, 0.0);
        }
        for y in &mut self.out_env {
            *y = 0.0;
        }
    }

    // ---- internal helpers ----

    #[inline]
    fn write_hop(&mut self, hop_in: &[f32]) {
        debug_assert_eq!(hop_in.len(), self.hop);
        let n = self.nfft;
        let mut wp = self.write_pos;
        // write hop samples into the ring
        for &s in hop_in {
            self.ring[wp] = s;
            wp += 1;
            if wp == n {
                wp = 0;
            }
        }
        self.write_pos = wp;
    }

    #[inline]
    fn write_hop_zero_padded(&mut self, hop_in: &[f32]) {
        let n = self.nfft;
        let mut wp = self.write_pos;
        let mut i = 0usize;
        // copy provided samples
        while i < hop_in.len() {
            self.ring[wp] = hop_in[i];
            wp += 1;
            if wp == n {
                wp = 0;
            }
            i += 1;
        }
        // zero-pad the remainder
        while i < self.hop {
            self.ring[wp] = 0.0;
            wp += 1;
            if wp == n {
                wp = 0;
            }
            i += 1;
        }
        self.write_pos = wp;
    }

    /// Build contiguous FFT frame from ring, run FFT, accumulate bands, and update smoothing.
    fn analyze_one_and_update(&mut self) {
        // Reassemble latest nfft samples: [write_pos..end) then [0..write_pos)
        let n = self.nfft;
        let left = n - self.write_pos;

        // Fill fft_buf with real input (imag=0), then FFT.
        for i in 0..left {
            let s = self.ring[self.write_pos + i];
            self.fft_buf[i] = Complex32::new(s, 0.0);
        }
        for i in 0..self.write_pos {
            let s = self.ring[i];
            self.fft_buf[left + i] = Complex32::new(s, 0.0);
        }

        self.fft.process(&mut self.fft_buf);

        // Sparse inner products (same math as NsgtKernelLog2::analyze)
        let bands = self.nsgt.bands();
        let inv_nfft = 1.0 / n as f32;
        let inv_nfft2 = inv_nfft * inv_nfft;
        for (bi, band) in bands.iter().enumerate() {
            // Instantaneous measure (power mode fixed at kernel creation time)
            let p = match self.power_mode {
                PowerMode::Coherent => {
                    let sparse = band
                        .spec_conj_sparse
                        .as_ref()
                        .expect("coherent kernel required for RT");
                    let mut acc = Complex32::new(0.0, 0.0);
                    // Σ X[k] * conj(K_k[k]) (already conj in spec_conj_sparse)
                    for &(k, w) in sparse {
                        // Safety: kernels are built for the same nfft.
                        debug_assert!(k < self.fft_buf.len());
                        acc += self.fft_buf[k] * w;
                    }
                    acc *= inv_nfft;
                    acc.norm_sqr()
                }
                PowerMode::Incoherent => {
                    let sparse = band
                        .spec_pow_sparse
                        .as_ref()
                        .expect("incoherent kernel required for RT");
                    let mut sum = 0.0f32;
                    for &(k, w_pow) in sparse {
                        debug_assert!(k < self.fft_buf.len());
                        sum += self.fft_buf[k].norm_sqr() * w_pow;
                    }
                    sum * inv_nfft2
                }
            };

            // Exponential smoothing
            let state = &mut self.bands_state[bi];
            state.smooth = (1.0 - state.alpha) * p + state.alpha * state.smooth;
            self.out_env[bi] = state.smooth;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::log2space::Log2Space;
    use crate::core::nsgt_kernel::NsgtLog2Config;
    use core::f32::consts::PI;

    fn mk_sine(len: usize, f_hz: f32, fs: f32, amp: f32) -> Vec<f32> {
        let w = 2.0 * PI * f_hz / fs;
        (0..len).map(|i| amp * (w * i as f32).cos()).collect()
    }

    fn mk_two_sine(len: usize, f1_hz: f32, f2_hz: f32, fs: f32, amp: f32) -> Vec<f32> {
        let w1 = 2.0 * PI * f1_hz / fs;
        let w2 = 2.0 * PI * f2_hz / fs;
        (0..len)
            .map(|i| {
                let t = i as f32;
                amp * (w1 * t).cos() + amp * (w2 * t).cos()
            })
            .collect()
    }

    fn std_dev(data: &[f32]) -> f32 {
        if data.is_empty() {
            return 0.0;
        }
        let mean = data.iter().sum::<f32>() / data.len() as f32;
        let mut var = 0.0f32;
        for &v in data {
            let d = v - mean;
            var += d * d;
        }
        (var / data.len() as f32).sqrt()
    }

    #[test]
    fn rt_raw_power_scales_quadratically() {
        let fs = 48_000.0;
        let space = Log2Space::new(200.0, 4000.0, 12);
        let nsgt = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                nfft_override: Some(256),
                ..Default::default()
            },
            space,
            None,
            PowerMode::Coherent,
        );
        let cfg = RtConfig {
            tau_min: 1e-6,
            tau_max: 1e-6,
            f_ref: 200.0,
        };

        let mut rt = RtNsgtKernelLog2::with_config(nsgt.clone(), cfg);
        let f = rt.freqs()[rt.freqs().len() / 2];
        let len = rt.nfft() * 4;
        let sig1 = mk_sine(len, f, fs, 1.0);
        let sig2 = mk_sine(len, f, fs, 2.0);

        let mut env1 = Vec::new();
        rt.process_block_emit(&sig1, |env| env1 = env.to_vec());

        let mut rt2 = RtNsgtKernelLog2::with_config(nsgt, cfg);
        let mut env2 = Vec::new();
        rt2.process_block_emit(&sig2, |env| env2 = env.to_vec());

        let (imax, p1) = env1
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .unwrap();
        assert!(*p1 > 1e-6, "unexpected near-zero band power");
        let ratio = env2[imax] / *p1;
        assert!(
            (ratio - 4.0).abs() < 0.1,
            "expected ~4x power scaling, got {ratio:.3}"
        );
    }

    #[test]
    fn rt_incoherent_power_reduces_beating_variance() {
        let fs = 48_000.0;
        let space = Log2Space::new(200.0, 4000.0, 12);
        let nsgt_coh = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                nfft_override: Some(512),
                ..Default::default()
            },
            space.clone(),
            None,
            PowerMode::Coherent,
        );
        let nsgt_incoh = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                nfft_override: Some(512),
                ..Default::default()
            },
            space,
            None,
            PowerMode::Incoherent,
        );
        let cfg = RtConfig {
            tau_min: 1e-6,
            tau_max: 1e-6,
            f_ref: 200.0,
        };
        let f1 = 1000.0;
        let f2 = 1007.0;
        let len = nsgt_coh.nfft() * 16;
        let sig = mk_two_sine(len, f1, f2, fs, 0.5);

        let mut rt_coh = RtNsgtKernelLog2::with_config(nsgt_coh, cfg);
        let mut rt_incoh = RtNsgtKernelLog2::with_config(nsgt_incoh, cfg);

        let band_idx = rt_coh
            .freqs()
            .iter()
            .enumerate()
            .min_by(|a, b| (a.1 - f1).abs().partial_cmp(&(b.1 - f1).abs()).unwrap())
            .map(|(i, _)| i)
            .unwrap_or(0);

        let mut series_coh = Vec::new();
        rt_coh.process_block_emit(&sig, |env| series_coh.push(env[band_idx]));
        let mut series_incoh = Vec::new();
        rt_incoh.process_block_emit(&sig, |env| series_incoh.push(env[band_idx]));

        let std_coh = std_dev(&series_coh);
        let std_incoh = std_dev(&series_incoh);
        assert!(
            std_incoh < std_coh * 0.8,
            "expected incoherent variance to drop: std_incoh={std_incoh:.6} std_coh={std_coh:.6}"
        );
    }

    #[test]
    fn rt_incoherent_power_scales_quadratically() {
        let fs = 48_000.0;
        let space = Log2Space::new(200.0, 4000.0, 12);
        let nsgt = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                nfft_override: Some(256),
                ..Default::default()
            },
            space,
            None,
            PowerMode::Incoherent,
        );
        let cfg = RtConfig {
            tau_min: 1e-6,
            tau_max: 1e-6,
            f_ref: 200.0,
        };

        let mut rt = RtNsgtKernelLog2::with_config(nsgt.clone(), cfg);
        let f = rt.freqs()[rt.freqs().len() / 2];
        let len = rt.nfft() * 4;
        let sig1 = mk_sine(len, f, fs, 1.0);
        let sig2 = mk_sine(len, f, fs, 2.0);

        let mut env1 = Vec::new();
        rt.process_block_emit(&sig1, |env| env1 = env.to_vec());

        let mut rt2 = RtNsgtKernelLog2::with_config(nsgt, cfg);
        let mut env2 = Vec::new();
        rt2.process_block_emit(&sig2, |env| env2 = env.to_vec());

        let (imax, p1) = env1
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .unwrap();
        assert!(*p1 > 1e-6, "unexpected near-zero band power");
        let ratio = env2[imax] / *p1;
        assert!(
            (ratio - 4.0).abs() < 0.1,
            "expected ~4x power scaling, got {ratio:.3}"
        );
    }
}
</file>

<file path="src/core/roughness_kernel.rs">
//! core/roughness_kernel.rs — perc_potential_R via ERB-domain kernel convolution.
//! Computes frequency-space roughness potential by convolving the
//! envelope energy using an asymmetric kernel.
//! density: per-ERB power density; mass: sum(density * du) over ERB.

use crate::core::density;
use crate::core::erb::hz_to_erb;
use crate::core::fft::apply_hann_window_complex;
#[cfg(test)]
use crate::core::fft::hilbert;
use crate::core::log2space::Log2Space;
use crate::core::peak_extraction::Peak;
use rustfft::{FftPlanner, num_complex::Complex32};

// ======================================================================
// Kernel parameter definition (Plomp–Levelt inspired, ΔERB domain)
// ======================================================================

#[derive(Clone, Copy, Debug)]
pub struct KernelParams {
    // === Cochlear layer ===
    pub sigma_erb: f32,
    pub tau_erb: f32,
    pub mix_tail: f32,
    pub half_width_erb: f32,
    pub suppress_sigma_erb: f32,
    pub suppress_pow: f32,
    // === Neural layer ===
    pub sigma_neural_erb: f32,
    pub w_neural: f32,
}

impl Default for KernelParams {
    fn default() -> Self {
        Self {
            sigma_erb: 0.45,
            tau_erb: 1.0,
            mix_tail: 0.20,
            half_width_erb: 4.0,
            suppress_sigma_erb: 0.1,
            suppress_pow: 3.0,
            sigma_neural_erb: 1.0,
            w_neural: 0.0,
        }
    }
}

// ======================================================================
// Core kernel evaluation
// ======================================================================

#[inline]
pub fn eval_kernel_delta_erb(params: &KernelParams, d_erb: f32) -> f32 {
    let sigma = params.sigma_erb.max(1e-6);
    let tau = params.tau_erb.max(1e-6);
    let s_sup = params.suppress_sigma_erb.max(1e-6);
    let sig_n = params.sigma_neural_erb.max(1e-6);

    let desq = d_erb * d_erb;
    let g_gauss = (-desq / (2.0 * sigma * sigma)).exp();
    let g_tail = if d_erb >= 0.0 {
        (-d_erb / tau).exp()
    } else {
        0.0
    };
    let base = (1.0 - params.mix_tail) * g_gauss + params.mix_tail * g_tail;

    let suppress = (1.0 - (-desq / (2.0 * s_sup * s_sup)).exp()).clamp(0.0, 1.0);
    let g_coch = base * suppress.powf(params.suppress_pow);
    let g_neural = (-desq / (2.0 * sig_n * sig_n)).exp();
    (1.0 - params.w_neural) * g_coch + params.w_neural * g_neural
}

pub fn build_kernel_erbstep(params: &KernelParams, erb_step: f32) -> (Vec<f32>, usize) {
    let hw_erb = params.half_width_erb;
    let n_side = (hw_erb / erb_step).ceil() as usize;
    let len = 2 * n_side + 1;

    let mut g: Vec<f32> = (0..len)
        .map(|i| {
            let d = (i as i32 - n_side as i32) as f32 * erb_step;
            eval_kernel_delta_erb(params, d)
        })
        .collect();

    let sum = g.iter().sum::<f32>() * erb_step;
    if sum > 0.0 {
        let inv = 1.0 / sum;
        g.iter_mut().for_each(|v| *v *= inv);
    }
    (g, n_side)
}

#[inline]
fn lut_interp(lut: &[f32], step: f32, hw: usize, d_erb: f32) -> f32 {
    let t = d_erb / step + hw as f32;
    let i = t.floor();
    let i0 = i as isize;
    let i1 = i0 + 1;
    if i0 < 0 || (i1 as usize) >= lut.len() {
        return 0.0;
    }
    let frac = t - i;
    let a = lut[i0 as usize];
    let b = lut[i1 as usize];
    a + frac * (b - a)
}

fn local_du_from_grid(erb: &[f32]) -> Vec<f32> {
    let n = erb.len();
    let mut du = vec![0.0; n];
    if n == 0 {
        return du;
    }
    if n == 1 {
        return du;
    }
    du[0] = (erb[1] - erb[0]).max(0.0);
    du[n - 1] = (erb[n - 1] - erb[n - 2]).max(0.0);
    for i in 1..n - 1 {
        du[i] = 0.5 * (erb[i + 1] - erb[i - 1]).max(0.0);
    }
    du
}

pub(crate) fn erb_grid(space: &Log2Space) -> (Vec<f32>, Vec<f32>) {
    let erb: Vec<f32> = space.centers_hz.iter().map(|&f| hz_to_erb(f)).collect();
    let du = local_du_from_grid(&erb);
    (erb, du)
}

// ======================================================================
// Roughness kernel (holds LUT, no global cache)
// ======================================================================

#[derive(Clone, Debug)]
pub struct RoughnessKernel {
    pub params: KernelParams,
    pub erb_step: f32,
    pub lut: Vec<f32>,
    pub hw: usize,
}

impl RoughnessKernel {
    /// Create a new kernel and precompute LUT.
    pub fn new(params: KernelParams, erb_step: f32) -> Self {
        let (lut, hw) = build_kernel_erbstep(&params, erb_step);
        Self {
            params,
            erb_step,
            lut,
            hw,
        }
    }

    // ------------------------------------------------------------------
    // Potential R from amplitude spectrum (linear frequency axis)
    // ------------------------------------------------------------------

    pub fn potential_r_from_spectrum(&self, amps_hz: &[f32], fs: f32) -> (Vec<f32>, f32) {
        let n = amps_hz.len();
        if n == 0 {
            return (vec![], 0.0);
        }

        let nfft = 2 * n;
        let df = fs / nfft as f32;

        let f: Vec<f32> = (0..n).map(|i| i as f32 * df).collect();
        let erb: Vec<f32> = f.iter().map(|&x| hz_to_erb(x)).collect();
        let half_width = self.params.half_width_erb;
        let du = local_du_from_grid(&erb);

        let mut r = vec![0.0f32; n];
        for i in 0..n {
            let fi_erb = erb[i];
            let mut sum = 0.0f32;

            let j_lo = erb.partition_point(|&x| x < fi_erb - half_width);
            let j_hi = erb.partition_point(|&x| x <= fi_erb + half_width);
            for j in j_lo..j_hi {
                if j == i {
                    continue;
                }
                let d = erb[j] - fi_erb;
                if d.abs() > half_width {
                    continue;
                }
                let w = lut_interp(&self.lut, self.erb_step, self.hw, d);
                sum += amps_hz[j] * w * du[j];
            }
            r[i] = sum;
        }

        // Integrate over ERB axis
        let r_total = density::density_to_mass(&r, &du);

        (r, r_total)
    }

    // ------------------------------------------------------------------
    // Potential R from analytic (Hilbert) signal
    // ------------------------------------------------------------------

    pub fn potential_r_from_analytic(&self, analytic: &[Complex32], fs: f32) -> (Vec<f32>, f32) {
        if analytic.is_empty() {
            return (vec![], 0.0);
        }

        let n0 = analytic.len();
        let n = n0.next_power_of_two();
        let mut buf: Vec<Complex32> = Vec::with_capacity(n);
        buf.extend_from_slice(analytic);
        if n > n0 {
            buf.resize(n, Complex32::new(0.0, 0.0));
        }

        // Apply Hann window (complex)
        let window_gain = apply_hann_window_complex(&mut buf);

        // FFT
        let mut planner = FftPlanner::new();
        let fft = planner.plan_fft_forward(n);
        fft.process(&mut buf);

        // Convert to amplitude spectrum
        let n_half = n / 2;
        let df = fs / n as f32;
        let base_scale = 1.0 / (fs * n as f32 * window_gain);
        let amps: Vec<f32> = (0..n_half)
            .map(|i| (buf[i].norm_sqr() * base_scale * 2.0 * df).sqrt())
            .collect();

        self.potential_r_from_spectrum(&amps, fs)
    }

    /// Compute perc_potential_R roughness from log2-domain amplitude spectrum (NSGT).
    /// Input values are ERB power densities (mass per ERB), so the internal
    /// accumulation performs a du-weighted integral. This models the potential
    /// roughness increase from adding a unit pure tone.
    pub fn potential_r_from_log2_spectrum_density(
        &self,
        amps_density: &[f32],
        space: &Log2Space,
    ) -> (Vec<f32>, f32) {
        use crate::core::erb::erb_to_hz;

        if amps_density.is_empty() || space.centers_hz.is_empty() {
            return (vec![], 0.0);
        }
        assert_eq!(
            amps_density.len(),
            space.centers_hz.len(),
            "amps and space length mismatch"
        );

        let n = amps_density.len();

        // (1) Map to ERB axis
        let (erb, du) = erb_grid(space);

        // (2) Convolution over ERB axis
        let half_width_erb = self.params.half_width_erb;
        let mut r = vec![0.0f32; n];

        for i in 0..n {
            let fi_erb = erb[i];
            let mut sum = 0.0f32;

            let lo_hz = erb_to_hz(fi_erb - half_width_erb);
            let hi_hz = erb_to_hz(fi_erb + half_width_erb);
            let j_lo = space.index_of_freq(lo_hz).unwrap_or(0);
            let j_hi = space.index_of_freq(hi_hz).unwrap_or(n - 1);

            for j in j_lo..j_hi {
                if j == i {
                    continue;
                }
                let d = erb[j] - fi_erb;
                let w = lut_interp(&self.lut, self.erb_step, self.hw, d);
                sum += amps_density[j] * w * du[j];
            }
            r[i] = sum;
        }

        // (3) Integration over ERB axis
        let r_total = density::density_to_mass(&r, &du);

        (r, r_total)
    }

    /// Compatibility wrapper for ERB-density input.
    pub fn potential_r_from_log2_spectrum(
        &self,
        amps: &[f32],
        space: &Log2Space,
    ) -> (Vec<f32>, f32) {
        self.potential_r_from_log2_spectrum_density(amps, space)
    }

    /// Compute perc_potential_R roughness from delta peaks (pure-tone interactions).
    /// Each peak mass is the ERB-integrated area (sum of density * du).
    pub fn potential_r_from_peaks(&self, peaks: &[Peak], space: &Log2Space) -> Vec<f32> {
        if peaks.is_empty() || space.centers_hz.is_empty() {
            return vec![];
        }

        use crate::core::erb::erb_to_hz;

        let (erb, _du) = erb_grid(space);
        let half_width_erb = self.params.half_width_erb;
        let mut r = vec![0.0f32; erb.len()];

        for (i, &u_i) in erb.iter().enumerate() {
            let mut sum = 0.0f32;
            let lo_hz = erb_to_hz(u_i - half_width_erb);
            let hi_hz = erb_to_hz(u_i + half_width_erb);
            let j_lo = space.index_of_freq(lo_hz).unwrap_or(0);
            let j_hi = space.index_of_freq(hi_hz).unwrap_or(erb.len() - 1);
            for peak in peaks {
                if peak.bin_idx == i {
                    continue;
                }
                let d = peak.u_erb - u_i;
                if d.abs() > half_width_erb {
                    continue;
                }
                if peak.bin_idx < erb.len() && (peak.bin_idx < j_lo || peak.bin_idx >= j_hi) {
                    continue;
                }
                let w = lut_interp(&self.lut, self.erb_step, self.hw, d);
                sum += peak.mass * w;
            }
            r[i] = sum;
        }

        r
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::erb::{erb_bw_hz, hz_to_erb};
    use crate::core::peak_extraction::{PeakExtractConfig, extract_peaks_density};
    use plotters::prelude::*;
    use rand::{Rng, SeedableRng};
    use std::fs::File;
    use std::path::Path;

    const ERB_STEP: f32 = 0.005;

    fn make_kernel() -> RoughnessKernel {
        let p = KernelParams::default();
        RoughnessKernel::new(p, ERB_STEP)
    }

    // ------------------------------------------------------------
    // Basic kernel characteristics
    // ------------------------------------------------------------

    #[test]
    fn kernel_is_positive_and_centered() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        assert!(g.iter().all(|&v| v >= 0.0));
        assert_eq!(g.len(), 2 * hw + 1);
        let edge_mean = (g[0] + g[g.len() - 1]) * 0.5;

        let pos = (hw as f32 + 0.3 / ERB_STEP).round() as usize;
        let peak = g[pos].max(1e-12);
        assert!(
            edge_mean / peak < 5e-3,
            "edges should decay (edge/peak={})",
            edge_mean / peak
        );
    }

    #[test]
    fn kernel_center_is_suppressed() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        let center = g[hw];

        // Pick the representative nearby peak (~+0.3 ERB).
        let pos = (hw as f32 + 0.3 / ERB_STEP).round() as usize;
        let peak = g[pos];

        // Allow true suppression to zero when parameters enforce it.
        assert!(center >= 0.0, "center should be non-negative");
        // Suppressed means well below the peak (empirical ~15-30%).
        assert!(
            center < 0.5 * peak,
            "center suppression too weak: c/peak={}",
            center / peak
        );
    }

    #[test]
    fn kernel_has_peak_near_pm0p3_erb() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        let n = g.len();
        let d_erb: Vec<f32> = (0..n)
            .map(|i| (i as i32 - hw as i32) as f32 * ERB_STEP)
            .collect();

        let mut pos_peak = None;
        let mut neg_peak = None;
        for i in 1..n - 1 {
            if g[i] > g[i - 1] && g[i] > g[i + 1] {
                if d_erb[i] > 0.0 && pos_peak.is_none() {
                    pos_peak = Some((d_erb[i], g[i]));
                }
                if d_erb[i] < 0.0 && neg_peak.is_none() {
                    neg_peak = Some((d_erb[i], g[i]));
                }
            }
        }

        let (pos_x, pos_val) = pos_peak.expect("no positive-side peak");
        let (neg_x, _neg_val) = neg_peak.expect("no negative-side peak");
        assert!(
            pos_x > 0.2 && pos_x < 0.4,
            "positive peak near +0.3 ERB (got {:.2})",
            pos_x
        );
        assert!(
            neg_x < -0.2 && neg_x > -0.4,
            "negative peak near -0.3 ERB (got {:.2})",
            neg_x
        );
        assert!(pos_val > g[hw] * 1.5);
    }

    #[test]
    fn kernel_is_asymmetric() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        let pos = (hw as f32 + 0.3 / ERB_STEP).round() as usize;
        let neg = (hw as f32 - 0.3 / ERB_STEP).round() as usize;
        assert!(g[pos] > g[neg]);
    }

    #[test]
    fn kernel_l1_norm_is_one() {
        let k = make_kernel();
        let g = &k.lut;
        let sum: f32 = g.iter().sum();
        let sum_cont = sum * k.erb_step;
        assert!((sum_cont - 1.0).abs() < 1e-4, "L1 norm={}", sum_cont);
    }

    #[test]
    fn neural_layer_reduces_center_suppression() {
        let mut p1 = KernelParams::default();
        p1.w_neural = 0.0;
        let k1 = RoughnessKernel::new(p1, ERB_STEP);
        let c1 = k1.lut[k1.hw];

        let mut p2 = KernelParams::default();
        p2.w_neural = 0.4;
        let k2 = RoughnessKernel::new(p2, ERB_STEP);
        let c2 = k2.lut[k2.hw];

        assert!(c2 > c1);
    }

    #[test]
    fn kernel_stable_across_erbstep() {
        let p = KernelParams::default();
        let k1 = RoughnessKernel::new(p, ERB_STEP);
        let k2 = RoughnessKernel::new(p, 0.02);
        let g1 = &k1.lut;
        let g2 = &k2.lut;
        let hw1 = k1.hw;
        let hw2 = k2.hw;
        let peak1 = g1[(hw1 as f32 + 0.3 / ERB_STEP).round() as usize];
        let peak2 = g2[(hw2 as f32 + 0.3 / 0.02).round() as usize];
        let max1 = g1.iter().cloned().fold(0.0f32, f32::max).max(1e-12);
        let max2 = g2.iter().cloned().fold(0.0f32, f32::max).max(1e-12);
        let ratio1 = peak1 / max1;
        let ratio2 = peak2 / max2;
        assert!((ratio1 - ratio2).abs() < 0.15);
    }

    // ------------------------------------------------------------
    // δ-input and stability tests
    // ------------------------------------------------------------

    #[test]
    fn delta_input_reproduces_kernel_shape_when_du_constant() {
        let fs = 48_000.0;
        let nfft = 131072;
        let n = nfft / 2;
        let df = fs / nfft as f32;
        let f0 = 1000.0;
        let k0 = (f0 / df).round() as usize;

        let p = KernelParams::default();
        let k = RoughnessKernel::new(p, ERB_STEP);
        let g = &k.lut;
        let hw = k.hw;

        let mut e = vec![0.0f32; n];
        e[k0] = 1.0;

        let fi = k0 as f32 * df;
        let du_const = df / erb_bw_hz(fi).max(1e-12);

        let mut r = vec![0.0f32; n];
        for i in 0..n {
            if i == k0 {
                continue;
            }
            let fj = i as f32 * df;
            let d = hz_to_erb(fj) - hz_to_erb(fi);
            if d.abs() > p.half_width_erb {
                continue;
            }
            let w = eval_kernel_delta_erb(&p, d);
            r[i] = w * du_const;
        }

        let lo = k0.saturating_sub((p.half_width_erb / ERB_STEP).ceil() as usize);
        let hi = (k0 + (p.half_width_erb / ERB_STEP).ceil() as usize).min(n - 1);

        let mut r_on_erb = Vec::with_capacity(g.len());
        for kidx in 0..g.len() {
            let d_k = (kidx as i32 - hw as i32) as f32 * ERB_STEP;
            let f_target_erb = d_k + hz_to_erb(fi);
            let mut best_i = k0;
            let mut best_diff = f32::MAX;
            for i in lo..=hi {
                let fj = i as f32 * df;
                let erb_i = hz_to_erb(fj);
                let diff = (erb_i - f_target_erb).abs();
                if diff < best_diff {
                    best_diff = diff;
                    best_i = i;
                }
            }
            r_on_erb.push(r[best_i]);
        }

        let r_sum: f32 = r_on_erb.iter().sum();
        let mut g_adj = g.clone();
        g_adj[hw] = 0.0;
        let g_sum: f32 = g_adj.iter().sum();
        let r_norm: Vec<f32> = r_on_erb.iter().map(|&x| x / (r_sum + 1e-12)).collect();
        let g_norm: Vec<f32> = g_adj.iter().map(|&x| x / (g_sum + 1e-12)).collect();

        let mae: f32 = r_norm
            .iter()
            .zip(g_norm.iter())
            .map(|(a, b)| (a - b).abs())
            .sum::<f32>()
            / g_norm.len() as f32;
        assert!(mae < 1e-2, "MAE={}", mae);
    }

    #[test]
    fn delta_input_reproduces_kernel_shape() {
        let params = KernelParams::default();
        let k = RoughnessKernel::new(params, ERB_STEP);
        let space = Log2Space::new(20.0, 8000.0, 500);

        let mut amps = vec![0.0f32; space.centers_hz.len()];
        let mid = amps.len() / 2;
        amps[mid] = 1.0;

        let (r_vec, _) = k.potential_r_from_log2_spectrum(&amps, &space);

        let g_ref = &k.lut;
        let hw = k.hw;
        let _d_erb_kernel: Vec<f32> = (-(hw as i32)..=hw as i32)
            .map(|i| i as f32 * ERB_STEP)
            .collect();

        let f0_erb = hz_to_erb(space.centers_hz[mid]);
        let d_erb_vec: Vec<f32> = space
            .centers_hz
            .iter()
            .map(|&f| hz_to_erb(f) - f0_erb)
            .collect();

        let mut g_adj = g_ref.clone();
        g_adj[hw] = 0.0;
        let g_norm: Vec<f32> = g_adj
            .iter()
            .map(|&v| v / g_adj.iter().sum::<f32>())
            .collect();
        let r_norm: Vec<f32> = r_vec
            .iter()
            .map(|&v| v / r_vec.iter().sum::<f32>())
            .collect();

        let mut total_err = 0.0;
        let mut count = 0;
        for (de, rv) in d_erb_vec.iter().zip(r_norm.iter()) {
            if de.abs() < params.half_width_erb {
                let k_idx = ((de / ERB_STEP) + hw as f32).round() as isize;
                if k_idx >= 0 && (k_idx as usize) < g_norm.len() {
                    total_err += (rv - g_norm[k_idx as usize]).abs();
                    count += 1;
                }
            }
        }
        let mae = total_err / (count as f32).max(1.0);
        assert!(mae < 1e-3, "MAE too large: {:.4}", mae);
    }

    #[test]
    fn potential_r_peaks_matches_density_delta_input() {
        let k = make_kernel();
        let space = Log2Space::new(40.0, 8000.0, 256);
        let (erb, du) = erb_grid(&space);

        let mut rng = rand::rngs::StdRng::seed_from_u64(7);
        let mut peaks = Vec::new();
        let mut density = vec![0.0f32; erb.len()];
        let mut used = vec![false; erb.len()];

        for _ in 0..12 {
            let mut idx = rng.random_range(0..erb.len());
            while used[idx] {
                idx = rng.random_range(0..erb.len());
            }
            used[idx] = true;
            let mass = rng.random_range(0.1f32..2.0f32);
            if du[idx] > 0.0 {
                density[idx] += mass / du[idx];
            }
            peaks.push(Peak {
                u_erb: erb[idx],
                mass,
                bin_idx: idx,
            });
        }

        let (r_density, _) = k.potential_r_from_log2_spectrum_density(&density, &space);
        let r_peaks = k.potential_r_from_peaks(&peaks, &space);

        for i in 0..r_density.len() {
            let diff = (r_density[i] - r_peaks[i]).abs();
            assert!(diff < 1e-4, "bin {} diff {}", i, diff);
        }
    }

    #[test]
    fn peak_extraction_conserves_cluster_mass() {
        let space = Log2Space::new(80.0, 8000.0, 128);
        let (erb, du) = erb_grid(&space);
        let mut density = vec![0.0f32; erb.len()];

        let center = erb.len() / 2;
        let sigma = 2.0f32;
        for i in 0..erb.len() {
            let x = (i as f32 - center as f32) / sigma;
            density[i] = (-0.5 * x * x).exp();
        }

        let total_mass = density::density_to_mass(&density, &du);
        let cfg = PeakExtractConfig {
            max_peaks: None,
            min_rel_db_power: -120.0,
            min_abs_power_density: None,
            min_prominence_db_power: 0.0,
            min_rel_mass_db_power: -70.0,
            min_mass_fraction: None,
            min_sep_erb: 0.2,
        };
        let peaks = extract_peaks_density(&density, &space, &cfg);

        assert_eq!(peaks.len(), 1);
        let diff = (peaks[0].mass - total_mass).abs();
        assert!(diff < 1e-4, "mass diff {}", diff);
    }

    #[test]
    fn potential_r_stable_across_fs() {
        let p = KernelParams::default();
        let k = RoughnessKernel::new(p, ERB_STEP);
        let base = 1000.0;

        let fs1 = 48000.0;
        let n1 = 4096;
        let sig1: Vec<f32> = (0..n1)
            .map(|i| (2.0 * std::f32::consts::PI * base * i as f32 / fs1).sin())
            .collect();
        let (_r1, rtot1) = k.potential_r_from_analytic(&hilbert(&sig1), fs1);

        let fs2 = 96000.0;
        let n2 = 8192;
        let sig2: Vec<f32> = (0..n2)
            .map(|i| (2.0 * std::f32::consts::PI * base * i as f32 / fs2).sin())
            .collect();
        let (_r2, rtot2) = k.potential_r_from_analytic(&hilbert(&sig2), fs2);

        let rel_err = ((rtot2 - rtot1) / rtot1.abs()).abs();
        assert!(rel_err < 0.001, "R_total rel_err={rel_err}");
    }

    // ------------------------------------------------------------
    // Plot tests (unchanged, ignore for normal runs)
    // ------------------------------------------------------------

    #[test]
    #[ignore]
    fn plot_kernel_shape_png() {
        let k = make_kernel();
        let params = k.params;
        let erb_step = 0.02;
        let (g, _) = build_kernel_erbstep(&params, erb_step);
        let hw = (params.half_width_erb / erb_step).ceil() as i32;
        let d_erb: Vec<f32> = (-hw..=hw).map(|i| i as f32 * erb_step).collect();

        let out_path = Path::new("target/test_kernel_shape.png");
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let mut chart = ChartBuilder::on(&root)
            .caption("Asymmetric ERB-domain Kernel", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(
                d_erb[0]..d_erb[d_erb.len() - 1],
                0.0..g.iter().cloned().fold(0.0, f32::max) * 1.1,
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("Amplitude")
            .draw()
            .unwrap();
        chart
            .draw_series(LineSeries::new(
                d_erb.iter().zip(g.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))
            .unwrap();
        root.present().unwrap();
        assert!(File::open(out_path).is_ok());
    }

    #[test]
    #[ignore]
    fn compare_build_kernel_and_eval_kernel_shape() -> Result<(), Box<dyn std::error::Error>> {
        let params = KernelParams::default();
        let erb_step = 0.005;
        let k = RoughnessKernel::new(params, erb_step);
        let g_discrete = &k.lut;
        let hw = k.hw;

        let d_erb_vec: Vec<f32> = (-(hw as i32)..=hw as i32)
            .map(|i| i as f32 * erb_step)
            .collect();
        let g_eval: Vec<f32> = d_erb_vec
            .iter()
            .map(|&d| eval_kernel_delta_erb(&params, d))
            .collect();
        let sum1: f32 = g_discrete.iter().sum();
        let sum2: f32 = g_eval.iter().sum();
        let g1: Vec<f32> = g_discrete.iter().map(|&v| v / sum1).collect();
        let g2: Vec<f32> = g_eval.iter().map(|&v| v / sum2).collect();
        let mae = g1
            .iter()
            .zip(g2.iter())
            .map(|(a, b)| (a - b).abs())
            .sum::<f32>()
            / g1.len() as f32;
        assert!(mae < 1e-3, "MAE={}", mae);

        let out_path = "target/test_kernel_build_vs_eval.png";
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE)?;
        let mut chart = ChartBuilder::on(&root)
            .caption("build_kernel vs eval_kernel", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(
                -5.0f32..5.0f32,
                0.0f32..g1.iter().cloned().fold(0.0, f32::max) * 1.1,
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("Amplitude")
            .draw()?;
        chart
            .draw_series(LineSeries::new(
                d_erb_vec.iter().zip(g1.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))?
            .label("discrete")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &BLUE));
        chart
            .draw_series(LineSeries::new(
                d_erb_vec.iter().zip(g2.iter()).map(|(&x, &y)| (x, y)),
                &RED,
            ))?
            .label("eval()")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &RED));
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()?;
        root.present()?;
        Ok(())
    }

    #[test]
    #[ignore]
    fn plot_potential_r_from_signal_direct_erb() {
        let fs = 48000.0;
        let k = RoughnessKernel::new(KernelParams::default(), 0.005);
        let base = 440.0;
        let n = 16384;

        let mut sig1 = vec![0.0f32; n];
        for i in 0..n {
            let t = i as f32 / fs;
            sig1[i] = (2.0 * std::f32::consts::PI * base * t).sin();
        }
        let (r1, _) = k.potential_r_from_analytic(&hilbert(&sig1), fs);

        let mut sig2 = vec![0.0f32; n];
        let f2 = base * 1.2;
        for i in 0..n {
            let t = i as f32 / fs;
            sig2[i] = (2.0 * std::f32::consts::PI * base * t).sin()
                + (2.0 * std::f32::consts::PI * f2 * t).sin();
        }
        let (r2, _) = k.potential_r_from_analytic(&hilbert(&sig2), fs);

        let df = fs / n as f32;
        let f0_erb = hz_to_erb(base);
        let x_erb: Vec<f32> = (0..r1.len())
            .map(|i| hz_to_erb(i as f32 * df) - f0_erb)
            .collect();

        let out_path = "target/test_potential_r_signal_direct_erb.png";
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let mut chart = ChartBuilder::on(&root)
            .caption("Potential R from Signal (ΔERB axis)", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(
                -5.0f32..5.0f32,
                0.0f32..r2.iter().cloned().fold(0.0, f32::max) * 1.1,
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("R(f)")
            .draw()
            .unwrap();
        chart
            .draw_series(LineSeries::new(
                x_erb.iter().zip(r1.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))
            .unwrap()
            .label("pure tone");
        chart
            .draw_series(LineSeries::new(
                x_erb.iter().zip(r2.iter()).map(|(&x, &y)| (x, y)),
                &RED,
            ))
            .unwrap()
            .label("two-tone ΔERB≈0.3");
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()
            .unwrap();
        root.present().unwrap();
        assert!(File::open(out_path).is_ok());
    }

    #[test]
    #[ignore]
    fn plot_potential_r_from_log2_spectrum_delta_input() -> Result<(), Box<dyn std::error::Error>> {
        use crate::core::erb::hz_to_erb;
        use crate::core::log2space::Log2Space;
        use plotters::prelude::*;

        let k = RoughnessKernel::new(KernelParams::default(), 0.005);
        let space = Log2Space::new(20.0, 8000.0, 144);

        let mut amps = vec![0.0f32; space.centers_hz.len()];
        let mid = amps.len() / 2;
        amps[mid] = 1.0;

        let (r_vec, _) = k.potential_r_from_log2_spectrum(&amps, &space);

        let mid = amps.len() / 2;
        let _f0_erb = hz_to_erb(space.centers_hz[mid]);
        let erb_per_bin = hz_to_erb(space.centers_hz[mid + 1]) - hz_to_erb(space.centers_hz[mid]);
        let d_erb_r: Vec<f32> = (0..amps.len())
            .map(|i| (i as f32 - mid as f32) * erb_per_bin)
            .collect();

        let g_ref = &k.lut;
        let hw = k.hw;
        let d_erb_kernel: Vec<f32> = (-(hw as i32)..=hw as i32)
            .map(|i| i as f32 * k.erb_step)
            .collect();

        let r_norm: Vec<f32> = r_vec
            .iter()
            .map(|&v| v / r_vec.iter().cloned().fold(0.0, f32::max))
            .collect();
        let g_norm: Vec<f32> = g_ref
            .iter()
            .map(|&v| v / g_ref.iter().cloned().fold(0.0, f32::max))
            .collect();

        let out_path = "target/test_potential_r_from_log2_spectrum_delta.png";
        let root = BitMapBackend::new(out_path, (1500, 1000)).into_drawing_area();
        root.fill(&WHITE)?;

        let mut chart = ChartBuilder::on(&root)
            .caption(
                "Potential R from Log2 Spectrum (δ input)",
                ("sans-serif", 30),
            )
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(50)
            .build_cartesian_2d(-5.0f32..5.0f32, 0.0f32..1.05f32)
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("Normalized Amplitude")
            .draw()?;
        chart
            .draw_series(LineSeries::new(
                d_erb_r.iter().zip(r_norm.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))?
            .label("R(log2 input)")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &BLUE));
        chart
            .draw_series(LineSeries::new(
                d_erb_kernel
                    .iter()
                    .zip(g_norm.iter())
                    .map(|(&x, &y)| (-x, y)),
                &GREEN,
            ))?
            .label("Kernel g(ΔERB), flipped")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &GREEN));
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()?;
        root.present()?;
        assert!(std::path::Path::new(out_path).exists());
        Ok(())
    }

    #[test]
    #[ignore]
    fn plot_potential_r_delta_input_all_methods() -> Result<(), Box<dyn std::error::Error>> {
        use crate::core::fft::hilbert;
        use crate::core::log2space::Log2Space;
        use rustfft::{FftPlanner, num_complex::Complex32};

        let fs = 48_000.0;
        let params = KernelParams::default();
        let k = RoughnessKernel::new(params, 0.005);
        let space = Log2Space::new(20.0, 8000.0, 144);
        let nfft = 163_84;

        let mut amps_log2 = vec![0.0f32; space.centers_hz.len()];
        let mid = amps_log2.len() / 2;
        amps_log2[mid] = 1.0;

        let (_r_log2, _) = k.potential_r_from_log2_spectrum(&amps_log2, &space);

        let df = fs / nfft as f32;
        let mut amps_lin = vec![0.0f32; nfft / 2];
        for (kidx, &f) in space.centers_hz.iter().enumerate() {
            let bin = (f / df).round() as usize;
            if bin < amps_lin.len() {
                amps_lin[bin] += amps_log2[kidx];
            }
        }
        let (_r_spec, _) = k.potential_r_from_spectrum(&amps_lin, fs);

        let mut buf = vec![Complex32::new(0.0, 0.0); nfft];
        for (i, &amp) in amps_lin.iter().enumerate() {
            buf[i] = Complex32::new(amp, 0.0);
        }
        for i in 1..(nfft / 2) {
            buf[nfft - i] = buf[i].conj();
        }
        let mut planner = FftPlanner::new();
        let ifft = planner.plan_fft_inverse(nfft);
        ifft.process(&mut buf);
        let sig: Vec<f32> = buf.iter().map(|z| z.re / nfft as f32).collect();
        let (_r_analytic, _) = k.potential_r_from_analytic(&hilbert(&sig), fs);

        // plotting same as original (omitted for brevity)
        Ok(())
    }
}
</file>

<file path="src/core/timebase.rs">
pub type Tick = u64;

#[derive(Clone, Copy, Debug)]
pub struct Timebase {
    pub fs: f32,
    pub hop: usize,
}

impl Timebase {
    pub fn tick_to_sec(&self, t: Tick) -> f32 {
        t as f32 / self.fs
    }

    pub fn sec_to_tick(&self, s: f32) -> Tick {
        if s <= 0.0 {
            return 0;
        }
        let tick = (s as f64 * self.fs as f64).round();
        tick as Tick
    }

    pub fn frame_start_tick(&self, frame_idx: u64) -> Tick {
        frame_idx.saturating_mul(self.hop as u64)
    }

    pub fn frame_end_tick(&self, frame_idx: u64) -> Tick {
        self.frame_start_tick(frame_idx)
            .saturating_add(self.hop as u64)
    }

    pub fn ceil_to_hop_tick(&self, tick: Tick) -> Tick {
        let hop = self.hop as Tick;
        if hop == 0 {
            return tick;
        }
        let rem = tick % hop;
        if rem == 0 {
            tick
        } else {
            tick.saturating_add(hop - rem)
        }
    }

    pub fn min_lead_ticks(&self) -> Tick {
        let mut ticks = self.sec_to_tick(0.005);
        if ticks == 0 {
            ticks = 1;
        }
        ticks
    }
}

#[cfg(test)]
mod tests {
    use super::{Tick, Timebase};

    #[test]
    fn sec_tick_round_trip() {
        let tb = Timebase {
            fs: 48_000.0,
            hop: 512,
        };
        let t: Tick = 12_345;
        let sec = tb.tick_to_sec(t);
        let round = tb.sec_to_tick(sec);
        assert_eq!(round, t);
    }

    #[test]
    fn frame_bounds() {
        let tb = Timebase {
            fs: 48_000.0,
            hop: 256,
        };
        let start = tb.frame_start_tick(10);
        let end = tb.frame_end_tick(10);
        assert_eq!(start, 2560);
        assert_eq!(end, 2816);
    }
}
</file>

<file path="src/life/sound/any_backend.rs">
use crate::core::log2space::Log2Space;
use crate::life::individual::ArticulationSignal;
use crate::life::sound::control::VoiceControlBlock;
use crate::life::sound::modal_engine::{ModalEngine, ModeShape};
use crate::synth::SynthError;

#[derive(Debug, Clone)]
pub enum AnyBackend {
    Modal(ModalEngine),
}

impl AnyBackend {
    pub fn from_shape(fs: f32, shape: ModeShape) -> Result<Self, SynthError> {
        Ok(Self::Modal(ModalEngine::new(fs, shape)?))
    }

    pub fn render_block(&mut self, drive: &[f32], ctrl: VoiceControlBlock, out: &mut [f32]) {
        match self {
            AnyBackend::Modal(engine) => engine.render_block(drive, ctrl, out),
        }
    }

    pub fn project_spectral(
        &mut self,
        amps: &mut [f32],
        space: &Log2Space,
        signal: &ArticulationSignal,
    ) {
        match self {
            AnyBackend::Modal(engine) => engine.project_spectral(amps, space, signal),
        }
    }

    #[cfg(test)]
    pub(crate) fn debug_last_modes_len(&self) -> usize {
        match self {
            AnyBackend::Modal(engine) => engine.last_modes_len(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::life::sound::control::{ControlRamp, VoiceControlBlock};

    #[test]
    fn any_backend_delegates_render_block() {
        let fs = 48_000.0;
        let shape = ModeShape::Sine {
            t60_s: 0.3,
            out_gain: 1.0,
            in_gain: 1.0,
        };
        let mut backend = AnyBackend::from_shape(fs, shape).expect("backend");
        let drive = [1.0, 0.0, 0.0, 0.0];
        let ctrl = VoiceControlBlock {
            pitch_hz: ControlRamp {
                start: 440.0,
                step: 0.0,
            },
            amp: ControlRamp {
                start: 1.0,
                step: 0.0,
            },
        };
        let mut out = [0.0f32; 4];
        backend.render_block(&drive, ctrl, &mut out);
        assert!(out.iter().all(|s| s.is_finite()));
        assert!(out.iter().any(|s| s.abs() > 1e-6));
    }
}
</file>

<file path="src/life/sound/control.rs">
#[derive(Debug, Clone, Copy)]
pub struct ControlRamp {
    pub start: f32,
    pub step: f32,
}

impl ControlRamp {
    pub fn for_len(start: f32, end: f32, len: usize) -> Self {
        let len = len.max(1);
        let step = (end - start) / len as f32;
        Self { start, step }
    }

    pub fn value_at(&self, idx: usize) -> f32 {
        self.start + self.step * idx as f32
    }
}

#[derive(Debug, Clone, Copy)]
pub struct VoiceControlBlock {
    pub pitch_hz: ControlRamp,
    pub amp: ControlRamp,
}
</file>

<file path="src/life/sound/events.rs">
pub type IndividualId = u64;

use crate::life::intent::BodySnapshot;

#[derive(Debug, Clone)]
pub enum AudioCommand {
    EnsureVoice {
        id: IndividualId,
        body: BodySnapshot,
        pitch_hz: f32,
        amp: f32,
    },
    Impulse {
        id: IndividualId,
        energy: f32,
    },
}

#[derive(Debug, Clone, Copy)]
pub struct VoiceTarget {
    pub id: IndividualId,
    pub pitch_hz: f32,
    pub amp: f32,
}
</file>

<file path="src/life/sound/mod.rs">
pub mod any_backend;
pub mod control;
pub mod events;
pub mod modal_engine;
pub mod voice;

pub use any_backend::AnyBackend;
pub use control::{ControlRamp, VoiceControlBlock};
pub use events::{AudioCommand, IndividualId, VoiceTarget};
pub use modal_engine::{ModalEngine, ModalMode, ModeShape};
pub use voice::{Voice, default_release_ticks};
</file>

<file path="src/life/sound/modal_engine.rs">
use crate::core::log2space::Log2Space;
use crate::life::individual::ArticulationSignal;
use crate::life::scenario::{HarmonicMode, TimbreGenotype};
use crate::life::sound::control::VoiceControlBlock;
use crate::synth::SynthError;
use crate::synth::modes::ModeParams;
use crate::synth::resonator::ResonatorBank;

const DEFAULT_UPDATE_PERIOD_SAMPLES: usize = 64;

#[derive(Debug, Clone)]
pub enum ModeShape {
    Sine {
        t60_s: f32,
        out_gain: f32,
        in_gain: f32,
    },
    Harmonic {
        partials: usize,
        base_t60_s: f32,
        in_gain: f32,
        genotype: TimbreGenotype,
    },
    Modal {
        modes: Vec<ModalMode>,
    },
}

#[derive(Debug, Clone)]
pub struct ModalMode {
    pub ratio: f32,
    pub t60_s: f32,
    pub gain: f32,
    pub in_gain: f32,
}

#[derive(Debug, Clone)]
pub struct ModalEngine {
    bank: ResonatorBank,
    shape: ModeShape,
    scratch: Vec<ModeParams>,
    last_built_pitch_hz: f32,
    update_period_samples: usize,
    counter: usize,
    last_modes_len: usize,
}

impl ModalEngine {
    pub fn new(fs: f32, shape: ModeShape) -> Result<Self, SynthError> {
        let max_modes = shape.max_modes().max(1);
        let bank = ResonatorBank::new(fs, max_modes)?;
        let scratch = Vec::with_capacity(max_modes);
        Ok(Self {
            bank,
            shape,
            scratch,
            last_built_pitch_hz: 0.0,
            update_period_samples: DEFAULT_UPDATE_PERIOD_SAMPLES.max(1),
            counter: 0,
            last_modes_len: 0,
        })
    }

    pub fn last_modes_len(&self) -> usize {
        self.last_modes_len
    }

    fn rebuild_modes(&mut self, pitch_hz: f32) {
        if !pitch_hz.is_finite() || pitch_hz <= 0.0 {
            self.last_modes_len = 0;
            let _ = self.bank.set_modes_preserve_state(&[]);
            self.last_built_pitch_hz = pitch_hz;
            return;
        }
        let limit = self.bank.capacity();
        self.shape.build_modes(pitch_hz, limit, &mut self.scratch);
        self.last_modes_len = self.scratch.len();
        let _ = self
            .bank
            .set_modes_preserve_state(&self.scratch[..self.last_modes_len]);
        self.last_built_pitch_hz = pitch_hz;
    }
    pub fn render_block(&mut self, drive: &[f32], ctrl: VoiceControlBlock, out: &mut [f32]) {
        debug_assert_eq!(drive.len(), out.len());
        if drive.is_empty() {
            return;
        }
        let mut counter = self.counter;
        let period = self.update_period_samples.max(1);
        for (idx, (u, y)) in drive.iter().copied().zip(out.iter_mut()).enumerate() {
            let pitch_hz = ctrl.pitch_hz.start + ctrl.pitch_hz.step * idx as f32;
            let amp = ctrl.amp.start + ctrl.amp.step * idx as f32;
            if counter == 0 {
                self.rebuild_modes(pitch_hz.max(1.0));
            }
            let sample = self.bank.process_sample(u);
            if amp.is_finite() {
                *y += amp.max(0.0) * sample;
            }
            counter += 1;
            if counter >= period {
                counter = 0;
            }
        }
        self.counter = counter;
    }

    pub fn project_spectral(
        &mut self,
        amps: &mut [f32],
        space: &Log2Space,
        signal: &ArticulationSignal,
    ) {
        debug_assert_eq!(amps.len(), space.n_bins());
        if !signal.is_active || signal.amplitude <= 0.0 {
            return;
        }
        let pitch_hz = self.last_built_pitch_hz;
        if !pitch_hz.is_finite() || pitch_hz <= 0.0 {
            return;
        }
        let amp_scale = signal.amplitude;
        match &self.shape {
            ModeShape::Sine { out_gain, .. } => {
                add_log2_energy(amps, space, pitch_hz, amp_scale * out_gain.max(0.0));
            }
            ModeShape::Harmonic {
                partials, genotype, ..
            } => {
                let partials = (*partials).max(1);
                let energy = 1.0;
                for k in 1..=partials {
                    let ratio = harmonic_ratio(genotype, k);
                    let freq_hz = pitch_hz * ratio;
                    let gain = harmonic_gain(genotype, k, energy);
                    add_log2_energy(amps, space, freq_hz, amp_scale * gain);
                }
            }
            ModeShape::Modal { modes } => {
                for mode in modes {
                    let freq_hz = pitch_hz * mode.ratio;
                    add_log2_energy(amps, space, freq_hz, amp_scale * mode.gain);
                }
            }
        }
    }
}

impl ModeShape {
    fn max_modes(&self) -> usize {
        match self {
            ModeShape::Sine { .. } => 1,
            ModeShape::Harmonic { partials, .. } => (*partials).max(1),
            ModeShape::Modal { modes } => modes.len().max(1),
        }
    }

    fn build_modes(&self, pitch_hz: f32, limit: usize, scratch: &mut Vec<ModeParams>) {
        scratch.clear();
        match self {
            ModeShape::Sine {
                t60_s,
                out_gain,
                in_gain,
            } => {
                scratch.push(ModeParams {
                    freq_hz: pitch_hz,
                    t60_s: t60_s.max(1e-3),
                    gain: *out_gain,
                    in_gain: *in_gain,
                });
            }
            ModeShape::Harmonic {
                partials,
                base_t60_s,
                in_gain,
                genotype,
            } => {
                let partials = (*partials).max(1);
                let energy = 1.0;
                for k in 1..=partials {
                    if scratch.len() >= limit {
                        break;
                    }
                    let ratio = harmonic_ratio(genotype, k);
                    let freq_hz = pitch_hz * ratio;
                    if !freq_hz.is_finite() || freq_hz <= 0.0 {
                        continue;
                    }
                    let gain = harmonic_gain(genotype, k, energy);
                    let t60_s = base_t60_s.max(1e-3) / (1.0 + 0.15 * k as f32);
                    scratch.push(ModeParams {
                        freq_hz,
                        t60_s,
                        gain,
                        in_gain: *in_gain,
                    });
                }
            }
            ModeShape::Modal { modes } => {
                for mode in modes {
                    if scratch.len() >= limit {
                        break;
                    }
                    let freq_hz = pitch_hz * mode.ratio;
                    if !freq_hz.is_finite() || freq_hz <= 0.0 {
                        continue;
                    }
                    scratch.push(ModeParams {
                        freq_hz,
                        t60_s: mode.t60_s.max(1e-3),
                        gain: mode.gain,
                        in_gain: mode.in_gain,
                    });
                }
            }
        }
    }
}

fn harmonic_ratio(genotype: &TimbreGenotype, k: usize) -> f32 {
    let kf = k as f32;
    let base = match genotype.mode {
        HarmonicMode::Harmonic => kf,
        HarmonicMode::Metallic => kf.powf(1.4),
    };
    let stretch = 1.0 + genotype.stiffness * kf * kf;
    (base * stretch).max(0.1)
}

fn harmonic_gain(genotype: &TimbreGenotype, k: usize, energy: f32) -> f32 {
    let kf = k as f32;
    let slope = genotype.brightness.max(0.0);
    let mut amp = 1.0 / kf.powf(slope.max(1e-6));
    if k.is_multiple_of(2) {
        amp *= 1.0 - genotype.comb.clamp(0.0, 1.0);
    }
    let damping = genotype.damping.max(0.0);
    if damping > 0.0 {
        let energy = energy.clamp(0.0, 1.0);
        amp *= energy.powf(damping * kf);
    }
    amp
}

fn add_log2_energy(amps: &mut [f32], space: &Log2Space, freq_hz: f32, energy: f32) {
    if !freq_hz.is_finite() || energy == 0.0 {
        return;
    }
    if freq_hz < space.fmin || freq_hz > space.fmax {
        return;
    }
    let log_f = freq_hz.log2();
    let base = space.centers_log2[0];
    let step = space.step();
    let pos = (log_f - base) / step;
    let idx_base = pos.floor();
    let idx = idx_base as isize;
    if idx < 0 {
        return;
    }
    let idx = idx as usize;
    let frac = pos - idx_base;
    if idx + 1 < amps.len() {
        amps[idx] += energy * (1.0 - frac);
        amps[idx + 1] += energy * frac;
    } else if idx < amps.len() {
        amps[idx] += energy;
    }
}
</file>

<file path="src/life/sound/voice.rs">
use crate::core::modulation::NeuralRhythms;
use crate::core::timebase::{Tick, Timebase};
use crate::life::individual::{ArticulationSignal, ArticulationWrapper};
use crate::life::intent::{BodySnapshot, Intent};
use crate::life::lifecycle::default_decay_attack;
use crate::life::phonation_engine::{PhonationKick, PhonationUpdate};
use crate::life::scenario::TimbreGenotype;
use crate::life::sound::any_backend::AnyBackend;
use crate::life::sound::control::{ControlRamp, VoiceControlBlock};
use crate::life::sound::modal_engine::ModeShape;
use std::collections::VecDeque;

#[derive(Debug, Clone, Copy)]
struct PendingUpdate {
    at_tick: Tick,
    update: PhonationUpdate,
}

#[derive(Debug, Clone, Copy)]
struct PendingTrigger {
    at_tick: Tick,
    energy: f32,
}

pub struct Voice {
    backend: AnyBackend,
    articulation: Option<ArticulationWrapper>,
    pending_impulse_energy: f32,
    onset: Tick,
    hold_end: Tick,
    release_end: Tick,
    attack_ticks: Tick,
    release_ticks: Tick,
    planned_kick_pending: Option<PhonationKick>,
    pending_updates: VecDeque<PendingUpdate>,
    pending_trigger: Option<PendingTrigger>,
    current_amp: f32,
    target_amp: f32,
    current_pitch_hz: f32,
    target_pitch_hz: f32,
    amp_tau_sec: f32,
    pitch_tau_sec: f32,
    amp_alpha: f32,
    pitch_alpha: f32,
    sample_dt: f32,
}

impl Voice {
    pub fn from_intent(time: Timebase, mut intent: Intent) -> Option<Self> {
        if intent.duration == 0 || intent.freq_hz <= 0.0 {
            return None;
        }
        if !intent.freq_hz.is_finite() || !intent.amp.is_finite() {
            return None;
        }
        if intent.amp == 0.0 {
            return None;
        }

        let (shape, amp_scale) = match intent.body.as_ref() {
            Some(snapshot) => (mode_shape_from_snapshot(snapshot), snapshot.amp_scale),
            None => (default_mode_shape(), 1.0),
        };
        let amp = intent.amp * amp_scale.clamp(0.0, 1.0);
        if !amp.is_finite() || amp <= 0.0 {
            return None;
        }

        let backend = AnyBackend::from_shape(time.fs, shape).ok()?;
        let articulation = intent.articulation.take();

        let attack_ticks = default_attack_ticks(time);
        let release_ticks = default_release_ticks(time);
        let (hold_end, release_end) = if intent.duration == Tick::MAX {
            (Tick::MAX, Tick::MAX)
        } else {
            let hold_end = intent.onset.saturating_add(intent.duration);
            let release_end = hold_end.saturating_add(release_ticks);
            (hold_end, release_end)
        };

        let sample_dt = if time.fs.is_finite() && time.fs > 0.0 {
            1.0 / time.fs
        } else {
            0.0
        };
        let current_amp = amp.max(0.0);
        let target_amp = current_amp;
        let current_pitch_hz = intent.freq_hz;
        let target_pitch_hz = current_pitch_hz;
        let amp_tau_sec = 0.0;
        let pitch_tau_sec = 0.0;
        let amp_alpha = smoothing_alpha(sample_dt, amp_tau_sec);
        let pitch_alpha = smoothing_alpha(sample_dt, pitch_tau_sec);

        Some(Self {
            backend,
            articulation,
            pending_impulse_energy: 0.0,
            onset: intent.onset,
            hold_end,
            release_end,
            attack_ticks,
            release_ticks,
            planned_kick_pending: None,
            pending_updates: VecDeque::new(),
            pending_trigger: None,
            current_amp,
            target_amp,
            current_pitch_hz,
            target_pitch_hz,
            amp_tau_sec,
            pitch_tau_sec,
            amp_alpha,
            pitch_alpha,
            sample_dt,
        })
    }

    pub fn note_off(&mut self, tick: Tick) {
        if tick < self.hold_end {
            self.hold_end = tick;
            self.release_end = self.hold_end.saturating_add(self.release_ticks);
        }
    }

    pub fn note_on(&mut self, tick: Tick) {
        if tick > self.onset {
            self.onset = tick;
            if self.hold_end < self.onset {
                self.hold_end = self.onset;
                self.release_end = self.hold_end.saturating_add(self.release_ticks);
            }
        }
    }

    pub fn arm_onset_trigger(&mut self, energy: f32) {
        if !energy.is_finite() || energy <= 0.0 {
            return;
        }
        self.pending_trigger = Some(PendingTrigger {
            at_tick: self.onset,
            energy,
        });
    }

    pub fn trigger_impulse(&mut self, energy: f32) {
        if !energy.is_finite() || energy <= 0.0 {
            return;
        }
        self.pending_impulse_energy += energy;
    }

    pub fn set_target(&mut self, pitch_hz: f32, amp: f32, tau_sec: f32) {
        self.set_smoothing_tau_sec(tau_sec);
        if pitch_hz.is_finite() && pitch_hz > 0.0 {
            self.target_pitch_hz = pitch_hz;
            if self.pitch_alpha >= 1.0 {
                self.current_pitch_hz = pitch_hz;
            }
        }
        if amp.is_finite() {
            let amp = amp.max(0.0);
            self.target_amp = amp;
            if self.amp_alpha >= 1.0 {
                self.current_amp = amp;
            }
        }
    }

    pub fn kick_planned(&mut self, kick: PhonationKick, rhythms: &NeuralRhythms, dt: f32) -> bool {
        if let Some(articulation) = self.articulation.as_mut() {
            articulation.kick_planned(kick, rhythms, dt);
            return true;
        }
        false
    }

    pub fn schedule_planned_kick(&mut self, kick: PhonationKick) {
        self.planned_kick_pending = Some(kick);
    }

    pub fn schedule_update(&mut self, at_tick: Tick, update: PhonationUpdate) {
        if update.is_empty() {
            return;
        }
        let insert_at = self
            .pending_updates
            .iter()
            .position(|pending| pending.at_tick > at_tick)
            .unwrap_or(self.pending_updates.len());
        self.pending_updates
            .insert(insert_at, PendingUpdate { at_tick, update });
    }

    pub fn apply_updates_if_due(&mut self, tick: Tick) {
        if tick >= self.hold_end {
            self.pending_updates.clear();
            return;
        }
        while let Some(pending) = self.pending_updates.front().copied() {
            if pending.at_tick > tick {
                break;
            }
            let pending = self.pending_updates.pop_front().expect("pending update");
            self.apply_update(&pending.update);
        }
    }

    pub fn kick_planned_if_due(&mut self, tick: Tick, rhythms: &NeuralRhythms, dt: f32) -> bool {
        let Some(kick) = self.planned_kick_pending else {
            return false;
        };
        if tick >= self.onset {
            self.planned_kick_pending = None;
            return self.kick_planned(kick, rhythms, dt);
        }
        false
    }

    pub fn render_tick(&mut self, tick: Tick, _fs: f32, dt: f32, rhythms: &NeuralRhythms) -> f32 {
        if let Some(trigger) = self.pending_trigger
            && tick >= trigger.at_tick
        {
            self.pending_trigger = None;
            self.trigger_impulse(trigger.energy);
        }
        self.advance_smoothing();
        let gain = self.gain_at(tick);

        let mut signal = if let Some(articulation) = self.articulation.as_mut() {
            let mut signal = articulation.process(1.0, rhythms, dt, 1.0);
            signal.amplitude *= articulation.gate();
            signal
        } else {
            ArticulationSignal {
                amplitude: 1.0,
                is_active: true,
                relaxation: rhythms.theta.alpha,
                tension: rhythms.theta.beta,
            }
        };
        if self.articulation.is_none() {
            let tension = signal.tension.clamp(0.0, 1.0);
            signal.amplitude *= 1.0 + 0.05 * tension;
        }
        signal.amplitude *= gain;
        signal.is_active = signal.is_active && signal.amplitude > 0.0;

        let drive = self.pending_impulse_energy;
        self.pending_impulse_energy = 0.0;
        let ctrl = VoiceControlBlock {
            pitch_hz: ControlRamp {
                start: self.current_pitch_hz.max(1.0),
                step: 0.0,
            },
            amp: ControlRamp {
                start: self.current_amp.max(0.0),
                step: 0.0,
            },
        };
        let mut out = [0.0f32; 1];
        self.backend
            .render_block(std::slice::from_ref(&drive), ctrl, &mut out);
        if !signal.is_active {
            return 0.0;
        }
        out[0] * signal.amplitude
    }

    pub fn render_block(
        &mut self,
        start_tick: Tick,
        fs: f32,
        dt: f32,
        rhythms: &mut NeuralRhythms,
        out: &mut [f32],
    ) {
        let end = start_tick.saturating_add(out.len() as Tick);
        let mut tick = start_tick;
        for sample in out.iter_mut() {
            *sample = self.render_tick(tick, fs, dt, rhythms);
            rhythms.advance_in_place(dt);
            tick = tick.saturating_add(1);
            if tick >= end {
                break;
            }
        }
    }

    pub fn set_smoothing_tau_sec(&mut self, tau_sec: f32) {
        let tau = if tau_sec.is_finite() {
            tau_sec.max(0.0)
        } else {
            0.0
        };
        self.amp_tau_sec = tau;
        self.pitch_tau_sec = tau;
        self.amp_alpha = smoothing_alpha(self.sample_dt, self.amp_tau_sec);
        self.pitch_alpha = smoothing_alpha(self.sample_dt, self.pitch_tau_sec);
        if self.amp_alpha >= 1.0 {
            self.current_amp = self.target_amp;
        }
        if self.pitch_alpha >= 1.0 {
            self.current_pitch_hz = self.target_pitch_hz;
        }
    }

    #[cfg(test)]
    pub(crate) fn debug_target_amp(&self) -> f32 {
        self.target_amp
    }

    #[cfg(test)]
    pub(crate) fn debug_current_amp(&self) -> f32 {
        self.current_amp
    }

    #[cfg(test)]
    pub(crate) fn debug_target_freq_hz(&self) -> f32 {
        self.target_pitch_hz
    }

    #[cfg(test)]
    pub(crate) fn debug_current_freq_hz(&self) -> f32 {
        self.current_pitch_hz
    }

    #[cfg(test)]
    pub(crate) fn debug_last_modes_len(&self) -> usize {
        self.backend.debug_last_modes_len()
    }

    pub fn end_tick(&self) -> Tick {
        self.release_end
    }

    pub fn onset(&self) -> Tick {
        self.onset
    }

    pub fn is_done(&self, now: Tick) -> bool {
        now >= self.release_end
    }

    fn apply_update(&mut self, update: &PhonationUpdate) {
        if let Some(freq_hz) = update.target_freq_hz
            && freq_hz.is_finite()
            && freq_hz > 0.0
        {
            self.target_pitch_hz = freq_hz;
            if self.pitch_alpha >= 1.0 {
                self.current_pitch_hz = freq_hz;
            }
        }
        if let Some(amp) = update.target_amp
            && amp.is_finite()
        {
            let amp = amp.max(0.0);
            self.target_amp = amp;
            if self.amp_alpha >= 1.0 {
                self.current_amp = amp;
            }
        }
    }

    fn advance_smoothing(&mut self) {
        self.current_amp = smooth_step(self.current_amp, self.target_amp, self.amp_alpha);
        if !self.current_amp.is_finite() {
            self.current_amp = self.target_amp;
        }
        self.current_amp = self.current_amp.max(0.0);

        self.current_pitch_hz = smooth_step(
            self.current_pitch_hz,
            self.target_pitch_hz,
            self.pitch_alpha,
        );
        if !self.current_pitch_hz.is_finite() || self.current_pitch_hz <= 0.0 {
            self.current_pitch_hz = self.target_pitch_hz;
        }
    }

    fn gain_at(&self, tick: Tick) -> f32 {
        if tick < self.onset || tick >= self.release_end {
            return 0.0;
        }

        let duration_ticks = self.hold_end.saturating_sub(self.onset).max(1);
        let pos = tick.saturating_sub(self.onset);
        let attack_len = self.attack_ticks.min(duration_ticks);
        let attack = if attack_len > 0 && pos < attack_len {
            (pos.saturating_add(1) as f32 / attack_len as f32).clamp(0.0, 1.0)
        } else {
            1.0
        };

        let release = if tick >= self.hold_end {
            if self.release_ticks == 0 {
                0.0
            } else {
                let remain = self.release_end.saturating_sub(tick);
                (remain as f32 / self.release_ticks as f32).clamp(0.0, 1.0)
            }
        } else {
            1.0
        };

        (attack * release).clamp(0.0, 1.0)
    }
}

fn smooth_step(current: f32, target: f32, alpha: f32) -> f32 {
    if !current.is_finite() {
        return target;
    }
    if !target.is_finite() {
        return current;
    }
    current + alpha * (target - current)
}

fn smoothing_alpha(dt: f32, tau_sec: f32) -> f32 {
    if !dt.is_finite() || dt <= 0.0 {
        return 1.0;
    }
    if !tau_sec.is_finite() || tau_sec <= 0.0 {
        return 1.0;
    }
    let alpha = 1.0 - (-dt / tau_sec).exp();
    if alpha.is_finite() {
        alpha.clamp(0.0, 1.0)
    } else {
        1.0
    }
}

pub fn default_release_ticks(time: Timebase) -> Tick {
    let release_sec = default_decay_attack();
    sec_to_tick_at_least_one(time, release_sec)
}

fn default_attack_ticks(time: Timebase) -> Tick {
    let attack_sec = default_decay_attack();
    sec_to_tick_at_least_one(time, attack_sec)
}

fn sec_to_tick_at_least_one(time: Timebase, sec: f32) -> Tick {
    if !sec.is_finite() || sec <= 0.0 {
        return 1;
    }
    let ticks = time.sec_to_tick(sec);
    if ticks < 1 { 1 } else { ticks }
}

fn default_mode_shape() -> ModeShape {
    ModeShape::Sine {
        t60_s: 0.8,
        out_gain: 1.0,
        in_gain: 1.0,
    }
}

fn mode_shape_from_snapshot(snapshot: &BodySnapshot) -> ModeShape {
    match snapshot.kind.as_str() {
        "harmonic" => ModeShape::Harmonic {
            partials: 16,
            base_t60_s: 0.8,
            in_gain: 1.0,
            genotype: TimbreGenotype {
                brightness: snapshot.brightness.clamp(0.0, 1.0),
                jitter: snapshot.noise_mix.clamp(0.0, 1.0),
                ..TimbreGenotype::default()
            },
        },
        _ => default_mode_shape(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn spawn_does_not_sound_until_triggered() {
        let tb = Timebase {
            fs: 48_000.0,
            hop: 64,
        };
        let intent = Intent {
            source_id: 1,
            intent_id: 0,
            onset: 0,
            duration: Tick::MAX,
            freq_hz: 440.0,
            amp: 0.5,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        };
        let mut voice = Voice::from_intent(tb, intent).expect("voice");

        let mut rhythms = NeuralRhythms::default();
        let mut out = vec![0.0f32; tb.hop];
        voice.render_block(0, tb.fs, 1.0 / tb.fs, &mut rhythms, &mut out);
        assert!(out.iter().all(|s| s.abs() <= 1e-6));

        voice.trigger_impulse(1.0);
        let mut rhythms = NeuralRhythms::default();
        let mut out = vec![0.0f32; tb.hop];
        voice.render_block(0, tb.fs, 1.0 / tb.fs, &mut rhythms, &mut out);
        assert!(out.iter().any(|s| s.abs() > 1e-6));
    }
}
</file>

<file path="src/life/gate_clock.rs">
use std::f32::consts::TAU;

use crate::core::modulation::RhythmBand;
use crate::core::phase::wrap_0_tau;
use crate::core::timebase::Tick;

const PHI_EPSILON: f32 = 1e-6;

pub fn next_gate_tick(
    now_tick: Tick,
    fs: f32,
    theta: RhythmBand,
    target_phase: f32,
) -> Option<Tick> {
    if !fs.is_finite() || fs <= 0.0 {
        return None;
    }
    if !theta.freq_hz.is_finite() || theta.freq_hz <= 0.0 {
        return None;
    }
    if !theta.phase.is_finite() || !target_phase.is_finite() {
        return None;
    }

    let phi0 = wrap_0_tau(theta.phase);
    let phi_t = wrap_0_tau(target_phase);
    let mut dphi = (phi_t - phi0).rem_euclid(TAU);
    if dphi < PHI_EPSILON {
        dphi += TAU;
    }

    let dt_sec = dphi / (TAU * theta.freq_hz);
    let dt_tick_f = dt_sec * fs;
    if !dt_tick_f.is_finite() {
        return None;
    }
    if dt_tick_f > Tick::MAX as f32 {
        return None;
    }

    let dt_tick = dt_tick_f.round().max(1.0) as Tick;

    let next_tick = now_tick.saturating_add(dt_tick);
    if next_tick <= now_tick {
        return None;
    }
    Some(next_tick)
}
</file>

<file path="src/synth/mod.rs">
//! Synthesis primitives without semantic meaning (Hz, sec).

pub mod modes;
pub mod resonator;
pub mod util;

/// Errors returned by synth primitives.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum SynthError {
    /// Sample rate is non-finite or not positive.
    InvalidSampleRate,
    /// Provided modes exceed the bank capacity.
    TooManyModes { requested: usize, capacity: usize },
}
</file>

<file path="src/synth/modes.rs">
//! Mode parameters and compiled coefficients (Hz, sec, theta = 2*pi*freq_hz/fs).

use std::f32::consts::PI;

/// Coefficients used by the sample processing loop.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct ModeCoeffs {
    /// Tuning coefficient: e = 2*sin(theta/2).
    pub e: f32,
    /// Per-sample decay 0..1.
    pub r: f32,
    /// Input coupling gain.
    pub b1: f32,
    /// Secondary coupling (reserved).
    pub b2: f32,
    /// Output gain.
    pub gain: f32,
}

impl ModeCoeffs {
    /// Safe zero coefficients.
    pub fn zero() -> Self {
        Self {
            e: 0.0,
            r: 0.0,
            b1: 0.0,
            b2: 0.0,
            gain: 0.0,
        }
    }
}

/// Parameters per mode in Hz and seconds.
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct ModeParams {
    /// Mode frequency in Hz.
    pub freq_hz: f32,
    /// T60 decay time in seconds.
    pub t60_s: f32,
    /// Output gain contribution.
    pub gain: f32,
    /// Input coupling gain for u.
    pub in_gain: f32,
}

impl Default for ModeParams {
    fn default() -> Self {
        Self {
            freq_hz: 440.0,
            t60_s: 1.0,
            gain: 0.0,
            in_gain: 0.0,
        }
    }
}

/// Compile parameters into coefficients using:
/// theta = 2*pi*freq_hz/fs, e = 2*sin(theta/2), r = 10^(-3/(t60_s*fs)).
/// Returns `ModeCoeffs::zero()` when `fs` is non-finite or <= 0.
pub fn compile_mode(params: &ModeParams, fs: f32) -> ModeCoeffs {
    if !fs.is_finite() || fs <= 0.0 {
        debug_assert!(fs.is_finite() && fs > 0.0, "invalid sample rate");
        return ModeCoeffs::zero();
    }

    let fs_safe = fs;
    let freq_max = (fs_safe * 0.49).max(1.0);

    let freq_hz = clamp_finite(params.freq_hz, 1.0, freq_max, 1.0);
    let t60_s = clamp_finite(params.t60_s, 0.005, 120.0, 0.005);

    let gain = if params.gain.is_finite() {
        params.gain
    } else {
        0.0
    };
    let in_gain = if params.in_gain.is_finite() {
        params.in_gain
    } else {
        0.0
    };

    let theta = 2.0 * PI * freq_hz / fs_safe;
    let e = 2.0 * (0.5 * theta).sin();

    let r_raw = 10.0_f32.powf(-3.0 / (t60_s * fs_safe));
    let r = if r_raw.is_finite() {
        r_raw.clamp(0.0, 0.999_999_9)
    } else {
        0.0
    };

    ModeCoeffs {
        e,
        r,
        b1: in_gain,
        b2: 0.0,
        gain,
    }
}

fn clamp_finite(value: f32, min: f32, max: f32, fallback: f32) -> f32 {
    if !value.is_finite() {
        return fallback;
    }
    if value < min {
        min
    } else if value > max {
        max
    } else {
        value
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn compile_r_matches_t60() {
        let fs = 48_000.0;
        let t60_s = 1.0;
        let params = ModeParams {
            freq_hz: 440.0,
            t60_s,
            gain: 0.0,
            in_gain: 0.0,
        };
        let coeffs = compile_mode(&params, fs);
        let n = (fs * t60_s) as f32;
        let decay = coeffs.r.powf(n);
        let expected = 1.0e-3_f32;
        let rel_err = ((decay / expected) - 1.0).abs();
        assert!(rel_err < 1.0e-3, "decay={decay} rel_err={rel_err}");
    }

    #[test]
    fn compile_sanitizes_non_finite_params() {
        let fs = 48_000.0;
        let safe_freq = 1.0;
        let safe_t60 = 0.005;

        let theta = 2.0 * PI * safe_freq / fs;
        let expected_e = 2.0 * (0.5 * theta).sin();
        let expected_r = 10.0_f32
            .powf(-3.0 / (safe_t60 * fs))
            .clamp(0.0, 0.999_999_9);

        let cases = [
            ModeParams {
                freq_hz: f32::NAN,
                t60_s: f32::NAN,
                gain: f32::NAN,
                in_gain: f32::NAN,
            },
            ModeParams {
                freq_hz: f32::INFINITY,
                t60_s: f32::INFINITY,
                gain: f32::INFINITY,
                in_gain: f32::INFINITY,
            },
        ];

        for params in cases.iter() {
            let coeffs = compile_mode(params, fs);
            assert!(coeffs.e.is_finite());
            assert!(coeffs.r.is_finite());
            assert!(coeffs.b1.is_finite());
            assert!(coeffs.gain.is_finite());
            assert_eq!(coeffs.b1, 0.0);
            assert_eq!(coeffs.gain, 0.0);
            assert!((coeffs.e - expected_e).abs() < 1.0e-6);
            assert!((coeffs.r - expected_r).abs() < 1.0e-6);
        }
    }
}
</file>

<file path="src/synth/util.rs">
//! Small DSP helpers (denorm flush for audio-rate values).

const DENORM_THRESH: f32 = 1.0e-20;

/// Flush denormals and non-finite values to zero.
#[inline(always)]
pub fn flush_denorm(x: f32) -> f32 {
    if !x.is_finite() || x.abs() < DENORM_THRESH {
        0.0
    } else {
        x
    }
}
</file>

<file path="src/ui/plots.rs">
use crate::ui::viewdata::AgentStateInfo;
use egui::{Align2, Color32, FontId, Id, Stroke, Vec2, Vec2b};
use egui_plot::{
    Bar, BarChart, GridInput, GridMark, Line, LineStyle, Plot, PlotPoints, Points, Polygon,
    log_grid_spacer,
};
use std::collections::VecDeque;

/// Histogram on a log2 frequency axis (auto bin width).
#[allow(clippy::too_many_arguments)]
pub fn log2_hist_hz(
    ui: &mut egui::Ui,
    title: &str,
    xs_hz: &[f32],
    ys: &[f32],
    y_label: &str,
    y_min: f64,
    y_max: f64,
    height: f32,
) {
    assert_eq!(xs_hz.len(), ys.len());
    if xs_hz.is_empty() {
        return;
    }

    // Use a sparser set to keep labels from colliding.
    const HZ_TICKS: [f64; 5] = [20.0, 100.0, 1_000.0, 10_000.0, 20_000.0];
    let tick_marks_log2: Vec<f64> = HZ_TICKS.iter().map(|hz| hz.log2()).collect();

    // Choose a bar width per bin based on neighbor spacing in log2 frequency.
    let mut bars: Vec<Bar> = Vec::with_capacity(xs_hz.len());
    for i in 0..xs_hz.len() {
        let f = xs_hz[i].max(1.0); // Avoid log2(0).
        let f_left = if i > 0 { xs_hz[i - 1].max(1.0) } else { f };
        let f_right = if i + 1 < xs_hz.len() {
            xs_hz[i + 1].max(1.0)
        } else {
            f
        };

        // Estimate bar width in log2 space from neighbor centers.
        let left = (f_left.log2() + f.log2()) * 0.5;
        let right = (f_right.log2() + f.log2()) * 0.5;
        let width = (right - left).abs().max(0.001);

        bars.push(
            Bar::new(f.log2() as f64, ys[i] as f64)
                .width(width as f64)
                .fill(Color32::from_rgb(240, 120, 120)) // match Roughness accent
                .stroke(egui::Stroke::NONE),
        );
    }

    let chart = BarChart::new(y_label, bars);

    let y_max_fixed = if y_max <= y_min { y_min + 1.0 } else { y_max };

    let tick_marks_log2_for_grid = tick_marks_log2.clone();
    Plot::new(title)
        .height(height)
        .allow_scroll(false)
        .allow_drag(false)
        .include_y(y_min)
        .include_y(y_max_fixed)
        .include_x((20.0f64).log2())
        .include_x((20_000.0f64).log2())
        .default_x_bounds((20.0f64).log2(), (20_000.0f64).log2())
        .default_y_bounds(y_min, y_max_fixed)
        .x_grid_spacer(move |_input: GridInput| {
            tick_marks_log2_for_grid
                .iter()
                .enumerate()
                .map(|(i, &v)| {
                    let step_size = if i + 1 < tick_marks_log2_for_grid.len() {
                        tick_marks_log2_for_grid[i + 1] - v
                    } else {
                        tick_marks_log2_for_grid[i] - tick_marks_log2_for_grid[i - 1]
                    };
                    GridMark {
                        value: v,
                        step_size,
                    }
                })
                .collect()
        })
        .x_axis_formatter(|mark, _range| {
            let hz = 2f64.powf(mark.value);
            if hz < 1000.0 {
                format!("{:.0} Hz", hz)
            } else {
                format!("{:.1} kHz", hz / 1000.0)
            }
        })
        .y_axis_formatter(|mark, _| format!("{:.2}", mark.value))
        .show(ui, |plot_ui| {
            plot_ui.bar_chart(chart);
        });
}

/// Generic log2-frequency plot.
#[allow(clippy::too_many_arguments)]
pub fn log2_plot_hz(
    ui: &mut egui::Ui,
    title: &str,
    xs_hz: &[f32],
    ys: &[f32],
    y_label: &str,
    y_min: f64,
    y_max: f64,
    height: f32,
    link_group: Option<&str>,
    line_color: Option<Color32>,
    overlay: Option<(&[f32], &str, Color32)>,
) {
    assert_eq!(
        xs_hz.len(),
        ys.len(),
        "x/y length mismatch: {} vs {}",
        xs_hz.len(),
        ys.len()
    );
    debug_assert!(
        xs_hz
            .windows(2)
            .all(|w| w[0].is_finite() && w[1].is_finite() && w[1] > w[0]),
        "log2_plot_hz expects strictly increasing finite x values"
    );

    // === Convert X axis to log2(Hz) ===
    let points: PlotPoints = xs_hz
        .iter()
        .zip(ys.iter())
        .map(|(&xx, &yy)| [xx.log2() as f64, yy as f64])
        .collect();

    // === Line object for egui_plot ===
    let mut line = Line::new(y_label, points);
    if let Some(color) = line_color {
        line = line.color(color);
    }
    let overlay_line = overlay.map(|(ys2, label, color)| {
        assert_eq!(
            xs_hz.len(),
            ys2.len(),
            "x/overlay length mismatch: {} vs {}",
            xs_hz.len(),
            ys2.len()
        );
        let points: PlotPoints = xs_hz
            .iter()
            .zip(ys2.iter())
            .map(|(&xx, &yy)| [xx.log2() as f64, yy as f64])
            .collect();
        Line::new(label, points).color(color)
    });

    // === Convert X range (20-20 kHz) to log2 ===
    let x_min = (20.0f64).log2();
    let x_max = (20_000.0f64).log2();

    // === Render ===
    let mut plot = Plot::new(title)
        .height(height)
        .allow_scroll(false)
        .allow_drag(false)
        .include_x(x_min)
        .include_x(x_max)
        .include_y(y_min)
        .include_y(y_max)
        .x_grid_spacer(log_grid_spacer(10))
        .x_axis_formatter(|mark, _range| {
            let hz = 2f64.powf(mark.value);
            format!("{:.0}", hz)
        })
        .y_axis_formatter(|mark, _range| format!("{:.2}", mark.value));
    if let Some(link) = link_group {
        plot = plot.link_axis(Id::new(link), Vec2b::new(true, false));
    }

    plot.show(ui, |plot_ui| {
        plot_ui.line(line);
        if let Some(line) = overlay_line {
            plot_ui.line(line);
        }
    });
}

/// Draw harmonicity above zero and roughness below zero on a log2 axis.
pub fn draw_roughness_harmonicity(
    ui: &mut egui::Ui,
    title: &str,
    xs_hz: &[f32],
    harmonicity: &[f32],
    roughness: &[f32],
    height: f32,
    link_group: Option<&str>,
) {
    assert_eq!(
        xs_hz.len(),
        harmonicity.len(),
        "x/h length mismatch: {} vs {}",
        xs_hz.len(),
        harmonicity.len()
    );
    assert_eq!(
        xs_hz.len(),
        roughness.len(),
        "x/r length mismatch: {} vs {}",
        xs_hz.len(),
        roughness.len()
    );
    if xs_hz.is_empty() {
        return;
    }

    let points_h: PlotPoints = xs_hz
        .iter()
        .zip(harmonicity.iter())
        .map(|(&xx, &yy)| {
            let v = if yy.is_finite() { yy } else { 0.0 };
            [xx.log2() as f64, v.clamp(0.0, 1.0) as f64]
        })
        .collect();
    let points_r: PlotPoints = xs_hz
        .iter()
        .zip(roughness.iter())
        .map(|(&xx, &yy)| {
            let v = if yy.is_finite() { yy } else { 0.0 };
            [xx.log2() as f64, -(v.clamp(0.0, 1.0) as f64)]
        })
        .collect();

    let mut plot = Plot::new(title)
        .height(height)
        .allow_scroll(false)
        .allow_drag(false)
        .include_x((20.0f64).log2())
        .include_x((20_000.0f64).log2())
        .include_y(-1.0)
        .include_y(1.0)
        .default_y_bounds(-1.0, 1.0)
        .x_grid_spacer(log_grid_spacer(10))
        .x_axis_formatter(|mark, _range| {
            let hz = 2f64.powf(mark.value);
            format!("{:.0}", hz)
        })
        .y_axis_formatter(|mark, _range| format!("{:.2}", mark.value));
    if let Some(link) = link_group {
        plot = plot.link_axis(Id::new(link), Vec2b::new(true, false));
    }

    plot.show(ui, |plot_ui| {
        plot_ui.line(Line::new("H", points_h));
        plot_ui.line(Line::new("R", points_r));
    });
}

pub fn time_plot(
    ui: &mut egui::Ui,
    title: &str,
    fs: f64,
    samples: &[f32],
    height: f32,
    show_y_axis: bool,
) {
    let points: PlotPoints = samples
        .iter()
        .enumerate()
        .map(|(i, s)| [i as f64 / fs, *s as f64])
        .collect();
    let line = Line::new("wave", points);

    ui.vertical(|ui| {
        let mut plot = Plot::new(title)
            .height(height)
            .allow_scroll(false)
            .allow_drag(false)
            .include_y(-1.1)
            .include_y(1.1)
            .default_y_bounds(-1.1, 1.1)
            .x_axis_formatter(|mark, _| format!("{:.3} s", mark.value));
        if show_y_axis {
            plot = plot.y_axis_formatter(|mark, _| format!("{:.2}", mark.value));
        } else {
            plot = plot.y_axis_formatter(|_, _| String::new());
        }
        plot.show(ui, |plot_ui| {
            plot_ui.line(line);
        });
    });
}

/// Show magnitude history for neural rhythms to avoid phase aliasing.
pub fn neural_activity_plot(
    ui: &mut egui::Ui,
    history: &VecDeque<(f64, crate::core::modulation::NeuralRhythms)>,
    height: f32,
    window_start: f64,
    window_end: f64,
    link_group: Option<&str>,
) {
    if history.len() < 2 {
        ui.label("No rhythm data");
        return;
    }

    let mut plot = Plot::new("neural_activity")
        .height(height)
        .allow_drag(true)
        .allow_scroll(true)
        .include_y(0.0)
        .include_y(1.0)
        .include_x(window_start)
        .include_x(window_end)
        .default_x_bounds(window_start, window_end)
        .y_axis_formatter(|_, _| String::new())
        .x_axis_formatter(|mark, _| format!("{:.1} s", mark.value));
    if let Some(link) = link_group {
        plot = plot.link_axis(Id::new(link), Vec2b::new(true, false));
    }
    plot.show(ui, |plot_ui| {
        let colors = [
            (Color32::from_rgb(80, 180, 255), "Delta (Phase)"),
            (Color32::from_rgb(70, 225, 135), "Theta (Phase)"),
            (Color32::from_rgb(255, 215, 60), "Alpha (Mag)"),
            (Color32::from_rgb(255, 110, 90), "Beta (Mag)"),
        ];

        for (idx, (color, name)) in colors.iter().enumerate() {
            let is_phase = idx <= 1;
            let mut segments: Vec<(Vec<[f64; 2]>, Color32)> = Vec::new();
            let mut current_pts: Vec<[f64; 2]> = Vec::new();
            let mut current_opacity: f32 = 1.0;
            let mut prev_val = 0.0f64;
            let mut prev_t = 0.0f64;
            let mut has_prev = false;

            for (t, r) in history {
                let (val, mag) = match idx {
                    0 => (
                        (r.delta.phase as f64).rem_euclid(std::f64::consts::TAU)
                            / std::f64::consts::TAU,
                        r.delta.mag,
                    ),
                    1 => (
                        (r.theta.phase as f64).rem_euclid(std::f64::consts::TAU)
                            / std::f64::consts::TAU,
                        r.theta.mag,
                    ),
                    2 => {
                        let alpha_mag = 0.5 * (r.theta.alpha + r.delta.alpha);
                        (alpha_mag.clamp(0.0, 1.0) as f64, alpha_mag)
                    }
                    3 => {
                        let beta_mag = r.theta.beta.max(r.delta.beta);
                        (beta_mag.clamp(0.0, 1.0) as f64, beta_mag)
                    }
                    _ => (0.0, 0.0),
                };

                let raw_opacity = 0.3 + 0.7 * mag.clamp(0.0, 1.0);
                let new_opacity = (raw_opacity * 10.0).round() / 10.0;

                if !has_prev {
                    current_opacity = new_opacity;
                    current_pts.push([*t, val]);
                    prev_val = val;
                    prev_t = *t;
                    has_prev = true;
                    continue;
                }

                let is_wrap = is_phase && (val - prev_val < -0.5);
                let is_opacity_change = (new_opacity - current_opacity).abs() > 0.05;

                if is_wrap {
                    let dt = *t - prev_t;
                    let v_diff = (val + 1.0) - prev_val;
                    if v_diff > 1e-5 {
                        let frac = (1.0 - prev_val) / v_diff;
                        let t_cross = prev_t + dt * frac;
                        current_pts.push([t_cross, 1.0]);
                        segments.push((current_pts, color.gamma_multiply(current_opacity)));
                        current_pts = vec![[t_cross, 0.0]];
                    } else {
                        segments.push((current_pts, color.gamma_multiply(current_opacity)));
                        current_pts = Vec::new();
                    }

                    current_pts.push([*t, val]);
                    current_opacity = new_opacity;
                } else if is_opacity_change {
                    segments.push((current_pts.clone(), color.gamma_multiply(current_opacity)));
                    let last_pt = *current_pts.last().unwrap();
                    current_pts = vec![last_pt, [*t, val]];
                    current_opacity = new_opacity;
                } else {
                    current_pts.push([*t, val]);
                }

                prev_val = val;
                prev_t = *t;
            }

            if !current_pts.is_empty() {
                segments.push((current_pts, color.gamma_multiply(current_opacity)));
            }

            for (seg_i, (pts, col)) in segments.into_iter().enumerate() {
                let series = PlotPoints::from(pts);
                let mut line = Line::new("", series).color(col).width(2.0);
                if seg_i == 0 {
                    line = line.name(*name);
                }
                plot_ui.line(line);
            }
        }
    });
}

/// Show current vs target frequency for each agent with intent arrows.
pub fn plot_population_dynamics(
    ui: &mut egui::Ui,
    agents: &[AgentStateInfo],
    spec_hz: &[f32],
    spec_amps: &[f32],
    height: f32,
) {
    let x_min = (20.0f64).log2();
    let x_max = (20_000.0f64).log2();
    let plot = Plot::new("population_dynamics")
        .height(height)
        .allow_scroll(true)
        .allow_drag(true)
        .include_y(-1.0)
        .include_y(1.1)
        .include_x(x_min)
        .include_x(x_max)
        .x_axis_formatter(|mark, _| format!("{:.0} Hz", 2f64.powf(mark.value)))
        .y_axis_formatter(|mark, _| format!("{:.2}", mark.value))
        .link_axis(Id::new("landscape_group"), Vec2b::new(true, false));

    plot.show(ui, |plot_ui| {
        if spec_hz.len() > 1 && spec_amps.len() > 1 {
            let mut bars: Vec<Bar> = Vec::with_capacity(spec_hz.len().saturating_sub(1));
            for i in 1..spec_hz.len().min(spec_amps.len()) {
                let f = spec_hz[i].max(1.0);
                let f_left = if i > 1 { spec_hz[i - 1].max(1.0) } else { f };
                let f_right = if i + 1 < spec_hz.len() {
                    spec_hz[i + 1].max(1.0)
                } else {
                    f
                };
                let left = (f_left.log2() + f.log2()) * 0.5;
                let right = (f_right.log2() + f.log2()) * 0.5;
                let width = (right - left).abs().max(0.001);
                bars.push(Bar::new(f.log2() as f64, spec_amps[i] as f64).width(width as f64));
            }
            plot_ui.bar_chart(BarChart::new("Sound bodies", bars));
        }

        for agent in agents {
            let y = agent.consonance as f64;
            let x = agent.freq_hz.max(1.0).log2() as f64;
            let xt = agent.target_freq.max(1.0).log2() as f64;
            if (x - xt).abs() > f64::EPSILON {
                plot_ui.line(
                    Line::new(format!("intent-{}", agent.id), vec![[x, y], [xt, y]])
                        .color(Color32::from_rgb(80, 140, 255))
                        .style(LineStyle::Dashed { length: 4.0 }),
                );
            }
            let t = agent.consonance.clamp(0.0, 1.0);
            let r = (60.0 + 180.0 * (1.0 - t)) as u8;
            let g = (80.0 + 140.0 * t) as u8;
            let b = (180.0 - 80.0 * t) as u8;
            // Use log2(window) so point size varies smoothly on a log-frequency x-axis.
            let radius = (agent.integration_window.max(1.0).log2() * 4.0).clamp(3.0, 20.0);
            plot_ui.points(
                Points::new(format!("agent-{}", agent.id), vec![[x, y]])
                    .radius(radius)
                    .color(Color32::from_rgb(r, g, b)),
            );
        }
    });
}

pub fn spectrum_time_freq_axes(
    ui: &mut egui::Ui,
    history: &VecDeque<(f64, crate::ui::viewdata::DorsalFrame)>,
    height: f32,
    window_start: f64,
    window_end: f64,
    link_group: Option<&str>,
) {
    let mut plot = Plot::new("time_freq_spectrum")
        .height(height)
        .allow_drag(true)
        .allow_scroll(true)
        .include_x(window_start)
        .include_x(window_end)
        .include_y(0.0)
        .include_y(3.0)
        .default_x_bounds(window_start, window_end)
        .default_y_bounds(0.0, 3.0)
        .x_axis_formatter(|mark, _| format!("{:.1} s", mark.value))
        .y_axis_formatter(|_, _| String::new());
    if let Some(link) = link_group {
        plot = plot.link_axis(Id::new(link), Vec2b::new(true, false));
    }

    plot.show(ui, |plot_ui| {
        let samples: Vec<(f64, crate::ui::viewdata::DorsalFrame)> = history
            .iter()
            .filter(|(t, _)| *t >= window_start && *t <= window_end)
            .map(|(t, d)| (*t, *d))
            .collect();
        if samples.len() < 2 {
            return;
        }

        let mut max_energy = 0.0f32;
        let mut max_flux = 0.0f32;
        for (_, d) in &samples {
            max_energy = max_energy.max(d.e_low).max(d.e_mid).max(d.e_high);
            max_flux = max_flux.max(d.flux);
        }
        let energy_scale = if max_energy > 0.0 {
            1.0 / max_energy
        } else {
            0.0
        };
        let flux_scale = if max_flux > 0.0 { 3.0 / max_flux } else { 0.0 };

        let band_specs = [
            (2.0f64, Color32::from_rgb(220, 60, 60), "high"),
            (1.0f64, Color32::from_rgb(220, 180, 60), "mid"),
            (0.0f64, Color32::from_rgb(60, 180, 80), "low"),
        ];

        for i in 0..(samples.len() - 1) {
            let (t0, d0) = samples[i];
            let (t1, _) = samples[i + 1];
            let x0 = t0;
            let x1 = t1.max(t0 + 0.0001);

            let vals = [d0.e_high, d0.e_mid, d0.e_low];
            for (band_idx, (y_base, base_color, _name)) in band_specs.iter().enumerate() {
                let intensity = (vals[band_idx] * energy_scale).clamp(0.0, 1.0);
                let alpha = (30.0 + 225.0 * intensity) as u8;
                let color = Color32::from_rgba_unmultiplied(
                    base_color.r(),
                    base_color.g(),
                    base_color.b(),
                    alpha,
                );
                let y0 = *y_base;
                let y1 = y0 + 1.0;
                let poly = vec![[x0, y0], [x1, y0], [x1, y1], [x0, y1]];
                plot_ui.polygon(
                    Polygon::new("", poly)
                        .fill_color(color)
                        .stroke(Stroke::NONE),
                );
            }
        }

        let flux_points: PlotPoints = samples
            .iter()
            .map(|(t, d)| [*t, (d.flux * flux_scale) as f64])
            .collect();
        plot_ui.line(
            Line::new("flux", flux_points)
                .color(Color32::from_rgb(140, 140, 140))
                .width(1.5),
        );
    });
}

/// Visualize neural rhythms (Delta/Theta/Alpha/Beta) as radial gauges.
pub fn neural_compass(
    ui: &mut egui::Ui,
    rhythms: &crate::core::modulation::NeuralRhythms,
    height: f32,
) {
    let color_delta = Color32::from_rgb(80, 180, 255);
    let color_theta = Color32::from_rgb(70, 225, 135);
    let color_alpha = Color32::from_rgb(255, 215, 60);
    let color_beta = Color32::from_rgb(255, 110, 90);
    let alpha_mag = 0.5 * (rhythms.theta.alpha + rhythms.delta.alpha);
    let beta_mag = rhythms.theta.beta.max(rhythms.delta.beta);
    let alpha_band = crate::core::modulation::RhythmBand {
        phase: 0.0,
        freq_hz: 0.0,
        mag: alpha_mag,
        alpha: alpha_mag,
        beta: beta_mag,
    };
    let beta_band = crate::core::modulation::RhythmBand {
        phase: 0.0,
        freq_hz: 0.0,
        mag: beta_mag,
        alpha: alpha_mag,
        beta: beta_mag,
    };
    let bands = [
        ("Delta", color_delta, rhythms.delta),
        ("Theta", color_theta, rhythms.theta),
        ("Alpha", color_alpha, alpha_band),
        ("Beta", color_beta, beta_band),
    ];

    let cheight = (height / 4.0) * 0.95;
    ui.vertical(|ui| {
        for (label, color, rhythm) in bands {
            let desired = egui::vec2(130.0, cheight);
            let (rect, _resp) = ui.allocate_exact_size(desired, egui::Sense::hover());
            let painter = ui.painter_at(rect);
            let center = rect.center();
            let radius = rect.width().min(rect.height()) * 0.45;

            // Background circle
            painter.circle_stroke(center, radius, Stroke::new(1.0, color.gamma_multiply(0.35)));
            painter.circle_filled(center, 2.0, Color32::WHITE);
            painter.circle_stroke(center, 2.0, Stroke::new(1.0, color.gamma_multiply(0.6)));
            let top = center + egui::vec2(0.0, -radius);
            painter.line_segment(
                [center, top],
                Stroke::new(1.0, Color32::WHITE.gamma_multiply(0.3)),
            );

            // Needle with log-style gain and a visible floor.
            let vis_mag =
                ((1.0f32 + (rhythm.mag * 50.0)).ln() / (1.0f32 + 50.0).ln()).clamp(0.35, 1.0);
            let length = radius * (0.3 + 0.7 * vis_mag);
            let angle = rhythm.phase - std::f32::consts::FRAC_PI_2;
            let tip = center + egui::vec2(angle.cos(), angle.sin()) * length;
            let thickness = 2.0 + 3.8 * vis_mag;
            painter.line_segment([center, tip], Stroke::new(thickness, color));

            // Label
            painter.text(
                rect.center_top() + egui::vec2(-40.0, 10.0),
                Align2::CENTER_TOP,
                label,
                FontId::proportional(12.0),
                color,
            );
        }
    });
}

/// Draw a mandala-style rhythm compass combining meter, beat, stability, and error without fast rotation.
pub fn draw_rhythm_mandala(
    ui: &mut egui::Ui,
    rhythms: &crate::core::modulation::NeuralRhythms,
    size: Vec2,
) {
    let side = size.x.min(size.y).clamp(80.0, 200.0);
    let _scale = (side / 150.0).clamp(0.6, 1.2);
    let (rect, _resp) = ui.allocate_exact_size(Vec2::splat(side), egui::Sense::hover());
    let painter = ui.painter_at(rect);

    let center = rect.center();
    let radius = rect.width().min(rect.height()) * 0.39;
    let start_angle = -std::f32::consts::FRAC_PI_2;
    let wrap = |p: f32| {
        let mut v = p % std::f32::consts::TAU;
        if v < 0.0 {
            v += std::f32::consts::TAU;
        }
        v
    };

    // Delta: orbiting marker outside the base ring.
    let get_visuals = |mag: f32, color: Color32| {
        let m = mag.clamp(0.0, 1.0);
        let alpha = 0.3 + 0.7 * m;
        let weight = m;
        (color.gamma_multiply(alpha), weight)
    };

    let color_delta = Color32::from_rgb(80, 180, 255);
    let color_theta = Color32::from_rgb(70, 225, 135);
    let color_alpha = Color32::from_rgb(255, 215, 60);
    let color_beta = Color32::from_rgb(255, 110, 90);

    // Delta: progress arc as the meter with magnitude-driven opacity/width.
    let delta_phase = wrap(rhythms.delta.phase);
    let outer_r = radius * 1.15;
    let (d_color, d_weight) = get_visuals(rhythms.delta.mag, color_delta);
    painter.circle_stroke(
        center,
        outer_r,
        Stroke::new(1.0, d_color.gamma_multiply(0.2)),
    );
    if delta_phase > 0.01 {
        let steps = (delta_phase * 12.0).max(2.0) as usize;
        let points: Vec<egui::Pos2> = (0..=steps)
            .map(|i| {
                let angle = start_angle + (delta_phase * i as f32 / steps as f32);
                center + egui::vec2(angle.cos(), angle.sin()) * outer_r
            })
            .collect();
        let width = 1.0 + d_weight * 3.0;
        painter.add(egui::Shape::line(points, Stroke::new(width, d_color)));
    }
    let delta_tip_angle = start_angle + delta_phase;
    let delta_tip_pos = center + egui::vec2(delta_tip_angle.cos(), delta_tip_angle.sin()) * outer_r;
    painter.circle_filled(delta_tip_pos, 2.0 + d_weight * 2.0, d_color);

    // Theta: base ring plus a slow cursor.
    let base_circle = Color32::from_gray(180);
    painter.circle_stroke(center, radius, Stroke::new(2.5, base_circle));
    let (t_color, t_weight) = get_visuals(rhythms.theta.mag, color_theta);
    let theta_angle = start_angle + wrap(rhythms.theta.phase);
    let theta_pos = center + egui::vec2(theta_angle.cos(), theta_angle.sin()) * radius;
    let dot_radius = 2.0 + t_weight * 3.0;
    painter.circle_filled(theta_pos, dot_radius, t_color);
    painter.circle_stroke(
        theta_pos,
        dot_radius + 1.0,
        Stroke::new(1.0, t_color.gamma_multiply(0.5)),
    );
    painter.circle_filled(center, 3.0, base_circle);

    // Alpha: stability axis along the vertical.
    let alpha_mag = (0.5 * (rhythms.theta.alpha + rhythms.delta.alpha)).clamp(0.0, 1.0);
    let alpha_vis = 0.25 + 0.75 * alpha_mag;
    let alpha_color = color_alpha.gamma_multiply(alpha_vis);
    let alpha_width = 2.0 + 6.0 * alpha_mag;
    painter.line_segment(
        [
            center + egui::vec2(0.0, -radius),
            center + egui::vec2(0.0, radius),
        ],
        Stroke::new(alpha_width, alpha_color),
    );

    // Beta: prediction error cross-grid.
    let beta_mag = rhythms.theta.beta.max(rhythms.delta.beta).clamp(0.0, 1.0);
    let beta_vis = 0.2 + 0.8 * beta_mag;
    let beta_color = color_beta.gamma_multiply(beta_vis);
    let beta_width = 1.5 + 6.0 * beta_mag;
    painter.line_segment(
        [
            center + egui::vec2(0.0, -radius),
            center + egui::vec2(0.0, radius),
        ],
        Stroke::new(beta_width, beta_color),
    );
    painter.line_segment(
        [
            center + egui::vec2(-radius, 0.0),
            center + egui::vec2(radius, 0.0),
        ],
        Stroke::new(beta_width, beta_color),
    );
}
</file>

<file path="src/lib.rs">
pub mod app;
pub mod audio;
pub mod cli;
pub mod config;
pub mod core;
pub mod life;
pub mod synth;
pub mod ui;
</file>

<file path="tests/gate_clock.rs">
use std::f32::consts::PI;

use conchordal::core::modulation::RhythmBand;
use conchordal::life::gate_clock::next_gate_tick;

fn band_with(phase: f32, freq_hz: f32) -> RhythmBand {
    RhythmBand {
        phase,
        freq_hz,
        mag: 0.0,
        alpha: 0.0,
        beta: 0.0,
    }
}

#[test]
fn next_gate_tick_always_future_when_some() {
    let fs = 48_000.0;
    let now_tick = 1000_u64;
    let target_phase = 0.0;
    let phases = [-PI, -PI + 1e-6, -0.1, 0.0, 0.1, PI - 1e-6, PI];
    let freqs = [0.1, 1.0, 4.0, 20.0];

    for &phase in &phases {
        for &freq_hz in &freqs {
            let theta = band_with(phase, freq_hz);
            let next_tick = next_gate_tick(now_tick, fs, theta, target_phase)
                .expect("expected Some for valid inputs");
            assert!(next_tick > now_tick);
        }
    }
}

#[test]
fn same_phase_goes_to_next_cycle() {
    let fs = 48_000.0;
    let now_tick = 1000_u64;
    let freq_hz = 4.0;
    let phase = 0.0;
    let theta = band_with(phase, freq_hz);
    let next = next_gate_tick(now_tick, fs, theta, phase).expect("expected Some");
    let expected = (fs / freq_hz).round() as u64;
    assert!(next > now_tick);
    let delta = next - now_tick;
    let diff = if delta > expected {
        delta - expected
    } else {
        expected - delta
    };
    assert!(diff <= 1, "delta={delta} expected={expected}");
}

#[test]
fn invalid_inputs_return_none() {
    let now_tick = 1000_u64;
    let target_phase = 0.0;
    let theta = band_with(0.0, 1.0);

    assert!(next_gate_tick(now_tick, 0.0, theta, target_phase).is_none());
    assert!(next_gate_tick(now_tick, -1.0, theta, target_phase).is_none());
    assert!(next_gate_tick(now_tick, f32::NAN, theta, target_phase).is_none());
    assert!(next_gate_tick(now_tick, f32::INFINITY, theta, target_phase).is_none());

    let theta_bad = band_with(0.0, 0.0);
    assert!(next_gate_tick(now_tick, 48_000.0, theta_bad, target_phase).is_none());
    let theta_bad = band_with(0.0, -1.0);
    assert!(next_gate_tick(now_tick, 48_000.0, theta_bad, target_phase).is_none());
    let theta_bad = band_with(0.0, f32::NAN);
    assert!(next_gate_tick(now_tick, 48_000.0, theta_bad, target_phase).is_none());
    let theta_bad = band_with(0.0, f32::INFINITY);
    assert!(next_gate_tick(now_tick, 48_000.0, theta_bad, target_phase).is_none());
}
</file>

<file path="tests/phonation_rate_is_time_based.rs">
use conchordal::life::phonation_engine::{
    AccumulatorInterval, CoreState, IntervalInput, PhonationInterval,
};

#[test]
fn phonation_rate_is_time_based() {
    let mut interval = AccumulatorInterval::new(1.0, 0, 1);
    let state = CoreState { is_alive: true };
    let dt_sec = 1.0 / 12.0;
    let tick_step = 10u64;
    let mut onsets = 0;
    for gate in 0..24u64 {
        let input = IntervalInput {
            gate,
            tick: gate * tick_step,
            dt_theta: 1.0,
            dt_sec,
            weight: 1.0,
        };
        if interval.on_candidate(&input, &state).is_some() {
            onsets += 1;
        }
    }
    assert!(
        (1..=3).contains(&onsets),
        "expected 1..=3 onsets, got {onsets}"
    );
}
</file>

<file path="tests/pitchcore_candidates.rs">
use conchordal::life::individual::{PitchCore, PitchHillClimbPitchCore};

#[test]
fn neighbors_produce_ratio_candidates() {
    let mut core = PitchHillClimbPitchCore::new(200.0, 440.0, 0.1, 0.1, 0.0, 0.5);
    let candidates = core.propose_freqs_hz_with_neighbors(440.0, &[440.0], 16, 8, 12.0);
    let has_fifth = candidates.iter().any(|&f| (f - 660.0_f32).abs() < 1.0_f32);
    let has_third = candidates.iter().any(|&f| (f - 550.0_f32).abs() < 1.0_f32);
    assert!(has_fifth || has_third, "expected ratio-derived candidate");
}

#[test]
fn fallback_generates_semitone_candidates() {
    let mut core = PitchHillClimbPitchCore::new(200.0, 440.0, 0.1, 0.1, 0.0, 0.5);
    let candidates = core.propose_freqs_hz_with_neighbors(440.0, &[], 12, 8, 12.0);
    assert!(candidates.len() >= 8);
}

#[test]
fn dedupe_is_deterministic() {
    let mut core = PitchHillClimbPitchCore::new(200.0, 440.0, 0.1, 0.1, 0.0, 0.5);
    let c1 = core.propose_freqs_hz_with_neighbors(440.0, &[440.0, 441.0], 16, 8, 1.0);
    let c2 = core.propose_freqs_hz_with_neighbors(440.0, &[440.0, 441.0], 16, 8, 1.0);
    assert_eq!(c1, c2);
}

#[test]
fn folded_candidates_stay_near_base_octave() {
    let mut core = PitchHillClimbPitchCore::new(200.0, 440.0, 0.1, 0.1, 0.0, 0.5);
    let base = 440.0_f32;
    let candidates = core.propose_freqs_hz_with_neighbors(base, &[220.0, 880.0], 24, 8, 12.0);
    for f in candidates {
        assert!(f >= base * 0.5 && f <= base * 2.0, "freq {f} out of range");
    }
}
</file>

<file path="tests/post_intent_action.rs">
use conchordal::core::log2space::Log2Space;
use conchordal::core::timebase::Timebase;
use conchordal::life::scenario::Action;
use conchordal::life::world_model::WorldModel;

#[test]
fn post_intent_applies_to_world_model() {
    let timebase = Timebase {
        fs: 48_000.0,
        hop: 512,
    };
    let space = Log2Space::new(55.0, 8000.0, 96);
    let mut world = WorldModel::new(timebase, space);
    let action = Action::PostIntent {
        source_id: 7,
        onset_sec: 1.0,
        duration_sec: 0.5,
        freq_hz: 440.0,
        amp: 0.5,
        tag: Some("test".to_string()),
        confidence: 0.8,
    };
    world.apply_action(&action);

    let view = world.ui_view();
    assert_eq!(view.intents.len(), 1);
    assert_eq!(view.intents[0].onset_tick, timebase.sec_to_tick(1.0));
    assert_eq!(view.intents[0].dur_tick, timebase.sec_to_tick(0.5));
}
</file>

<file path="tests/samples_no_legacy_keys.rs">
use std::fs;
use std::path::{Path, PathBuf};

const PLAN_A: &str = "plan";
const PLAN_B: &str = "ning";
const BIRTH_A: &str = "on";
const BIRTH_B: &str = "_birth";
const SUSTAIN_A: &str = "sustain";
const SUSTAIN_B: &str = "_update";
const TIMING_A: &str = "ti";
const TIMING_B: &str = "ming";

fn collect_sample_files(root: &Path, out: &mut Vec<PathBuf>) {
    let entries = match fs::read_dir(root) {
        Ok(entries) => entries,
        Err(err) => panic!("failed to read {:?}: {err}", root),
    };
    for entry in entries {
        let entry = entry.expect("sample entry");
        let path = entry.path();
        if path.is_dir() {
            collect_sample_files(&path, out);
            continue;
        }
        let ext = path.extension().and_then(|s| s.to_str()).unwrap_or("");
        if matches!(ext, "rhai" | "json" | "yaml" | "yml") {
            out.push(path);
        }
    }
}

#[test]
fn samples_have_no_legacy_keys() {
    let root = Path::new("samples");
    let mut files = Vec::new();
    collect_sample_files(root, &mut files);
    assert!(!files.is_empty(), "no sample files found under {root:?}");

    let banned_raw = [
        format!("{PLAN_A}{PLAN_B}"),
        format!("{BIRTH_A}{BIRTH_B}"),
        format!("{SUSTAIN_A}{SUSTAIN_B}"),
    ];
    let phonation_key = ["pho", "nation"].concat();
    let quote = "\"";
    let mut banned_compact = Vec::new();
    let timing_key = format!("{TIMING_A}{TIMING_B}");
    banned_compact.push(format!("{timing_key}:{quote}"));
    banned_compact.push(format!("{quote}{timing_key}{quote}:"));
    for value in ["once", "off", "immediate"] {
        banned_compact.push(format!("{phonation_key}:{quote}{value}{quote}"));
        banned_compact.push(format!(
            "{quote}{phonation_key}{quote}:{quote}{value}{quote}"
        ));
    }

    for path in files {
        let contents = fs::read_to_string(&path)
            .unwrap_or_else(|err| panic!("failed to read {:?}: {err}", path));
        for token in &banned_raw {
            assert!(
                !contents.contains(token),
                "legacy token \"{token}\" found in {path:?}"
            );
        }
        let compact: String = contents.chars().filter(|c| !c.is_whitespace()).collect();
        for token in &banned_compact {
            assert!(
                !compact.contains(token),
                "legacy token \"{token}\" found in {path:?}"
            );
        }
    }
}
</file>

<file path="tests/samples_parse.rs">
use std::path::PathBuf;

use conchordal::life::scripting::ScriptHost;

#[test]
fn samples_parse_successfully() {
    let mut stack = vec![PathBuf::from("samples")];
    let mut found = false;
    while let Some(dir) = stack.pop() {
        for entry in std::fs::read_dir(&dir).expect("samples dir exists") {
            let path = entry.expect("dir entry").path();
            let name = path
                .file_name()
                .and_then(|s| s.to_str())
                .unwrap_or_default()
                .to_string();
            if name.starts_with('#') || name.starts_with('.') || name.ends_with('~') {
                continue;
            }
            if path.is_dir() {
                stack.push(path);
                continue;
            }
            if path.extension().and_then(|s| s.to_str()) != Some("rhai") {
                continue;
            }
            found = true;
            ScriptHost::load_script(path.to_str().expect("path str"))
                .unwrap_or_else(|e| panic!("script {name} should parse: {e}"));
        }
    }
    assert!(found, "no sample scripts found under samples/");
}
</file>

<file path="src/audio/output.rs">
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};

use anyhow::Context;
use ringbuf::traits::*;
use ringbuf::{HeapCons, HeapProd, HeapRb};
use tracing::{debug, info};

/// Module for connecting to the output device.
pub struct AudioOutput {
    stream: Option<cpal::Stream>,
    pub config: cpal::StreamConfig,
}

impl AudioOutput {
    /// Start AudioOutput and return a Producer for the worker loop.
    pub fn new(latency_ms: f32) -> anyhow::Result<(Self, HeapProd<f32>)> {
        let host = cpal::default_host();
        let device = host
            .default_output_device()
            .context("No default output device")?;

        let supported_config = device
            .default_output_config()
            .context("No default config")?;
        let sample_rate = supported_config.sample_rate();
        let channels = supported_config.channels();

        let config = cpal::StreamConfig {
            channels,
            sample_rate,
            buffer_size: cpal::BufferSize::Default,
        };

        let target_frames = (sample_rate as f32 * latency_ms / 1000.0).round().max(1.0) as usize;
        let min_frames = match supported_config.buffer_size() {
            cpal::SupportedBufferSize::Range { min, .. } => (*min as usize) * 2,
            cpal::SupportedBufferSize::Unknown => 512,
        };
        let capacity_frames = (target_frames * 2).max(min_frames);
        if capacity_frames > target_frames * 2 {
            info!(
                "Audio buffer raised to min frames: target={} actual={} (sr={} ch={})",
                target_frames * 2,
                capacity_frames,
                sample_rate,
                channels
            );
        }
        info!(
            "Audio buffer config: sr={} ch={} target_frames={} capacity_frames={}",
            sample_rate, channels, target_frames, capacity_frames
        );
        let rb = HeapRb::<f32>::new(capacity_frames);
        let (prod, mut cons): (HeapProd<f32>, HeapCons<f32>) = rb.split();

        let stream = device
            .build_output_stream(
                &config,
                move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
                    let n_frames = data.len() / channels as usize;

                    for frame in 0..n_frames {
                        // Pop one frame of samples.
                        let s = cons.try_pop().unwrap_or(0.0);

                        // Mono: copy to all channels.
                        for ch in 0..channels {
                            data[frame * channels as usize + ch as usize] = s;
                        }
                    }
                },
                |err| eprintln!("Stream error: {:?}", err),
                None,
            )
            .context("Failed to build output stream")?;
        stream.play().context("Failed to start output stream")?;

        Ok((
            Self {
                stream: Some(stream),
                config,
            },
            prod,
        ))
    }

    pub fn stop(&mut self) {
        self.stream.take(); // take and Drop
    }

    /// Worker loop pushes new samples.
    pub fn push_samples(prod: &mut HeapProd<f32>, samples: &[f32]) {
        let mut offset = 0;
        while offset < samples.len() {
            let written = prod.push_slice(&samples[offset..]);
            offset += written;

            if offset < samples.len() {
                std::thread::sleep(std::time::Duration::from_micros(200));
            }
        }
    }

    // pub fn buffered_samples(&self) -> usize {
    //     self._rb.occupied_len()
    // }

    // pub fn capacity(&self) -> usize {
    //     self._rb.capacity().get()
    // }
}

impl Drop for AudioOutput {
    fn drop(&mut self) {
        if self.stream.is_some() {
            debug!("AudioOutput drop: stopping CPAL stream.");
        }
        self.stream.take();
    }
}
</file>

<file path="src/core/nsgt.rs">
//! core/nsgt.rs — Log2-axis Non-Stationary Gabor (analysis-only, Goertzel-based)
//!
//! Overview
//! --------
//! - Uses [`Log2Space`] grid between [fmin, fmax] with `bins_per_oct` resolution.
//! - Band-dependent window length: L_k = ceil(Q * fs / f_k), Q = 1/(2^(1/B)-1).
//! - Analysis via windowed Goertzel per band & frame.
//!
//! Notes
//! -----
//! - Analysis-only (no dual frames yet).
//! - Designed for Conchordal: downstream modules use log2-axis envelopes or analytic signals.
//! - Window: periodic Hann, overlap ≥ 50% recommended.
//!
//! Performance
//! -----------
//! - Goertzel avoids per-frame FFT overhead, efficient for sparse-band constant-Q.
//! - Dense or long-window use cases may prefer batched FFT (TODO).

use crate::core::log2space::Log2Space;
use rustfft::num_complex::Complex32;

// =====================================================
// Config structures
// =====================================================

/// NSGT configuration (log2-axis, analysis-only).
#[derive(Clone, Copy, Debug)]
pub struct NsgtLog2Config {
    /// Sampling rate [Hz]
    pub fs: f32,
    /// Overlap ratio in [0, 0.95). 0.5 = 50% overlap (default-good)
    pub overlap: f32,
}

impl Default for NsgtLog2Config {
    fn default() -> Self {
        Self {
            fs: 48_000.0,
            overlap: 0.5,
        }
    }
}

/// Band descriptor on log2 axis.
#[derive(Clone, Debug)]
pub struct NsgtBand {
    pub f_hz: f32,
    pub win_len: usize,
    pub hop: usize,
    pub window: Vec<f32>,
    pub log2_hz: f32,
    pub q: f32,
}

/// Analysis result for one band.
#[derive(Clone, Debug)]
pub struct BandCoeffs {
    pub coeffs: Vec<Complex32>,
    pub t_sec: Vec<f32>,
    pub f_hz: f32,
    pub log2_hz: f32,
    pub win_len: usize,
    pub hop: usize,
}

// =====================================================
// Analyzer core
// =====================================================

#[derive(Clone, Debug)]
pub struct NsgtLog2 {
    pub cfg: NsgtLog2Config,
    pub bands: Vec<NsgtBand>,
    pub space: Log2Space,
}

impl NsgtLog2 {
    /// Construct analyzer with log2-spaced bands and band-dependent windows.
    pub fn new(cfg: NsgtLog2Config, space: Log2Space) -> Self {
        assert!(
            cfg.overlap >= 0.0 && cfg.overlap < 0.95,
            "Overlap must be in [0,0.95)"
        );

        let fs = cfg.fs;
        let bpo = space.bins_per_oct as f32;
        let q = 1.0 / (2f32.powf(1.0 / bpo) - 1.0);

        // --- use given log2-space to define band centers
        let bands: Vec<NsgtBand> = space
            .centers_hz
            .iter()
            .zip(space.centers_log2.iter())
            .map(|(&f, &log2_f)| {
                let mut win_len = (q * fs / f).ceil() as usize;
                win_len = win_len.max(16);
                if win_len.is_multiple_of(2) {
                    win_len += 1;
                }
                let hop = ((1.0 - cfg.overlap) * win_len as f32).round().max(1.0) as usize;
                let window = crate::core::fft::hann_window_periodic(win_len);
                NsgtBand {
                    f_hz: f,
                    win_len,
                    hop,
                    window,
                    log2_hz: log2_f,
                    q,
                }
            })
            .collect();

        Self {
            cfg,
            bands,
            space: space.clone(),
        }
    }

    pub fn bands(&self) -> &[NsgtBand] {
        &self.bands
    }

    pub fn space(&self) -> &Log2Space {
        &self.space
    }

    pub fn freqs_hz(&self) -> Vec<f32> {
        self.space.centers_hz.clone()
    }

    pub fn hop_s(&self) -> f32 {
        let mean_hop =
            self.bands.iter().map(|b| b.hop as f32).sum::<f32>() / self.bands.len().max(1) as f32;
        mean_hop / self.cfg.fs
    }

    /// Full NSGT analysis returning complex coefficients per band.
    pub fn analyze(&self, signal: &[f32]) -> Vec<BandCoeffs> {
        let n = signal.len();
        if n == 0 {
            return Vec::new();
        }
        let fs = self.cfg.fs;
        let mut out = Vec::with_capacity(self.bands.len());
        for b in &self.bands {
            let (coeffs, t_idx) = analyze_band_goertzel(signal, fs, b);
            let t_sec = t_idx.into_iter().map(|i| i as f32 / fs).collect();
            out.push(BandCoeffs {
                coeffs,
                t_sec,
                f_hz: b.f_hz,
                log2_hz: b.log2_hz,
                win_len: b.win_len,
                hop: b.hop,
            });
        }
        out
    }

    /// Mean envelope magnitude per band (for perc_potential_R roughness kernels).
    pub fn analyze_envelope(&self, signal: &[f32]) -> Vec<f32> {
        let bands = self.analyze(signal);
        let amps: Vec<f32> = bands
            .iter()
            .map(|b| {
                if b.coeffs.is_empty() {
                    0.0
                } else {
                    b.coeffs.iter().map(|z| z.norm()).sum::<f32>() / b.coeffs.len() as f32
                }
            })
            .collect();
        amps
    }

    /// Representative analytic vector per band (for perc_potential_H kernels).
    pub fn analyze_flattened(&self, signal: &[f32]) -> Vec<Complex32> {
        self.analyze(signal)
            .iter()
            .filter_map(|b| b.coeffs.get(b.coeffs.len() / 2).copied())
            .collect()
    }

    /// Compute PSD-like estimate from an existing `analyze()` result.
    pub fn analyze_psd_from_bands(&self, bands: &[BandCoeffs]) -> Vec<f32> {
        if bands.is_empty() {
            return Vec::new();
        }

        let mut psd_vals = Vec::with_capacity(bands.len());

        for b in bands {
            if b.coeffs.is_empty() {
                psd_vals.push(0.0);
                continue;
            }

            // (1) mean power
            let mean_pow =
                b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / (b.coeffs.len().max(1) as f32);

            // (2) bandwidth
            let bw_hz = self.space.bandwidth_hz(b.f_hz);

            // (3) moderate correction → multiply by sqrt(Δf)
            let psd_adj = mean_pow * bw_hz.sqrt();

            psd_vals.push(psd_adj);
        }

        psd_vals
    }

    /// Convenience version: run full analysis and return PSD directly.
    pub fn analyze_psd(&self, signal: &[f32]) -> Vec<f32> {
        let bands = self.analyze(signal);
        self.analyze_psd_from_bands(&bands)
    }
}

// =====================================================
// Internal utilities
// =====================================================

// /// Windowed Goertzel per band across time.
fn analyze_band_goertzel(x: &[f32], fs: f32, band: &NsgtBand) -> (Vec<Complex32>, Vec<usize>) {
    let n = x.len();
    let win_len = band.win_len;
    let h = band.hop;
    let f = band.f_hz;
    let omega = 2.0 * std::f32::consts::PI * f / fs;

    let mut centers = Vec::new();
    let mut c = win_len / 2;
    while c + win_len / 2 <= n + (win_len / 2) {
        centers.push(c);
        c += h;
        if c == 0 {
            break;
        }
    }

    let mut coeffs = Vec::with_capacity(centers.len());
    for &c in &centers {
        let start = c.saturating_sub(win_len / 2);
        let mut acc_re = 0.0;
        let mut acc_im = 0.0;
        for i in 0..win_len {
            let xi = if start + i < n { x[start + i] } else { 0.0 };
            let w = band.window[i];
            let ph = omega * (start + i) as f32;
            acc_re += xi * w * ph.cos();
            acc_im -= xi * w * ph.sin();
        }
        let norm = (2.0 / win_len as f32).sqrt();
        coeffs.push(Complex32::new(acc_re * norm, acc_im * norm));
    }
    (coeffs, centers)
}

// =====================================================
// Tests
// =====================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::log2space::Log2Space;
    use approx::assert_relative_eq;

    fn mk_sine(fs: f32, f: f32, secs: f32) -> Vec<f32> {
        let n = (fs * secs).round() as usize;
        (0..n)
            .map(|i| (2.0 * std::f32::consts::PI * f * (i as f32) / fs).sin())
            .collect()
    }

    #[test]
    fn pure_tone_hits_right_band() {
        let fs = 48_000.0;
        let nsgt = NsgtLog2::new(
            NsgtLog2Config { fs, overlap: 0.5 },
            Log2Space::new(20.0, 8000.0, 48),
        );
        let sig = mk_sine(fs, 440.0, 1.0);
        let bands = nsgt.analyze(&sig);

        let (mut best_f, mut best_val) = (0.0, 0.0);
        for b in &bands {
            let p =
                b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / (b.coeffs.len().max(1) as f32);
            if p > best_val {
                best_val = p;
                best_f = b.f_hz;
            }
        }
        let cents = 1200.0 * ((best_f / 440.0).log2().abs());
        assert!(
            cents < 60.0,
            "440Hz peak band off by {:.1} cents (f={:.2})",
            cents,
            best_f
        );
    }

    #[test]
    fn window_len_monotonic_vs_freq() {
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 48));
        for w in nsgt.bands.windows(2) {
            if w[0].f_hz < w[1].f_hz {
                assert!(w[0].win_len >= w[1].win_len);
            }
        }
    }

    #[test]
    fn empty_signal_returns_empty() {
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 48));
        let out = nsgt.analyze(&[]);
        assert!(out.is_empty());
    }

    #[test]
    fn low_vs_high_freq_energy_scaling() {
        let fs = 48000.0;
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig_low = mk_sine(fs, 220.0, 1.0);
        let sig_high = mk_sine(fs, 1760.0, 1.0);
        let p_low = nsgt
            .analyze(&sig_low)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let p_high = nsgt
            .analyze(&sig_high)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let ratio = p_high / p_low;
        assert_relative_eq!(ratio, 1.0, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn amplitude_linearity() {
        let fs = 48000.0;
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig1 = mk_sine(fs, 440.0, 1.0);
        let sig2: Vec<f32> = sig1.iter().map(|v| v * 2.0).collect();

        let e1 = nsgt
            .analyze(&sig1)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let e2 = nsgt
            .analyze(&sig2)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        assert_relative_eq!(e2 / e1, 4.0, epsilon = 0.1, max_relative = 0.1);
    }
    #[test]
    fn time_invariance_of_magnitude() {
        let fs = 48000.0;
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig = mk_sine(fs, 440.0, 1.0);
        let shift = (0.1 * fs) as usize;
        let mut sig_shifted = vec![0.0; shift];
        sig_shifted.extend_from_slice(&sig);

        let amp1 = nsgt.analyze_envelope(&sig);
        let amp2 = nsgt.analyze_envelope(&sig_shifted);
        let corr: f32 = amp1.iter().zip(&amp2).map(|(a, b)| a * b).sum::<f32>()
            / (amp1.iter().map(|a| a * a).sum::<f32>().sqrt()
                * amp2.iter().map(|b| b * b).sum::<f32>().sqrt());
        assert!(
            corr > 0.95,
            "Magnitude envelope correlation should be high (corr={corr:.3})"
        );
    }

    #[test]
    fn hop_size_stability() {
        let fs = 48000.0;
        let space = Log2Space::new(20.0, 8000.0, 96);
        let sig = mk_sine(fs, 440.0, 1.0);

        let e_mean = |overlap: f32| {
            let nsgt = NsgtLog2::new(NsgtLog2Config { fs, overlap }, space.clone());
            let out = nsgt.analyze(&sig);
            let sum_e: f32 = out
                .iter()
                .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
                .sum();
            let n_frames: usize = out.iter().map(|b| b.coeffs.len()).max().unwrap_or(1);
            sum_e / n_frames as f32
        };

        let e_half = e_mean(0.5);
        let e_75 = e_mean(0.75);

        assert_relative_eq!(e_half, e_75, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn band_count_matches_space() {
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), space.clone());
        assert_eq!(
            nsgt.bands().len(),
            space.centers_hz.len(),
            "Band count must match Log2Space bin count"
        );
    }

    // #[test]
    // #[ignore]
    // fn plot_nsgt_spectrum() {
    //     use plotters::prelude::*;

    //     let fs = 48000.0;
    //     let nsgt = NsgtLog2::new(
    //         NsgtLog2Config { fs, overlap: 0.5 },
    //         Log2Space::new(20.0, 8000.0, 96),
    //     );

    //     // === 1. Test signal (pure 440 Hz) ===
    //     let sig = mk_sine(fs, 440.0, 1.0);

    //     // === 2. NSGT analysis ===
    //     let bands = nsgt.analyze(&sig);

    //     // === 3. Mean energy per band in log2 axis ===
    //     let points: Vec<(f32, f32)> = bands
    //         .iter()
    //         .map(|b| {
    //             let p = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
    //                 / (b.coeffs.len().max(1) as f32);
    //             (b.log2_hz, p)
    //         })
    //         .collect();

    //     // === 4. Output target ===
    //     let root = BitMapBackend::new("target/nsgt_spectrum.png", (1500, 1000)).into_drawing_area();
    //     root.fill(&WHITE).unwrap();
    //     let mut chart = ChartBuilder::on(&root)
    //         .caption("NSGT Spectrum (pure 440Hz)", ("sans-serif", 18))
    //         .margin(10)
    //         .x_label_area_size(40)
    //         .y_label_area_size(50)
    //         .build_cartesian_2d(
    //             (20f32.log2())..(8000f32.log2()),
    //             0f32..points.iter().map(|(_, p)| *p).fold(0.0f32, f32::max) * 1.1,
    //         )
    //         .unwrap();

    //     chart
    //         .configure_mesh()
    //         .x_desc("log2(frequency) [oct]")
    //         .y_desc("mean power")
    //         .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
    //         .draw()
    //         .unwrap();

    //     chart
    //         .draw_series(LineSeries::new(points.iter().cloned(), &BLUE))
    //         .unwrap()
    //         .label("power")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &BLUE));

    //     chart
    //         .configure_series_labels()
    //         .border_style(&BLACK)
    //         .draw()
    //         .unwrap();
    //     root.present().unwrap();

    //     println!("Saved plot to target/nsgt_spectrum.png");
    // }

    // #[test]
    // #[ignore]
    // fn plot_nsgt_log2_noise_response() {
    //     use plotters::prelude::*;
    //     use rand::Rng;
    //     use scirs2_signal::waveforms::{brown_noise, pink_noise};

    //     let fs = 48_000.0;
    //     let secs = 4.0;
    //     let n = (fs * secs) as usize;

    //     // === 1. NSGT setup ===
    //     let nsgt = NsgtLog2::new(
    //         NsgtLog2Config { fs, overlap: 0.5 },
    //         Log2Space::new(35.0, 24_000.0, 96),
    //     );

    //     // === 2. Generate noise ===
    //     let mut rng = rand::rng();
    //     let white: Vec<f32> = (0..n).map(|_| rng.random_range(-1.0f32..1.0)).collect();
    //     let pink: Vec<f32> = pink_noise(n, Some(42))
    //         .unwrap()
    //         .iter()
    //         .map(|&v| v as f32)
    //         .collect();
    //     let brown: Vec<f32> = brown_noise(n, Some(42))
    //         .unwrap()
    //         .iter()
    //         .map(|&v| v as f32)
    //         .collect();

    //     // === 3. Full analysis ===
    //     let bands_w = nsgt.analyze(&white);
    //     let bands_p = nsgt.analyze(&pink);
    //     let bands_b = nsgt.analyze(&brown);

    //     // === 4. PSD normalization (power per Hz) ===
    //     let psd_norm = |bands: &[BandCoeffs]| -> Vec<f32> {
    //         bands
    //             .iter()
    //             .map(|b| {
    //                 let mean_pow = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
    //                     / (b.coeffs.len().max(1) as f32);
    //                 let bw = nsgt
    //                     .space()
    //                     .delta_hz_at(b.f_hz)
    //                     .unwrap_or(fs / (b.win_len as f32));
    //                 mean_pow / bw.max(1e-9)
    //             })
    //             .collect()
    //     };

    //     let psd_w = psd_norm(&bands_w);
    //     let psd_p = psd_norm(&bands_p);
    //     let psd_b = psd_norm(&bands_b);

    //     // === 5. Convert to dB [re power/Hz] ===
    //     let to_db =
    //         |x: &[f32]| -> Vec<f32> { x.iter().map(|v| 10.0 * v.max(1e-20).log10()).collect() };
    //     let white_db = to_db(&psd_w);
    //     let pink_db = to_db(&psd_p);
    //     let brown_db = to_db(&psd_b);
    //     let log2x = nsgt.space().centers_log2.clone();

    //     // === 6. Output ===
    //     let root =
    //         BitMapBackend::new("target/nsgt_noise_psd_db.png", (1500, 1000)).into_drawing_area();
    //     root.fill(&WHITE).unwrap();

    //     let y_min = white_db
    //         .iter()
    //         .chain(&pink_db)
    //         .chain(&brown_db)
    //         .cloned()
    //         .fold(f32::INFINITY, f32::min);
    //     let y_max = white_db
    //         .iter()
    //         .chain(&pink_db)
    //         .chain(&brown_db)
    //         .cloned()
    //         .fold(f32::NEG_INFINITY, f32::max);

    //     let mut chart = ChartBuilder::on(&root)
    //         .caption("NSGT PSD (White / Pink / Brown Noise)", ("sans-serif", 18))
    //         .margin(10)
    //         .x_label_area_size(40)
    //         .y_label_area_size(60)
    //         .build_cartesian_2d(
    //             (20f32.log2())..(24_000f32.log2()),
    //             (y_min - 10.0)..(y_max + 10.0),
    //         )
    //         .unwrap();

    //     chart
    //         .configure_mesh()
    //         .x_desc("log2(frequency) [oct]")
    //         .y_desc("Power Spectral Density [dB re 1/Hz]")
    //         .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
    //         .draw()
    //         .unwrap();

    //     // === 7. Plot ===
    //     chart
    //         .draw_series(LineSeries::new(
    //             log2x.iter().cloned().zip(white_db.iter().cloned()),
    //             &BLUE,
    //         ))
    //         .unwrap()
    //         .label("White")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &BLUE));

    //     chart
    //         .draw_series(LineSeries::new(
    //             log2x.iter().cloned().zip(pink_db.iter().cloned()),
    //             &RED,
    //         ))
    //         .unwrap()
    //         .label("Pink")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &RED));

    //     chart
    //         .draw_series(LineSeries::new(
    //             log2x.iter().cloned().zip(brown_db.iter().cloned()),
    //             &GREEN,
    //         ))
    //         .unwrap()
    //         .label("Brown")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &GREEN));

    //     chart
    //         .configure_series_labels()
    //         .border_style(&BLACK)
    //         .background_style(&WHITE.mix(0.8))
    //         .draw()
    //         .unwrap();

    //     root.present().unwrap();
    //     println!("Saved plot to target/nsgt_noise_psd_db.png");
    // }
}
</file>

<file path="src/core/psycho_state.rs">
use crate::core::density;
use crate::core::landscape::LandscapeParams;
use crate::core::log2space::Log2Space;
use crate::core::roughness_kernel::erb_grid;

#[derive(Clone, Copy, Debug)]
pub struct RoughnessRef {
    pub total: f32,
    pub peak: f32,
}

#[derive(Clone, Copy, Debug)]
pub struct HarmonicityRef {
    pub max: f32,
}

#[inline]
pub fn clamp01(x: f32) -> f32 {
    x.clamp(0.0, 1.0)
}

#[inline]
pub fn clamp_pm1(x: f32) -> f32 {
    x.clamp(-1.0, 1.0)
}

/// Normalize a density curve for potential scans, returning (normalized, mass).
pub fn normalize_density(density_vals: &[f32], du: &[f32], eps: f32) -> (Vec<f32>, f32) {
    let mass = density::density_to_mass(density_vals, du);
    if mass <= eps {
        return (vec![0.0; density_vals.len()], mass);
    }
    let inv = 1.0 / (mass + eps);
    let norm = density_vals.iter().map(|&v| v * inv).collect();
    (norm, mass)
}

/// Convert roughness ratio (relative to reference) into normalized state [0, 1].
pub fn roughness_ratio_to_state01(ratio: f32, k: f32) -> f32 {
    if ratio.is_nan() {
        return 0.0;
    }
    if ratio.is_infinite() {
        return if ratio.is_sign_positive() { 1.0 } else { 0.0 };
    }
    let ratio = ratio.max(0.0);
    let k = if k.is_finite() { k.max(1e-6) } else { 1e-6 };
    let r_ref = 1.0 / (1.0 + k);
    if ratio <= 0.0 {
        0.0
    } else if ratio < 1.0 {
        (ratio * r_ref).clamp(0.0, 1.0)
    } else {
        let denom = ratio + k;
        if denom <= 0.0 {
            return 1.0;
        }
        (1.0 - k / denom).clamp(0.0, 1.0)
    }
}

pub fn r_pot_scan_to_r_state01_scan(r_pot_scan: &[f32], r_ref_peak: f32, k: f32, out: &mut [f32]) {
    debug_assert_eq!(out.len(), r_pot_scan.len());
    let denom = if r_ref_peak.is_finite() && r_ref_peak > 0.0 {
        r_ref_peak
    } else {
        1.0
    };
    let len = out.len().min(r_pot_scan.len());
    for i in 0..len {
        let ratio = r_pot_scan[i] / denom;
        out[i] = roughness_ratio_to_state01(ratio, k);
    }
}

pub fn h_pot_scan_to_h_state01_scan(h_pot_scan: &[f32], h_ref_max: f32, out: &mut [f32]) {
    debug_assert_eq!(out.len(), h_pot_scan.len());
    let denom = if h_ref_max.is_finite() && h_ref_max > 0.0 {
        h_ref_max
    } else {
        1.0
    };
    let len = out.len().min(h_pot_scan.len());
    for i in 0..len {
        out[i] = clamp01(h_pot_scan[i] / denom);
    }
}

pub fn compose_c_statepm1(h_state01: f32, r_state01: f32, w_r: f32) -> (f32, f32) {
    let h01 = clamp01(h_state01);
    let r01 = clamp01(r_state01);
    let c_signed = clamp_pm1(h01 - w_r * r01);
    let c01 = clamp01((c_signed + 1.0) * 0.5);
    (c_signed, c01)
}

pub fn compose_c_statepm1_scan(h_state01: &[f32], r_state01: &[f32], w_r: f32, out: &mut [f32]) {
    debug_assert_eq!(h_state01.len(), r_state01.len());
    debug_assert_eq!(out.len(), h_state01.len());
    let len = out.len().min(h_state01.len()).min(r_state01.len());
    for i in 0..len {
        let (c_signed, _) = compose_c_statepm1(h_state01[i], r_state01[i], w_r);
        out[i] = c_signed;
    }
}

pub fn roughness_ref_from_r_pot_scan(r_pot_scan: &[f32], du: &[f32]) -> RoughnessRef {
    debug_assert_eq!(r_pot_scan.len(), du.len());
    let peak = r_pot_scan.iter().copied().fold(0.0f32, f32::max);
    let total = density::density_to_mass(r_pot_scan, du);
    RoughnessRef { total, peak }
}

pub fn build_roughness_reference_density(params: &LandscapeParams, space: &Log2Space) -> Vec<f32> {
    let (erb, du) = erb_grid(space);
    if erb.is_empty() {
        return Vec::new();
    }
    let f0 = params.roughness_ref_f0_hz.max(1.0);
    let a = nearest_bin_by_freq(space, f0);
    let target_erb = erb[a] + params.roughness_ref_sep_erb;
    let mut b = nearest_bin_by_erb(&erb, target_erb);
    if b == a && erb.len() > 1 {
        b = if a + 1 < erb.len() {
            a + 1
        } else {
            a.saturating_sub(1)
        };
    }

    let mut ref_density = vec![0.0f32; erb.len()];
    let m_a = params.roughness_ref_mass_split.clamp(0.0, 1.0);
    let m_b = 1.0 - m_a;
    if du[a] > 0.0 {
        ref_density[a] += m_a / du[a];
    }
    if b != a && du[b] > 0.0 {
        ref_density[b] += m_b / du[b];
    } else if b == a && du[a] > 0.0 {
        ref_density[a] += m_b / du[a];
    }

    ref_density
}

pub fn compute_roughness_reference(params: &LandscapeParams, space: &Log2Space) -> RoughnessRef {
    let eps = params.roughness_ref_eps.max(1e-12);
    let ref_density = build_roughness_reference_density(params, space);
    let (r_pot_scan, r_total) = params
        .roughness_kernel
        .potential_r_from_log2_spectrum_density(&ref_density, space);
    let (_erb, du) = erb_grid(space);
    let mut ref_vals = roughness_ref_from_r_pot_scan(&r_pot_scan, &du);
    ref_vals.total = r_total.max(eps);
    ref_vals.peak = ref_vals.peak.max(eps);
    ref_vals
}

fn nearest_bin_by_freq(space: &Log2Space, f0: f32) -> usize {
    let mut best = 0;
    let mut best_diff = f32::MAX;
    for (i, &f) in space.centers_hz.iter().enumerate() {
        let diff = (f - f0).abs();
        if diff < best_diff {
            best_diff = diff;
            best = i;
        }
    }
    best
}

fn nearest_bin_by_erb(erb: &[f32], target: f32) -> usize {
    let mut best = 0;
    let mut best_diff = f32::MAX;
    for (i, &u) in erb.iter().enumerate() {
        let diff = (u - target).abs();
        if diff < best_diff {
            best_diff = diff;
            best = i;
        }
    }
    best
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::harmonicity_kernel::{HarmonicityKernel, HarmonicityParams};
    use crate::core::landscape::RoughnessScalarMode;
    use crate::core::log2space::Log2Space;
    use crate::core::roughness_kernel::{KernelParams, RoughnessKernel};

    fn build_params(space: &Log2Space) -> LandscapeParams {
        LandscapeParams {
            fs: 48_000.0,
            max_hist_cols: 1,
            alpha: 0.0,
            roughness_kernel: RoughnessKernel::new(KernelParams::default(), 0.005),
            harmonicity_kernel: HarmonicityKernel::new(space, HarmonicityParams::default()),
            roughness_scalar_mode: RoughnessScalarMode::Total,
            roughness_half: 0.1,
            consonance_roughness_weight: 0.5,
            loudness_exp: 1.0,
            ref_power: 1.0,
            tau_ms: 1.0,
            roughness_k: 1.0,
            roughness_ref_f0_hz: 1000.0,
            roughness_ref_sep_erb: 0.25,
            roughness_ref_mass_split: 0.5,
            roughness_ref_eps: 1e-12,
        }
    }

    #[test]
    fn roughness_ref_matches_reference_scan() {
        let space = Log2Space::new(80.0, 8000.0, 96);
        let params = build_params(&space);
        let ref_density = build_roughness_reference_density(&params, &space);
        let (r_pot_scan, r_total) = params
            .roughness_kernel
            .potential_r_from_log2_spectrum_density(&ref_density, &space);
        let (_erb, du) = erb_grid(&space);
        let ref_vals = roughness_ref_from_r_pot_scan(&r_pot_scan, &du);
        let legacy_total = density::density_to_mass(&r_pot_scan, &du);
        let legacy_peak = r_pot_scan.iter().copied().fold(0.0f32, f32::max);
        assert!((ref_vals.total - legacy_total).abs() < 1e-6);
        assert!((ref_vals.peak - legacy_peak).abs() < 1e-6);
        let ref_from_kernel = compute_roughness_reference(&params, &space);
        assert!((ref_from_kernel.total - r_total).abs() < 1e-6);
    }

    #[test]
    fn roughness_ratio_state01_matches() {
        let k: f32 = 0.3;
        let legacy = |ratio: f32| {
            if ratio.is_nan() {
                return 0.0;
            }
            if ratio.is_infinite() {
                return if ratio.is_sign_positive() { 1.0 } else { 0.0 };
            }
            let ratio = ratio.max(0.0);
            let k = k.max(1e-6);
            let r_ref = 1.0 / (1.0 + k);
            if ratio <= 0.0 {
                0.0
            } else if ratio < 1.0 {
                (ratio * r_ref).clamp(0.0, 1.0)
            } else {
                let denom = ratio + k;
                if denom <= 0.0 {
                    return 1.0;
                }
                (1.0 - k / denom).clamp(0.0, 1.0)
            }
        };
        for &ratio in &[0.0, 0.5, 1.0, 10.0, f32::INFINITY] {
            let new_val = roughness_ratio_to_state01(ratio, k);
            let old_val = legacy(ratio);
            assert!((new_val - old_val).abs() < 1e-6);
        }
    }

    #[test]
    fn compose_c_statepm1_scan_matches_scalar() {
        let h = vec![0.2, 0.8];
        let r = vec![0.1, 0.5];
        let mut out = vec![0.0; 2];
        compose_c_statepm1_scan(&h, &r, 0.5, &mut out);
        for i in 0..2 {
            let legacy = (h[i] - 0.5 * r[i]).clamp(-1.0, 1.0);
            let (c, _) = compose_c_statepm1(h[i], r[i], 0.5);
            assert!((out[i] - c).abs() < 1e-6);
            assert!((c - legacy).abs() < 1e-6);
        }
    }
}
</file>

<file path="src/life/predictive_spectrum.rs">
use crate::core::landscape::LandscapeParams;
use crate::core::log2space::Log2Space;
use crate::core::psycho_state::{
    compose_c_statepm1_scan, compute_roughness_reference, h_pot_scan_to_h_state01_scan,
    r_pot_scan_to_r_state01_scan,
};
use crate::core::roughness_kernel::erb_grid;
use crate::core::timebase::Tick;
use crate::life::intent::Intent;

#[derive(Clone, Debug)]
pub struct PredKernelInputs {
    pub eval_tick: Tick,
    pub pred_env_scan: Vec<f32>,
    pub pred_den_scan: Vec<f32>,
}

#[derive(Clone, Debug)]
pub struct PredTerrain {
    pub eval_tick: Tick,
    pub pred_env_scan: Vec<f32>,
    pub pred_den_scan: Vec<f32>,
    pub pred_h_pot_scan: Vec<f32>,
    pub pred_r_pot_scan: Vec<f32>,
    pub pred_h_state01_scan: Vec<f32>,
    pub pred_r_state01_scan: Vec<f32>,
    pub pred_c_statepm1_scan: Vec<f32>,
}

pub fn build_pred_kernel_inputs_from_intents(
    space: &Log2Space,
    intents: &[Intent],
    eval_tick: Tick,
) -> PredKernelInputs {
    let n = space.n_bins();
    let mut pred_env_scan = vec![0.0f32; n];
    let mut pred_den_scan = vec![0.0f32; n];
    let (_erb, du) = erb_grid(space);
    debug_assert_eq!(du.len(), n);

    for intent in intents {
        if !intent_active_at(intent, eval_tick) {
            continue;
        }
        add_intent_energy(intent, space, &du, &mut pred_env_scan, &mut pred_den_scan);
    }

    space.assert_scan_len_named(&pred_env_scan, "pred_env_scan");
    space.assert_scan_len_named(&pred_den_scan, "pred_den_scan");

    PredKernelInputs {
        eval_tick,
        pred_env_scan,
        pred_den_scan,
    }
}

pub fn build_pred_terrain_from_intents(
    space: &Log2Space,
    params: &LandscapeParams,
    intents: &[Intent],
    eval_tick: Tick,
) -> PredTerrain {
    let inputs = build_pred_kernel_inputs_from_intents(space, intents, eval_tick);
    let (pred_h_pot_scan, _) = params
        .harmonicity_kernel
        .potential_h_from_log2_spectrum(&inputs.pred_env_scan, space);
    let (pred_r_pot_scan, _) = params
        .roughness_kernel
        .potential_r_from_log2_spectrum_density(&inputs.pred_den_scan, space);

    let mut pred_h_state01_scan = vec![0.0f32; pred_h_pot_scan.len()];
    let mut pred_r_state01_scan = vec![0.0f32; pred_r_pot_scan.len()];
    let mut pred_c_statepm1_scan = vec![0.0f32; pred_h_pot_scan.len()];

    let h_ref_max = pred_h_pot_scan.iter().copied().fold(0.0f32, f32::max);
    let h_ref_max = if h_ref_max.is_finite() && h_ref_max > 0.0 {
        h_ref_max
    } else {
        1.0
    };
    h_pot_scan_to_h_state01_scan(&pred_h_pot_scan, h_ref_max, &mut pred_h_state01_scan);

    let rough_ref = compute_roughness_reference(params, space);
    let rough_k = params.roughness_k.max(1e-6);
    r_pot_scan_to_r_state01_scan(
        &pred_r_pot_scan,
        rough_ref.peak,
        rough_k,
        &mut pred_r_state01_scan,
    );

    compose_c_statepm1_scan(
        &pred_h_state01_scan,
        &pred_r_state01_scan,
        params.consonance_roughness_weight,
        &mut pred_c_statepm1_scan,
    );

    PredTerrain {
        eval_tick,
        pred_env_scan: inputs.pred_env_scan,
        pred_den_scan: inputs.pred_den_scan,
        pred_h_pot_scan,
        pred_r_pot_scan,
        pred_h_state01_scan,
        pred_r_state01_scan,
        pred_c_statepm1_scan,
    }
}

fn intent_active_at(intent: &Intent, eval_tick: Tick) -> bool {
    let end = intent.onset.saturating_add(intent.duration);
    intent.onset <= eval_tick && eval_tick < end
}

fn add_intent_energy(
    intent: &Intent,
    space: &Log2Space,
    du: &[f32],
    pred_env_scan: &mut [f32],
    pred_den_scan: &mut [f32],
) {
    if intent.freq_hz <= 0.0 || !intent.freq_hz.is_finite() {
        return;
    }
    if !intent.amp.is_finite() {
        return;
    }
    if intent.freq_hz < space.fmin || intent.freq_hz > space.fmax {
        return;
    }
    let mut amp = intent.amp.max(0.0);
    if let Some(body) = &intent.body {
        amp *= body.amp_scale.clamp(0.0, 1.0);
    }
    if amp <= 0.0 {
        return;
    }

    // HarmonicityStream consumes the log2-space amplitude spectrum (linear amplitude on log2 bins).
    add_log2_energy(pred_env_scan, space, intent.freq_hz, amp);

    let power = amp * amp;
    add_log2_density(pred_den_scan, space, du, intent.freq_hz, power);
}

fn add_log2_energy(amps: &mut [f32], space: &Log2Space, freq_hz: f32, energy: f32) {
    if !freq_hz.is_finite() || energy == 0.0 {
        return;
    }
    if freq_hz < space.fmin || freq_hz > space.fmax {
        return;
    }
    let pos = match space.bin_pos_of_freq(freq_hz) {
        Some(pos) => pos,
        None => return,
    };
    let idx_base = pos.floor();
    let idx = idx_base as isize;
    if idx < 0 {
        return;
    }
    let idx = idx as usize;
    let frac = pos - idx_base;
    if idx + 1 < amps.len() {
        amps[idx] += energy * (1.0 - frac);
        amps[idx + 1] += energy * frac;
    } else if idx < amps.len() {
        amps[idx] += energy * (1.0 - frac);
    }
}

fn add_log2_density(density: &mut [f32], space: &Log2Space, du: &[f32], freq_hz: f32, mass: f32) {
    if !freq_hz.is_finite() || mass == 0.0 {
        return;
    }
    if freq_hz < space.fmin || freq_hz > space.fmax {
        return;
    }
    let pos = match space.bin_pos_of_freq(freq_hz) {
        Some(pos) => pos,
        None => return,
    };
    let idx_base = pos.floor();
    let idx = idx_base as isize;
    if idx < 0 {
        return;
    }
    let idx = idx as usize;
    let frac = pos - idx_base;
    if idx + 1 < density.len() {
        let d0 = du[idx].max(1e-12);
        let d1 = du[idx + 1].max(1e-12);
        density[idx] += (mass * (1.0 - frac)) / d0;
        density[idx + 1] += (mass * frac) / d1;
    } else if idx < density.len() {
        let d0 = du[idx].max(1e-12);
        density[idx] += (mass * (1.0 - frac)) / d0;
    }
}
</file>

<file path="src/life/social_density.rs">
use crate::core::timebase::Tick;

#[derive(Clone, Debug, Default)]
pub struct SocialDensityTrace {
    pub start_tick: Tick,
    pub bin_ticks: u32,
    pub bins: Vec<f32>,
}

impl SocialDensityTrace {
    pub fn density_at(&self, tick: Tick) -> f32 {
        if self.bin_ticks == 0 {
            return 0.0;
        }
        if tick < self.start_tick {
            return 0.0;
        }
        let idx = ((tick - self.start_tick) / self.bin_ticks as Tick) as usize;
        self.bins.get(idx).copied().unwrap_or(0.0)
    }

    pub fn from_onsets(
        start_tick: Tick,
        end_tick: Tick,
        bin_ticks: u32,
        smooth: f32,
        population_size: usize,
        onsets: &[(Tick, f32)],
    ) -> Self {
        if bin_ticks == 0 || end_tick <= start_tick {
            return Self::default();
        }
        let span = end_tick - start_tick;
        let n_bins = span.div_ceil(bin_ticks as Tick) as usize;
        let mut bins = vec![0.0; n_bins];
        for (tick, strength) in onsets {
            if *tick < start_tick || *tick >= end_tick {
                continue;
            }
            let idx = ((*tick - start_tick) / bin_ticks as Tick) as usize;
            if let Some(slot) = bins.get_mut(idx) {
                *slot += strength.max(0.0);
            }
        }
        if population_size > 0 {
            let norm = population_size as f32;
            for v in &mut bins {
                *v /= norm;
            }
        }
        let smooth = smooth.clamp(0.0, 1.0);
        if smooth > 0.0 {
            let mut prev = bins.first().copied().unwrap_or(0.0);
            for v in &mut bins {
                *v = smooth * prev + (1.0 - smooth) * *v;
                prev = *v;
            }
        }
        Self {
            start_tick,
            bin_ticks,
            bins,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn density_at_out_of_range_is_zero() {
        let trace = SocialDensityTrace {
            start_tick: 10,
            bin_ticks: 5,
            bins: vec![1.0],
        };
        assert_eq!(trace.density_at(9), 0.0);
        assert_eq!(trace.density_at(10), 1.0);
        assert_eq!(trace.density_at(20), 0.0);
    }

    #[test]
    fn from_onsets_bins_and_normalizes() {
        let trace =
            SocialDensityTrace::from_onsets(0, 10, 5, 0.0, 2, &[(0, 1.0), (1, 1.0), (6, 1.0)]);
        assert_eq!(trace.bins.len(), 2);
        assert!((trace.bins[0] - 1.0).abs() < 1e-6);
        assert!((trace.bins[1] - 0.5).abs() < 1e-6);
    }

    #[test]
    fn from_onsets_bin_count_and_boundary_assignment() {
        let trace = SocialDensityTrace::from_onsets(
            100,
            200,
            10,
            0.0,
            2,
            &[(100, 1.0), (110, 1.0), (110, 1.0)],
        );
        assert_eq!(trace.bins.len(), 10);
        assert!((trace.bins[0] - 0.5).abs() < 1e-6);
        assert!((trace.bins[1] - 1.0).abs() < 1e-6);
    }

    #[test]
    fn from_onsets_boundary_tick_goes_to_next_bin() {
        let trace = SocialDensityTrace::from_onsets(0, 12, 4, 0.0, 1, &[(4, 1.0)]);
        assert_eq!(trace.bins.len(), 3);
        assert_eq!(trace.bins[0], 0.0);
        assert_eq!(trace.bins[1], 1.0);
    }

    #[test]
    fn from_onsets_clamps_smoothing() {
        let trace = SocialDensityTrace::from_onsets(0, 10, 5, 2.0, 1, &[(0, 1.0)]);
        assert!(trace.bins.iter().all(|v| v.is_finite()));
    }
}
</file>

<file path="src/config.rs">
use crate::core::nsgt_kernel::KernelAlign;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AudioConfig {
    #[serde(default = "AudioConfig::default_latency_ms")]
    pub latency_ms: f32,
    #[serde(default = "AudioConfig::default_sample_rate")]
    pub sample_rate: u32,
}

impl AudioConfig {
    fn default_latency_ms() -> f32 {
        50.0
    }
    fn default_sample_rate() -> u32 {
        48_000
    }
}

impl Default for AudioConfig {
    fn default() -> Self {
        Self {
            latency_ms: Self::default_latency_ms(),
            sample_rate: Self::default_sample_rate(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisConfig {
    #[serde(default = "AnalysisConfig::default_nfft")]
    pub nfft: usize,
    #[serde(default = "AnalysisConfig::default_hop_size")]
    pub hop_size: usize,
    #[serde(default = "AnalysisConfig::default_tau_ms")]
    pub tau_ms: f32,
    #[serde(default)]
    pub kernel_align: KernelAlign,
}

impl AnalysisConfig {
    fn default_nfft() -> usize {
        16_384
    }
    fn default_hop_size() -> usize {
        512
    }
    fn default_tau_ms() -> f32 {
        10.0
    }
}

impl Default for AnalysisConfig {
    fn default() -> Self {
        Self {
            nfft: Self::default_nfft(),
            hop_size: Self::default_hop_size(),
            tau_ms: Self::default_tau_ms(),
            kernel_align: KernelAlign::Right,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PsychoAcousticsConfig {
    #[serde(default = "PsychoAcousticsConfig::default_loudness_exp")]
    pub loudness_exp: f32,
    #[serde(default = "PsychoAcousticsConfig::default_roughness_k")]
    pub roughness_k: f32,
    #[serde(default = "PsychoAcousticsConfig::default_roughness_weight")]
    pub roughness_weight: f32,
    #[serde(default = "PsychoAcousticsConfig::default_use_incoherent_power")]
    pub use_incoherent_power: bool,
}

impl PsychoAcousticsConfig {
    fn default_loudness_exp() -> f32 {
        0.23
    }
    fn default_roughness_k() -> f32 {
        0.428571
    }
    fn default_roughness_weight() -> f32 {
        1.0
    }
    fn default_use_incoherent_power() -> bool {
        false
    }
}

impl Default for PsychoAcousticsConfig {
    fn default() -> Self {
        Self {
            loudness_exp: Self::default_loudness_exp(),
            roughness_k: Self::default_roughness_k(),
            roughness_weight: Self::default_roughness_weight(),
            use_incoherent_power: Self::default_use_incoherent_power(),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct AppConfig {
    #[serde(default)]
    pub audio: AudioConfig,
    #[serde(default)]
    pub analysis: AnalysisConfig,
    #[serde(default)]
    pub psychoacoustics: PsychoAcousticsConfig,
    #[serde(default)]
    pub playback: PlaybackConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybackConfig {
    #[serde(default = "PlaybackConfig::default_wait_user_exit")]
    pub wait_user_exit: bool,
    #[serde(default = "PlaybackConfig::default_wait_user_start")]
    pub wait_user_start: bool,
}

impl PlaybackConfig {
    fn default_wait_user_exit() -> bool {
        true
    }
    fn default_wait_user_start() -> bool {
        false
    }
}

impl Default for PlaybackConfig {
    fn default() -> Self {
        Self {
            wait_user_exit: Self::default_wait_user_exit(),
            wait_user_start: Self::default_wait_user_start(),
        }
    }
}

impl AppConfig {
    fn round_f32(x: f32) -> f32 {
        (x * 1_000_000.0).round() / 1_000_000.0
    }

    fn rounded(mut self) -> Self {
        self.audio.latency_ms = Self::round_f32(self.audio.latency_ms);
        self.analysis.tau_ms = Self::round_f32(self.analysis.tau_ms);
        self.psychoacoustics.loudness_exp = Self::round_f32(self.psychoacoustics.loudness_exp);
        self.psychoacoustics.roughness_k = Self::round_f32(self.psychoacoustics.roughness_k);
        self.psychoacoustics.roughness_weight =
            Self::round_f32(self.psychoacoustics.roughness_weight);
        self
    }

    pub fn load_or_default(path: &str) -> Self {
        let path_obj = Path::new(path);
        if path_obj.exists() {
            match fs::read_to_string(path_obj) {
                Ok(contents) => match toml::from_str(&contents) {
                    Ok(cfg) => return cfg,
                    Err(err) => {
                        eprintln!("Failed to parse config {path}: {err}. Using defaults.");
                    }
                },
                Err(err) => {
                    eprintln!("Failed to read config {path}: {err}. Using defaults.");
                }
            }
            return Self::default();
        }

        // File does not exist: write defaults and return them.
        let default_cfg = Self::default().rounded();
        if let Ok(text) = toml::to_string_pretty(&default_cfg) {
            let mut commented = String::new();
            for line in text.lines() {
                let trimmed = line.trim();
                if trimmed.is_empty() {
                    commented.push('\n');
                } else if trimmed.starts_with('[') && trimmed.ends_with(']') {
                    commented.push_str(line);
                    commented.push('\n');
                } else {
                    commented.push_str("# ");
                    commented.push_str(line);
                    commented.push('\n');
                }
            }
            if let Err(err) = fs::write(path_obj, commented) {
                eprintln!("Failed to write default config to {path}: {err}");
            }
        } else {
            eprintln!("Failed to serialize default config; continuing with defaults");
        }
        default_cfg
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;

    fn unique_path(name: &str) -> std::path::PathBuf {
        let mut p = std::env::temp_dir();
        p.push(format!(
            "conchordal_config_test_{}_{}",
            name,
            std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_nanos()
        ));
        p
    }

    #[test]
    fn load_or_default_writes_defaults_cleanly() {
        let path = unique_path("defaults.toml");
        let path_str = path.to_string_lossy().to_string();
        // Ensure clean slate
        let _ = fs::remove_file(&path);

        let cfg = AppConfig::load_or_default(&path_str);
        assert!(path.exists(), "config file should be created");
        assert_eq!(cfg.audio.latency_ms, 50.0);
        assert_eq!(cfg.audio.sample_rate, 48_000);
        assert_eq!(cfg.psychoacoustics.loudness_exp, 0.23);
        assert!((cfg.psychoacoustics.roughness_k - 0.428571).abs() < 1e-6);
        assert_eq!(cfg.psychoacoustics.roughness_weight, 1.0);
        assert!(!cfg.psychoacoustics.use_incoherent_power);

        let contents = fs::read_to_string(&path).expect("read written config");
        assert!(
            contents.contains("# loudness_exp = 0.23"),
            "should write commented loudness_exp"
        );
        assert!(
            contents.contains("# roughness_k = 0.42857"),
            "should write commented roughness_k"
        );
        assert!(
            contents.contains("# roughness_weight = 1.0"),
            "should write commented roughness_weight"
        );
        assert!(
            contents.contains("# use_incoherent_power = false"),
            "should write commented use_incoherent_power"
        );

        let _ = fs::remove_file(&path);
    }

    #[test]
    fn load_or_default_reads_existing() {
        let path = unique_path("custom.toml");
        let path_str = path.to_string_lossy().to_string();
        let custom = AppConfig {
            audio: AudioConfig {
                latency_ms: 75.0,
                sample_rate: 44_100,
            },
            analysis: AnalysisConfig {
                nfft: 8192,
                hop_size: 256,
                tau_ms: 60.0,
                kernel_align: KernelAlign::Center,
            },
            psychoacoustics: PsychoAcousticsConfig {
                loudness_exp: 0.3,
                roughness_k: 0.2,
                roughness_weight: 0.8,
                use_incoherent_power: false,
            },
            playback: PlaybackConfig {
                wait_user_exit: false,
                wait_user_start: true,
            },
        };
        let text = toml::to_string_pretty(&custom).unwrap();
        fs::write(&path, text).unwrap();

        let cfg = AppConfig::load_or_default(&path_str);
        assert_eq!(cfg.audio.latency_ms, 75.0);
        assert_eq!(cfg.audio.sample_rate, 44_100);
        assert_eq!(cfg.analysis.nfft, 8192);
        assert_eq!(cfg.analysis.hop_size, 256);
        assert_eq!(cfg.analysis.tau_ms, 60.0);
        assert_eq!(cfg.psychoacoustics.loudness_exp, 0.3);
        assert_eq!(cfg.psychoacoustics.roughness_k, 0.2);
        assert_eq!(cfg.psychoacoustics.roughness_weight, 0.8);
        assert!(!cfg.psychoacoustics.use_incoherent_power);
        assert!(!cfg.playback.wait_user_exit);
        assert!(cfg.playback.wait_user_start);

        let _ = fs::remove_file(&path);
    }
}
</file>

<file path="src/core.rs">
pub mod a_weighting;
pub mod db;
pub mod density;
pub mod erb;
pub mod fft;
pub mod harmonic_ratios;
pub mod harmonicity_kernel;
pub mod harmonicity_worker;
pub mod landscape;
pub mod landscape_spectral;
pub mod log2space;
pub mod modulation;
pub mod nsgt;
pub mod nsgt_kernel;
pub mod nsgt_rt;
pub mod peak_extraction;
pub mod phase;
pub mod psycho_state;
pub mod roughness_kernel;
pub mod roughness_worker;
pub mod stream;
pub mod timebase;
pub mod utils;
</file>

<file path="tests/intent_board.rs">
use conchordal::core::timebase::Tick;
use conchordal::life::intent::{Intent, IntentBoard};

fn make_intent(intent_id: u64, onset: Tick, duration: Tick) -> Intent {
    Intent {
        source_id: 1,
        intent_id,
        onset,
        duration,
        freq_hz: 440.0,
        amp: 0.5,
        tag: None,
        confidence: 1.0,
        body: None,
        articulation: None,
    }
}

#[test]
fn publish_and_query() {
    let mut board = IntentBoard::new(0, 0);
    board.publish(make_intent(1, 10, 5));
    let hits: Vec<_> = board.query_range(0..20).collect();
    assert_eq!(hits.len(), 1);
    assert_eq!(hits[0].intent_id, 1);
}

#[test]
fn overlap_is_detected() {
    let mut board = IntentBoard::new(0, 0);
    board.publish(make_intent(1, 10, 10));
    let hits: Vec<_> = board.query_range(15..18).collect();
    assert_eq!(hits.len(), 1);
    assert_eq!(hits[0].intent_id, 1);
}

#[test]
fn prune_removes_old_finished_intents() {
    let mut board = IntentBoard::new(10, 0);
    board.publish(make_intent(1, 80, 5));
    board.publish(make_intent(2, 90, 15));
    board.prune(100);
    let ids: Vec<_> = board.query_range(0..200).map(|i| i.intent_id).collect();
    assert_eq!(ids, vec![2]);
}

#[test]
fn prune_removes_far_future_intents() {
    let mut board = IntentBoard::new(0, 10);
    board.publish(make_intent(1, 105, 5));
    board.publish(make_intent(2, 120, 5));
    board.prune(100);
    let ids: Vec<_> = board.query_range(0..200).map(|i| i.intent_id).collect();
    assert_eq!(ids, vec![1]);
}

#[test]
fn snapshot_clones_within_range() {
    let mut board = IntentBoard::new(0, 0);
    board.publish(make_intent(1, 5, 5));
    board.publish(make_intent(2, 20, 5));
    let snap = board.snapshot(15, 20, 10);
    let ids: Vec<_> = snap.iter().map(|i| i.intent_id).collect();
    assert_eq!(ids, vec![1, 2]);
}

#[test]
fn publish_out_of_order_keeps_sorted() {
    let mut board = IntentBoard::new(0, 0);
    board.publish(make_intent(1, 20, 5));
    board.publish(make_intent(2, 10, 5));
    board.publish(make_intent(3, 15, 5));
    let onsets: Vec<_> = board.query_range(0..100).map(|i| i.onset).collect();
    assert_eq!(onsets, vec![10, 15, 20]);
}
</file>

<file path="tests/log2space_scan_invariants.rs">
use conchordal::core::landscape::Landscape;
use conchordal::core::log2space::Log2Space;
use conchordal::core::psycho_state::{
    compose_c_statepm1_scan, h_pot_scan_to_h_state01_scan, r_pot_scan_to_r_state01_scan,
};

#[test]
fn landscape_scans_match_space_bins() {
    let space = Log2Space::new(55.0, 4000.0, 48);
    let landscape = Landscape::new(space.clone());

    space.assert_scan_len(&landscape.roughness);
    space.assert_scan_len(&landscape.roughness_shape_raw);
    space.assert_scan_len(&landscape.roughness01);
    space.assert_scan_len(&landscape.harmonicity);
    space.assert_scan_len(&landscape.harmonicity01);
    space.assert_scan_len(&landscape.consonance);
    space.assert_scan_len(&landscape.consonance01);
    space.assert_scan_len(&landscape.subjective_intensity);
    space.assert_scan_len(&landscape.nsgt_power);
}

#[test]
fn pot_state_scan_len_invariants_hold() {
    let space = Log2Space::new(55.0, 4000.0, 24);
    let n = space.n_bins();

    let r_pot = vec![0.1f32; n];
    let mut r_state = vec![0.0f32; n];
    r_pot_scan_to_r_state01_scan(&r_pot, 1.0, 0.5, &mut r_state);

    let h_pot = vec![0.2f32; n];
    let mut h_state = vec![0.0f32; n];
    h_pot_scan_to_h_state01_scan(&h_pot, 1.0, &mut h_state);

    let mut c_state = vec![0.0f32; n];
    compose_c_statepm1_scan(&h_state, &r_state, 0.5, &mut c_state);
}

#[test]
// compose_c_statepm1_scan uses debug_assert for length checks; skip in release where it is elided.
#[cfg(debug_assertions)]
#[should_panic]
fn compose_panics_on_len_mismatch() {
    let h_state = vec![0.1f32; 4];
    let r_state = vec![0.2f32; 3];
    let mut c_state = vec![0.0f32; 4];
    compose_c_statepm1_scan(&h_state, &r_state, 0.5, &mut c_state);
}
</file>

<file path="samples/01_fundamentals/basic.rhai">
let drones_tag = "drones";
spawn(
    drones_tag,
    5,
    #{ method: #{ mode: "harmonicity", min_freq: 200.0, max_freq: 1200.0 } },
    #{ body: #{ amp: 0.15 }, phonation: #{ type: "hold" } }
);

wait(10.0);
release(drones_tag, 3.0);
wait(4.0);
end();
</file>

<file path="samples/01_fundamentals/psychoacoustic_test.rhai">
print("Harmonicity demo: climb into peaks, then settle");

// Seed: One-shot long decay
let seed_method = #{ mode: "random_log_uniform", min_freq: 330.0, max_freq: 330.0 };
spawn("seed", 1, #{ method: seed_method }, #{ body: #{ amp: 0.24 } });
wait(0.5);

let method = #{ mode: "harmonicity", min_freq: 200.0, max_freq: 1200.0 };

for i in 0..6 {
    spawn(
        "harm_" + i,
        2,
        #{ method: method },
        #{ body: #{ amp: 0.16 + i * 0.01 } }
    );
    wait(0.7);
}

wait(1.5);
end();
</file>

<file path="samples/01_fundamentals/spawn_basics.rhai">
// Mixed strategies in one sweep (quick listening tour)
spawn(
    "rnd",
    3,
    #{ method: #{ mode: "random_log_uniform", min_freq: 200.0, max_freq: 1500.0 } },
    #{ body: #{ amp: 0.18 } }
);
wait(0.9);
spawn(
    "harm",
    2,
    #{ method: #{ mode: "harmonicity", min_freq: 260.0, max_freq: 1200.0 } },
    #{ body: #{ amp: 0.22 } }
);
wait(0.8);
spawn(
    "gap",
    2,
    #{ method: #{ mode: "spectral_gap", min_freq: 220.0, max_freq: 1400.0 } },
    #{ body: #{ amp: 0.18 } }
);
wait(0.9);
spawn(
    "hdens",
    3,
    #{ method: #{ mode: "harmonic_density", min_freq: 160.0, max_freq: 1400.0, temperature: 0.7 } },
    #{ body: #{ amp: 0.2 } }
);
wait(0.8);
spawn(
    "zero",
    2,
    #{ method: #{ mode: "zero_crossing", min_freq: 180.0, max_freq: 1600.0 } },
    #{ body: #{ amp: 0.18 } }
);
wait(0.8);
spawn(
    "lowharm",
    2,
    #{ method: #{ mode: "low_harmonicity", min_freq: 200.0, max_freq: 1500.0 } },
    #{ body: #{ amp: 0.18 } }
);
wait(1.5);
end();
</file>

<file path="samples/02_mechanisms/rhythmic_sync.rhai">
print(">>> Experiment: Self-Organizing Rhythm <<<");

// ============================================================
// Setup: percussive so synchronization is easy to hear
// ============================================================

let click_phonation = #{ type: "clock", density: 1.0, legato: 0.0 };

// Startup stimulus: a single short click to bootstrap rhythm extraction.
let starter_method = #{ mode: "random_log_uniform", min_freq: 100.0, max_freq: 100.0 };
spawn(
    "starter",
    1,
    #{ method: starter_method },
    #{ body: #{ amp: 0.4, method: "sine" }, phonation: click_phonation }
);

// Long-lived agents, but the sound is a short pluck.
// Sharp attack makes timing offsets and sync obvious.
let follower_patch = #{
    body: #{ amp: 0.08, method: "sine" },
    phonation: #{ type: "interval", density: 0.7, legato: 0.1 }
};

// ============================================================
// Phase 1: The Seed (metronome-driven entrainment)
// ============================================================
scene("Phase 1: Metronome");
print("--- [1] Injecting strong beat (Delta band driver) ---");

// 1. Place a strong kick (60 Hz) to shake the low/delta band and set a reference.
let kick_method = #{ mode: "random_log_uniform", min_freq: 60.0, max_freq: 60.0 };
let kick_tag = "kick";
spawn(
    kick_tag,
    1,
    #{ method: kick_method },
    #{ body: #{ amp: 0.5, method: "sine" }, phonation: click_phonation }
);

wait(2.0); // allow rhythm to settle

// ============================================================
// Phase 2: The Swarm (group injection)
// ============================================================
scene("Phase 2: Recruitment");
print("--- [2] Spawning agents with random phases ---");

// 2. Inject many agents (200–800 Hz).
// Phases start messy, then get pulled toward the kick (delta band).
let method_flock = #{ 
    mode: "harmonic_density", 
    min_freq: 200.0, 
    max_freq: 800.0, 
    temperature: 1.0 
};

// Add in four waves to thicken layers
for i in 0..4 {
    spawn("follower", 4, #{ method: method_flock }, follower_patch);
    wait(1.0); // pause before next batch
}

print("--- Listening for synchronization... ---");
wait(4.0); // give time to synchronize

// ============================================================
// Phase 3: Emergence (self-sustain)
// ============================================================
scene("Phase 3: Emergence");
print("--- [3] REMOVING THE METRONOME (Watch self-sustain) ---");

// 3. Remove the parent kick; no external reference remains.
// Agents try to keep rhythm by mutual coupling alone.
remove(kick_tag);

// Success if the groove persists (with some wobble) after the leader vanishes.
wait(6.0);

// ============================================================
// Phase 4: Perturbation (disrupt and resync)
// ============================================================
scene("Phase 4: Perturbation");
print("--- [4] Injecting counter-rhythm (High freq) ---");

// 4. Inject high clicks with a different tempo to perturb the groove.
// Watch whether high/alpha stimulation micro-adjusts timing.
let method_click = #{ mode: "random_log_uniform", min_freq: 2000.0, max_freq: 4000.0 };

for i in 0..8 {
    spawn(
        "noise",
        2,
        #{ method: method_click },
        #{ body: #{ amp: 0.1, method: "sine" }, phonation: click_phonation }
    );
    wait(0.25); // fast pulse
}

wait(3.0); // observe post-perturbation settling

// Done
end();
</file>

<file path="samples/02_mechanisms/spectral_gap.rhai">
print("Spectral Gap: weave through silence");

let method = #{ mode: "spectral_gap", min_freq: 120.0, max_freq: 2200.0 };

scene("stitch");
for i in 0..24 {
    spawn(
        "gap_" + i,
        1,
        #{ method: method },
        #{
            body: #{ amp: 0.18, method: "sine" },
            phonation: #{ type: "interval", density: 0.6, legato: 0.1 }
        }
    );
    wait(0.16);
}

wait(1.2);
end();
</file>

<file path="samples/03_structures/basic_progression.rhai">
print(">>> Cycle of Fifths (Organic Update) <<<");

// ヘルパー: 指定範囲のランダムな周波数を返す（簡易版）
fn random_offset(base, amount) {
    // Rhaiにrand()がない場合を想定し、システム時間等は使えないため
    // 決定論的な擬似ランダム、または単純なオフセットを使用します。
    return base + amount; 
}

fn play_step(name, root, dur) {
    // 1. Bass (Anchor): 動かない、重い、飽きない
    let bass_patch = #{ body: #{ amp: 0.6, method: "sine" }, phonation: #{ type: "hold" } };

    // 2. Pad (Seeker): 動きやすい、分散する
    let pad_patch = #{ body: #{ amp: 0.3, method: "sine" }, phonation: #{ type: "hold" } };

    print("Playing: " + name);

    // ベース（アンカー）を配置
    let bass_method = #{ mode: "random_log_uniform", min_freq: root, max_freq: root };
    let bass_tag = "bass_" + name;
    spawn(bass_tag, 1, #{ method: bass_method }, bass_patch);
    
    // ランドスケープが形成されるのを少し待つ
    wait(0.2); 

    // パッドを配置（自律的に和音構成音を探させる）
    // ルートの少し上から配置し、GravityとConsonanceで落ち着かせる
    let pad_1_method = #{ mode: "random_log_uniform", min_freq: root * 1.5, max_freq: root * 1.5 };
    let pad_2_method = #{ mode: "random_log_uniform", min_freq: root * 2.0, max_freq: root * 2.0 };
    let pad_3_method = #{ mode: "random_log_uniform", min_freq: root * 1.25, max_freq: root * 1.25 };
    let pad_1_tag = "pad_" + name + "_1";
    let pad_2_tag = "pad_" + name + "_2";
    let pad_3_tag = "pad_" + name + "_3";
    spawn(pad_1_tag, 1, #{ method: pad_1_method }, pad_patch); // 5th付近
    spawn(pad_2_tag, 1, #{ method: pad_2_method }, pad_patch); // Octave付近
    spawn(pad_3_tag, 1, #{ method: pad_3_method }, pad_patch); // 3rd付近 (Major/Minorは地形で決まる)

    wait(dur);

    // クリーンアップ
    remove(bass_tag);
    remove(pad_1_tag);
    remove(pad_2_tag);
    remove(pad_3_tag);
}

let chords = [
    #{ name: "Am",   freq: 110.00, dur: 3.0 },
    #{ name: "Dm",   freq: 146.83, dur: 3.0 },
    #{ name: "G7",   freq: 196.00, dur: 3.0 },
    #{ name: "Cmaj", freq: 130.81, dur: 3.0 },
    #{ name: "Fmaj", freq: 174.61, dur: 3.0 },
    #{ name: "Bdim", freq: 246.94, dur: 3.0 },
    #{ name: "E7",   freq: 164.81, dur: 3.0 },
    #{ name: "Am",   freq: 110.00, dur: 4.0 },
];

scene("cycle_organic");

// ランドスケープ設定（飽きの早さなどを調整）

for ch in chords {
    play_step(ch.name, ch.freq, ch.dur);
}

wait(2.0);
end();
</file>

<file path="samples/03_structures/cadence_ii_v_i.rhai">
print("II - V - I anchor walk");

fn play_chord(root, tag) {
    let pad_method = #{ mode: "harmonicity", min_freq: root * 2.0, max_freq: root * 5.0 };

    let bass_method = #{ mode: "random_log_uniform", min_freq: root, max_freq: root };
    let bass_tag = "bass_" + tag;
    spawn(
        bass_tag,
        1,
        #{ method: bass_method },
        #{ body: #{ amp: 0.36, method: "sine" }, phonation: #{ type: "hold" } }
    );
    wait(0.18);
    let pads_tag = "pad_" + tag;
    spawn(
        pads_tag,
        3,
        #{ method: pad_method },
        #{ body: #{ amp: 0.2, method: "sine" }, phonation: #{ type: "hold" } }
    );
    wait(1.4);
    remove(bass_tag);
    remove(pads_tag);
}

scene("ii");
play_chord(146.83, "ii"); // Dm7

scene("v");
play_chord(196.00, "v"); // G7

scene("i");
play_chord(130.81, "i"); // Cmaj

wait(1.0);
end();
</file>

<file path="samples/03_structures/tension_resolution.rhai">
print("Polyphony: anchor + tension + resolution");

fn chord_block(root, name, sustain_amp, tension_amp, dur) {
    // Anchor bass
    let bass_method = #{ mode: "random_log_uniform", min_freq: root, max_freq: root };
    spawn(
        "bass_" + name,
        1,
        #{ method: bass_method },
        #{ body: #{ amp: sustain_amp, method: "sine" }, phonation: #{ type: "hold" } }
    );
    wait(0.18);

    // Pads seek harmonic peaks above the anchor
    let pad_method = #{ mode: "harmonicity", min_freq: root * 2.0, max_freq: root * 5.0 };
    spawn(
        "pad_" + name,
        3,
        #{ method: pad_method },
        #{ body: #{ amp: sustain_amp * 0.6, method: "sine" }, phonation: #{ type: "hold" } }
    );

    // Midway, inject tension using low_harmonicity
    wait(dur * 0.4);
    let tension_method = #{ mode: "low_harmonicity", min_freq: root * 1.5, max_freq: root * 4.0 };
    spawn(
        "tension_" + name,
        2,
        #{ method: tension_method },
        #{ body: #{ amp: tension_amp, method: "sine" }, phonation: #{ type: "hold" } }
    );

    // Resolve: refresh harmonicity and thin tension
    wait(dur * 0.35);
    spawn(
        "resolve_" + name,
        2,
        #{ method: pad_method },
        #{ body: #{ amp: sustain_amp * 0.5, method: "sine" }, phonation: #{ type: "hold" } }
    );
    wait(dur * 0.25);
}

scene("Imaj7");
chord_block(130.81, "Cmaj7", 0.32, 0.18, 2.0);

scene("IIm7");
chord_block(146.83, "Dm7", 0.3, 0.18, 1.8);

scene("V7");
chord_block(196.00, "G7", 0.34, 0.2, 2.2);

scene("Imaj7_resolve");
chord_block(130.81, "Cmaj7_final", 0.36, 0.14, 2.4);

wait(1.0);
end();
</file>

<file path="samples/04_ecosystems/mirror_dualism.rhai">
print(">>> Comparison: Major Gravity vs Mirror Dualism <<<");

// ==========================================
// Shared Setup: The Anchor
// ==========================================
// Center on C4 (261.63Hz).
// "C" persists in both phases, but the attraction landscape around it changes.
let anchor_patch = #{ body: #{ amp: 0.4, method: "sine" }, phonation: #{ type: "hold" } };

let anchor_method = #{ mode: "random_log_uniform", min_freq: 261.63, max_freq: 261.63 };
let anchor_tag = "anchor";
spawn(anchor_tag, 1, #{ method: anchor_method }, anchor_patch);
wait(2.0);

// ==========================================
// Phase 1: Common Root (Standard / Major)
// ==========================================
// mirror_weight = 0.0
// Standard gravity based on the Overtone Series.
// With C4 active, its harmonics (E, G, Bb...) and C-rooted chords become stable.
// Result: Emergence of "C Major" tonality.
scene("Phase 1: Major Gravity");
print("--- [1] Weight 0.0: Common Root (Major) ---");

set_harmonicity(#{ mirror: 0.0 });
wait(0.5);

// Use harmonic_density with moderate temp to allow 3rds/5ths to emerge
let method_major = #{
    mode: "harmonic_density",
    min_freq: 130.0,
    max_freq: 1050.0,
    temperature: 0.5,
    min_dist_erb: 1.0
};
let voice_patch = #{ body: #{ amp: 0.2, method: "sine" }, phonation: #{ type: "hold" } };

let voices_major = [];
for i in 0..6 {
    // Probabilistically selects C, E, G (C Major Triad)
    let voice_tag = "voice_maj_" + i;
    spawn(voice_tag, 1, #{ method: method_major }, voice_patch);
    voices_major.push(voice_tag);
    wait(0.8);
}

wait(2.0);
// Clean up Phase 1 voices
for v in voices_major {
    remove(v);
}

// ==========================================
// Phase 2: Common Overtone (Mirror / Minor)
// ==========================================
// mirror_weight = 0.8
// Inverted gravity based on the Undertone Series.
// Searches for "hidden roots" that contain C4 as an overtone.
// - C is the 3rd harmonic of F (F-A-C)
// - C is the 5th harmonic of Ab (Ab-C-Eb)
// Result: Gravity flips to the minor side (F Minor / Ab Major) sharing C.
scene("Phase 2: Mirror Gravity");
print("--- [2] Weight 0.8: Common Overtone (Minor) ---");

// Invert gravity using map-based API
set_harmonicity(#{ mirror: 1.0 }); 
wait(1.0); // Allow landscape to update

let method_mirror = #{
    mode: "harmonic_density",
    min_freq: 130.0,
    max_freq: 1050.0,
    temperature: 0.5,
    min_dist_erb: 1.0
};

for i in 0..6 {
    // Probabilistically selects F, Ab (F Minor / Ab Major context)
    spawn("voice_min_" + i, 1, #{ method: method_mirror }, voice_patch);
    wait(0.8);
}

wait(3.0);
end();
</file>

<file path="samples/04_ecosystems/symbiotic_field.rhai">
print(">>> Hybrid Ecosystem: Machine, Plant, and Life <<<");

// 1. Machine (Seq): Strict rhythm using config maps
scene("Phase 1: Mechanism");
parallel(|| {
    let kick_method = #{ mode: "random_log_uniform", min_freq: 60.0, max_freq: 60.0 };
    let kick_patch = #{
        body: #{ amp: 0.6, method: "sine" },
        phonation: #{ type: "clock", density: 1.0, legato: 0.0 }
    };
    for i in 0..8 {
        spawn("kick", 1, #{ method: kick_method }, kick_patch);
        wait(0.5);
    }
});
wait(4.0);

// 2. Plant (Drone): Ambient texture
scene("Phase 2: Vegetation");
let drone_patch = #{
    body: #{
        amp: 0.3,
        method: "harmonic",
        timbre: #{ brightness: 0.5, inharmonic: 0.0, width: 0.05, motion: 0.05 }
    },
    phonation: #{ type: "hold" }
};
// Using a harmonic body for a drone-like pad.
let pad_method = #{ mode: "random_log_uniform", min_freq: 110.0, max_freq: 110.0 };
spawn("pad_low", 1, #{ method: pad_method }, drone_patch);
wait(2.0);

// 3. Life (Entrain): Standard autonomous agents
scene("Phase 3: Inhabitants");
let bio_patch = #{ body: #{ amp: 0.2, method: "sine" } };
let bio_method = #{ mode: "harmonicity", min_freq: 400.0, max_freq: 800.0 };
spawn("bugs", 5, #{ method: bio_method }, bio_patch);

wait(5.0);

// 4. Global Control
scene("Phase 4: High Pressure");
set_global_coupling(2.0);
set_roughness_tolerance(0.1);
wait(5.0);

end();
</file>

<file path="src/life/pitch_core.rs">
use crate::core::harmonic_ratios::{HARMONIC_RATIOS, fold_to_octave_near, ratio_to_f32};
use crate::core::landscape::Landscape;
use crate::life::perceptual::{FeaturesNow, PerceptualContext};
use crate::life::scenario::PitchCoreConfig;
use rand::Rng;

#[derive(Debug, Clone, Copy)]
pub struct TargetProposal {
    pub target_pitch_log2: f32,
    pub salience: f32,
}

#[allow(clippy::too_many_arguments)]
pub trait PitchCore {
    fn propose_target<R: Rng + ?Sized>(
        &mut self,
        current_pitch_log2: f32,
        current_target_log2: f32,
        current_freq_hz: f32,
        integration_window: f32,
        landscape: &Landscape,
        perceptual: &PerceptualContext,
        _features: &FeaturesNow,
        rng: &mut R,
    ) -> TargetProposal;

    fn propose_freqs_hz(&mut self, base_freq_hz: f32, k: usize) -> Vec<f32> {
        self.propose_freqs_hz_with_neighbors(base_freq_hz, &[], k, k.clamp(1, 8), 12.0)
    }

    fn propose_freqs_hz_with_neighbors(
        &mut self,
        base_freq_hz: f32,
        neighbor_freqs_hz: &[f32],
        max_candidates: usize,
        min_candidates: usize,
        dedupe_cents: f32,
    ) -> Vec<f32>;
}

#[derive(Debug, Clone)]
pub struct PitchHillClimbPitchCore {
    neighbor_step_log2: f32,
    tessitura_center: f32,
    tessitura_gravity: f32,
    improvement_threshold: f32,
    exploration: f32,
    persistence: f32,
}

impl PitchHillClimbPitchCore {
    pub fn new(
        neighbor_step_cents: f32,
        tessitura_center: f32,
        tessitura_gravity: f32,
        improvement_threshold: f32,
        exploration: f32,
        persistence: f32,
    ) -> Self {
        Self {
            neighbor_step_log2: neighbor_step_cents / 1200.0,
            tessitura_center,
            tessitura_gravity,
            improvement_threshold,
            exploration: exploration.clamp(0.0, 1.0),
            persistence: persistence.clamp(0.0, 1.0),
        }
    }

    pub fn set_exploration(&mut self, value: f32) {
        self.exploration = value.clamp(0.0, 1.0);
    }

    pub fn set_persistence(&mut self, value: f32) {
        self.persistence = value.clamp(0.0, 1.0);
    }

    pub fn set_tessitura_center(&mut self, value: f32) {
        self.tessitura_center = value;
    }

    pub fn set_tessitura_gravity(&mut self, value: f32) {
        self.tessitura_gravity = value;
    }
}

impl PitchCore for PitchHillClimbPitchCore {
    fn propose_target<R: Rng + ?Sized>(
        &mut self,
        current_pitch_log2: f32,
        current_target_log2: f32,
        _current_freq_hz: f32,
        integration_window: f32,
        landscape: &Landscape,
        perceptual: &PerceptualContext,
        _features: &FeaturesNow,
        rng: &mut R,
    ) -> TargetProposal {
        let (fmin, fmax) = landscape.freq_bounds_log2();
        let current_target_log2 = current_target_log2.clamp(fmin, fmax);
        let perfect_fifth = 1.5f32.log2();
        let imperfect_fifth = 0.66f32.log2();
        let mut candidates = vec![
            current_target_log2,
            current_target_log2 + self.neighbor_step_log2,
            current_target_log2 - self.neighbor_step_log2,
            current_target_log2 + perfect_fifth,
            current_target_log2 + imperfect_fifth,
        ];
        candidates.retain(|f| f.is_finite());

        let adjusted_score = |pitch_log2: f32| -> f32 {
            let clamped = pitch_log2.clamp(fmin, fmax);
            let score = landscape.evaluate_pitch01_log2(clamped);
            let distance_oct = (clamped - current_pitch_log2).abs();
            let penalty = distance_oct * integration_window * 0.5;
            let dist = clamped - self.tessitura_center;
            let gravity_penalty = dist * dist * self.tessitura_gravity;
            let base = score - penalty - gravity_penalty;
            let idx = landscape.space.index_of_log2(clamped).unwrap_or(0);
            base + perceptual.score_adjustment(idx)
        };

        let mut best_pitch = current_target_log2;
        let mut best_score = f32::MIN;
        for p in candidates {
            let clamped = p.clamp(fmin, fmax);
            let adjusted = adjusted_score(clamped);
            if adjusted > best_score {
                best_score = adjusted;
                best_pitch = clamped;
            }
        }

        let current_adjusted = adjusted_score(current_target_log2);
        let improvement = best_score - current_adjusted;
        let mut target_pitch_log2 = current_target_log2;

        if improvement > self.improvement_threshold {
            target_pitch_log2 = best_pitch;
        } else {
            let satisfaction = ((current_adjusted + 1.0) * 0.5).clamp(0.0, 1.0);
            let mut stay_prob = self.persistence.clamp(0.0, 1.0) * satisfaction;
            stay_prob = stay_prob.clamp(0.0, 1.0);
            let exploration = self.exploration.clamp(0.0, 1.0);
            stay_prob = (stay_prob * (1.0 - exploration)).clamp(0.0, 1.0);
            if rng.random_range(0.0..1.0) > stay_prob {
                target_pitch_log2 = best_pitch;
            }
        }

        TargetProposal {
            target_pitch_log2,
            salience: (improvement / 0.2).clamp(0.0, 1.0),
        }
    }

    fn propose_freqs_hz_with_neighbors(
        &mut self,
        base_freq_hz: f32,
        neighbor_freqs_hz: &[f32],
        max_candidates: usize,
        min_candidates: usize,
        dedupe_cents: f32,
    ) -> Vec<f32> {
        if max_candidates == 0 || !base_freq_hz.is_finite() || base_freq_hz <= 0.0 {
            return Vec::new();
        }
        let mut candidates = Vec::new();
        let lo = base_freq_hz * 0.5;
        let hi = base_freq_hz * 2.0;

        if !neighbor_freqs_hz.is_empty() {
            for &neighbor in neighbor_freqs_hz {
                if !neighbor.is_finite() || neighbor <= 0.0 {
                    continue;
                }
                for &ratio in HARMONIC_RATIOS {
                    let r = ratio_to_f32(ratio);
                    let forward = fold_to_octave_near(neighbor * r, base_freq_hz, lo, hi);
                    let inverse = fold_to_octave_near(neighbor / r, base_freq_hz, lo, hi);
                    candidates.push(forward);
                    candidates.push(inverse);
                }
            }
        }

        candidates = dedupe_by_cents(candidates, dedupe_cents);
        candidates.sort_by(|a, b| cmp_by_base(*a, *b, base_freq_hz));

        if candidates.len() < min_candidates {
            let steps = [
                -12.0, -9.0, -7.0, -5.0, -4.0, -3.0, -2.0, 0.0, 2.0, 3.0, 4.0, 5.0, 7.0, 9.0, 12.0,
            ];
            for &step in &steps {
                let freq = base_freq_hz * 2.0f32.powf(step / 12.0);
                let folded = fold_to_octave_near(freq, base_freq_hz, lo, hi);
                candidates.push(folded);
            }
            candidates = dedupe_by_cents(candidates, dedupe_cents);
            candidates.sort_by(|a, b| cmp_by_base(*a, *b, base_freq_hz));
        }

        candidates
            .into_iter()
            .filter(|f| f.is_finite() && *f > 0.0 && *f >= 20.0 && *f <= 20_000.0)
            .take(max_candidates)
            .collect()
    }
}

fn dedupe_by_cents(mut freqs: Vec<f32>, dedupe_cents: f32) -> Vec<f32> {
    if freqs.is_empty() {
        return freqs;
    }
    freqs.retain(|f| f.is_finite() && *f > 0.0);
    freqs.sort_by(|a, b| a.total_cmp(b));
    let mut out = Vec::with_capacity(freqs.len());
    let mut last: Option<f32> = None;
    for f in freqs {
        if let Some(prev) = last {
            let cents = 1200.0f32 * (f / prev).log2().abs();
            if cents < dedupe_cents {
                continue;
            }
        }
        last = Some(f);
        out.push(f);
    }
    out
}

fn cmp_by_base(a: f32, b: f32, base: f32) -> std::cmp::Ordering {
    let base = if base.is_finite() && base > 0.0 {
        base
    } else {
        1.0
    };
    let da = (a / base).log2().abs();
    let db = (b / base).log2().abs();
    da.total_cmp(&db).then_with(|| a.total_cmp(&b))
}

#[derive(Debug, Clone)]
pub enum AnyPitchCore {
    PitchHillClimb(PitchHillClimbPitchCore),
}

impl PitchCore for AnyPitchCore {
    fn propose_target<R: Rng + ?Sized>(
        &mut self,
        current_pitch_log2: f32,
        current_target_log2: f32,
        current_freq_hz: f32,
        integration_window: f32,
        landscape: &Landscape,
        perceptual: &PerceptualContext,
        features: &FeaturesNow,
        rng: &mut R,
    ) -> TargetProposal {
        match self {
            AnyPitchCore::PitchHillClimb(core) => core.propose_target(
                current_pitch_log2,
                current_target_log2,
                current_freq_hz,
                integration_window,
                landscape,
                perceptual,
                features,
                rng,
            ),
        }
    }

    fn propose_freqs_hz_with_neighbors(
        &mut self,
        base_freq_hz: f32,
        neighbor_freqs_hz: &[f32],
        max_candidates: usize,
        min_candidates: usize,
        dedupe_cents: f32,
    ) -> Vec<f32> {
        match self {
            AnyPitchCore::PitchHillClimb(core) => core.propose_freqs_hz_with_neighbors(
                base_freq_hz,
                neighbor_freqs_hz,
                max_candidates,
                min_candidates,
                dedupe_cents,
            ),
        }
    }
}

impl AnyPitchCore {
    pub fn from_config<R: Rng + ?Sized>(
        config: &PitchCoreConfig,
        initial_pitch_log2: f32,
        _rng: &mut R,
    ) -> Self {
        match config {
            PitchCoreConfig::PitchHillClimb {
                neighbor_step_cents,
                tessitura_gravity,
                improvement_threshold,
                exploration,
                persistence,
            } => {
                let neighbor_step_cents = neighbor_step_cents.unwrap_or(200.0);
                let tessitura_gravity = tessitura_gravity.unwrap_or(0.1);
                let improvement_threshold = improvement_threshold.unwrap_or(0.1);
                let exploration = exploration.unwrap_or(0.0);
                let persistence = persistence.unwrap_or(0.5);
                AnyPitchCore::PitchHillClimb(PitchHillClimbPitchCore::new(
                    neighbor_step_cents,
                    initial_pitch_log2,
                    tessitura_gravity,
                    improvement_threshold,
                    exploration,
                    persistence,
                ))
            }
        }
    }

    pub fn set_exploration(&mut self, value: f32) {
        match self {
            AnyPitchCore::PitchHillClimb(core) => core.set_exploration(value),
        }
    }

    pub fn set_persistence(&mut self, value: f32) {
        match self {
            AnyPitchCore::PitchHillClimb(core) => core.set_persistence(value),
        }
    }

    pub fn set_tessitura_center(&mut self, value: f32) {
        match self {
            AnyPitchCore::PitchHillClimb(core) => core.set_tessitura_center(value),
        }
    }

    pub fn set_tessitura_gravity(&mut self, value: f32) {
        match self {
            AnyPitchCore::PitchHillClimb(core) => core.set_tessitura_gravity(value),
        }
    }
}
</file>

<file path="src/life/sound_body.rs">
use super::articulation_core::{ArticulationSignal, PinkNoise};
use crate::core::log2space::Log2Space;
use crate::life::scenario::{HarmonicMode, SoundBodyConfig, TimbreGenotype};
use rand::Rng;
use std::f32::consts::PI;

pub trait SoundBody {
    fn base_freq_hz(&self) -> f32;
    fn set_freq(&mut self, freq: f32);
    fn set_pitch_log2(&mut self, log_freq: f32);
    fn set_amp(&mut self, amp: f32);
    fn amp(&self) -> f32;
    fn articulate_wave(&mut self, sample: &mut f32, fs: f32, dt: f32, signal: &ArticulationSignal);
    fn project_spectral_body(
        &mut self,
        amps: &mut [f32],
        space: &Log2Space,
        signal: &ArticulationSignal,
    );
}

fn add_log2_energy(amps: &mut [f32], space: &Log2Space, freq_hz: f32, energy: f32) {
    if !freq_hz.is_finite() || energy == 0.0 {
        return;
    }
    if freq_hz < space.fmin || freq_hz > space.fmax {
        return;
    }
    let log_f = freq_hz.log2();
    let base = space.centers_log2[0];
    let step = space.step();
    let pos = (log_f - base) / step;
    let idx_base = pos.floor();
    let idx = idx_base as isize;
    if idx < 0 {
        return;
    }
    let idx = idx as usize;
    let frac = pos - idx_base;
    if idx + 1 < amps.len() {
        amps[idx] += energy * (1.0 - frac);
        amps[idx + 1] += energy * frac;
    } else if idx < amps.len() {
        amps[idx] += energy;
    }
}

#[derive(Debug, Clone)]
pub struct SineBody {
    pub freq_hz: f32,
    pub amp: f32,
    pub audio_phase: f32,
}

impl SoundBody for SineBody {
    fn base_freq_hz(&self) -> f32 {
        self.freq_hz
    }

    fn set_freq(&mut self, freq: f32) {
        self.freq_hz = freq;
    }

    fn set_pitch_log2(&mut self, log_freq: f32) {
        self.freq_hz = 2.0f32.powf(log_freq);
    }

    fn set_amp(&mut self, amp: f32) {
        self.amp = amp;
    }

    fn amp(&self) -> f32 {
        self.amp
    }

    fn articulate_wave(
        &mut self,
        sample: &mut f32,
        _fs: f32,
        dt: f32,
        signal: &ArticulationSignal,
    ) {
        if !signal.is_active || signal.amplitude <= 0.0 {
            return;
        }
        self.audio_phase = (self.audio_phase + 2.0 * PI * self.freq_hz * dt).rem_euclid(2.0 * PI);
        *sample += self.amp * signal.amplitude * self.audio_phase.sin();
    }

    fn project_spectral_body(
        &mut self,
        amps: &mut [f32],
        space: &Log2Space,
        signal: &ArticulationSignal,
    ) {
        if !signal.is_active || signal.amplitude <= 0.0 {
            return;
        }
        let energy = self.amp.max(0.0) * signal.amplitude;
        add_log2_energy(amps, space, self.freq_hz, energy);
    }
}

#[derive(Debug, Clone)]
pub struct HarmonicBody {
    pub base_freq_hz: f32,
    pub amp: f32,
    pub genotype: TimbreGenotype,
    pub lfo_phase: f32,
    pub phases: Vec<f32>,
    pub detune_phases: Vec<f32>,
    pub jitter_gen: PinkNoise,
}

impl HarmonicBody {
    fn partial_ratio(&self, idx: usize) -> f32 {
        let k = (idx + 1) as f32;
        let base = match self.genotype.mode {
            HarmonicMode::Harmonic => k,
            HarmonicMode::Metallic => k.powf(1.4),
        };
        let stretch = 1.0 + self.genotype.stiffness * k * k;
        (base * stretch).max(0.1)
    }

    fn compute_partial_amp(&self, idx: usize, current_energy: f32) -> f32 {
        let k = (idx + 1) as f32;
        let slope = self.genotype.brightness.max(0.0);
        let mut amp = 1.0 / k.powf(slope.max(1e-6));
        if (idx + 1).is_multiple_of(2) {
            amp *= 1.0 - self.genotype.comb.clamp(0.0, 1.0);
        }
        let damping = self.genotype.damping.max(0.0);
        if damping > 0.0 {
            let energy = current_energy.clamp(0.0, 1.0);
            amp *= energy.powf(damping * k);
        }
        amp
    }

    fn partial_count(&self) -> usize {
        self.phases.len().min(self.detune_phases.len())
    }
}

impl SoundBody for HarmonicBody {
    fn base_freq_hz(&self) -> f32 {
        self.base_freq_hz
    }

    fn set_freq(&mut self, freq: f32) {
        self.base_freq_hz = freq;
    }

    fn set_pitch_log2(&mut self, log_freq: f32) {
        self.base_freq_hz = 2.0f32.powf(log_freq);
    }

    fn set_amp(&mut self, amp: f32) {
        self.amp = amp;
    }

    fn amp(&self) -> f32 {
        self.amp
    }

    fn articulate_wave(
        &mut self,
        sample: &mut f32,
        _fs: f32,
        dt: f32,
        signal: &ArticulationSignal,
    ) {
        if !signal.is_active || signal.amplitude <= 0.0 {
            return;
        }
        let partials = self.partial_count();
        if partials == 0 {
            return;
        }
        self.lfo_phase =
            (self.lfo_phase + 2.0 * PI * self.genotype.vibrato_rate * dt).rem_euclid(2.0 * PI);
        let vibrato =
            self.genotype.vibrato_depth * (1.0 + signal.relaxation * 0.5) * self.lfo_phase.sin();
        let jitter_scale = (1.0 + signal.tension * 0.5) * (signal.amplitude + 0.1);
        let jitter = self.jitter_gen.sample() * self.genotype.jitter * jitter_scale;
        let base_freq = (self.base_freq_hz * (1.0 + vibrato + jitter)).max(1.0);
        let unison = (self.genotype.unison * (1.0 + signal.relaxation * 0.5)).max(0.0);

        let mut acc = 0.0;
        for idx in 0..partials {
            let ratio = self.partial_ratio(idx);
            let freq = base_freq * ratio;
            if !freq.is_finite() || freq <= 0.0 {
                continue;
            }
            let part_amp = self.compute_partial_amp(idx, signal.amplitude);
            if part_amp <= 0.0 {
                continue;
            }
            let phase = &mut self.phases[idx];
            *phase = (*phase + 2.0 * PI * freq * dt).rem_euclid(2.0 * PI);
            let mut part_sample = phase.sin();
            if unison > 0.0 {
                let detune_ratio = 1.0 + unison * 0.02;
                let detune_phase = &mut self.detune_phases[idx];
                *detune_phase =
                    (*detune_phase + 2.0 * PI * freq * detune_ratio * dt).rem_euclid(2.0 * PI);
                part_sample = 0.5 * (part_sample + detune_phase.sin());
            }
            acc += part_amp * part_sample;
        }
        *sample += self.amp * signal.amplitude * acc;
    }

    fn project_spectral_body(
        &mut self,
        amps: &mut [f32],
        space: &Log2Space,
        signal: &ArticulationSignal,
    ) {
        if !signal.is_active || signal.amplitude <= 0.0 {
            return;
        }
        let partials = self.partial_count();
        if partials == 0 {
            return;
        }
        let amp_scale = self.amp.max(0.0) * signal.amplitude;
        for idx in 0..partials {
            let ratio = self.partial_ratio(idx);
            let freq = self.base_freq_hz * ratio;
            let part_amp = self.compute_partial_amp(idx, signal.amplitude);
            add_log2_energy(amps, space, freq, amp_scale * part_amp);
        }
    }
}

#[derive(Debug, Clone)]
pub enum AnySoundBody {
    Sine(SineBody),
    Harmonic(HarmonicBody),
}

impl AnySoundBody {
    pub fn from_config<R: Rng + ?Sized>(
        config: &SoundBodyConfig,
        freq_hz: f32,
        amp: f32,
        rng: &mut R,
    ) -> Self {
        match config {
            SoundBodyConfig::Sine { phase } => AnySoundBody::Sine(SineBody {
                freq_hz,
                amp,
                audio_phase: phase.unwrap_or_else(|| rng.random_range(0.0..std::f32::consts::TAU)),
            }),
            SoundBodyConfig::Harmonic { genotype, partials } => {
                let partials = partials.unwrap_or(16).max(1);
                let mut phases = Vec::with_capacity(partials);
                let mut detune_phases = Vec::with_capacity(partials);
                for _ in 0..partials {
                    phases.push(rng.random_range(0.0..std::f32::consts::TAU));
                    detune_phases.push(rng.random_range(0.0..std::f32::consts::TAU));
                }
                AnySoundBody::Harmonic(HarmonicBody {
                    base_freq_hz: freq_hz,
                    amp,
                    genotype: genotype.clone(),
                    lfo_phase: 0.0,
                    phases,
                    detune_phases,
                    jitter_gen: PinkNoise::new(rng.next_u64(), 0.001),
                })
            }
        }
    }
}

impl SoundBody for AnySoundBody {
    fn base_freq_hz(&self) -> f32 {
        match self {
            AnySoundBody::Sine(body) => body.base_freq_hz(),
            AnySoundBody::Harmonic(body) => body.base_freq_hz(),
        }
    }

    fn set_freq(&mut self, freq: f32) {
        match self {
            AnySoundBody::Sine(body) => body.set_freq(freq),
            AnySoundBody::Harmonic(body) => body.set_freq(freq),
        }
    }

    fn set_pitch_log2(&mut self, log_freq: f32) {
        match self {
            AnySoundBody::Sine(body) => body.set_pitch_log2(log_freq),
            AnySoundBody::Harmonic(body) => body.set_pitch_log2(log_freq),
        }
    }

    fn set_amp(&mut self, amp: f32) {
        match self {
            AnySoundBody::Sine(body) => body.set_amp(amp),
            AnySoundBody::Harmonic(body) => body.set_amp(amp),
        }
    }

    fn amp(&self) -> f32 {
        match self {
            AnySoundBody::Sine(body) => body.amp(),
            AnySoundBody::Harmonic(body) => body.amp(),
        }
    }

    fn articulate_wave(&mut self, sample: &mut f32, fs: f32, dt: f32, signal: &ArticulationSignal) {
        match self {
            AnySoundBody::Sine(body) => body.articulate_wave(sample, fs, dt, signal),
            AnySoundBody::Harmonic(body) => body.articulate_wave(sample, fs, dt, signal),
        }
    }

    fn project_spectral_body(
        &mut self,
        amps: &mut [f32],
        space: &Log2Space,
        signal: &ArticulationSignal,
    ) {
        match self {
            AnySoundBody::Sine(body) => body.project_spectral_body(amps, space, signal),
            AnySoundBody::Harmonic(body) => body.project_spectral_body(amps, space, signal),
        }
    }
}
</file>

<file path="src/synth/resonator.rs">
//! Resonator bank using a damped Modified Coupled Form (Hz, sec).
//! x = r*(x - e*y) + b1*u, y = r*(e*x + y) + b2*u

use crate::synth::SynthError;
use crate::synth::modes::{ModeParams, compile_mode};
use std::f32::consts::PI;
#[cfg(feature = "simd-wide")]
use wide::{f32x4, f32x8};

// Use fused mul-add only when the SIMD path can also fuse, to keep outputs aligned.
#[cfg(any(target_feature = "fma", target_feature = "neon"))]
#[inline(always)]
fn mul_add_fast(a: f32, b: f32, c: f32) -> f32 {
    a.mul_add(b, c)
}

#[cfg(not(any(target_feature = "fma", target_feature = "neon")))]
#[inline(always)]
fn mul_add_fast(a: f32, b: f32, c: f32) -> f32 {
    a * b + c
}

/// Bank of resonators in a struct-of-arrays layout.
#[derive(Debug, Clone)]
pub struct ResonatorBank {
    fs: f32,
    capacity: usize,
    active_len: usize,
    x: Vec<f32>,
    y: Vec<f32>,
    e: Vec<f32>,
    r: Vec<f32>,
    b1: Vec<f32>,
    b2: Vec<f32>,
    gain: Vec<f32>,
    theta: Vec<f32>,
}

impl ResonatorBank {
    /// Create a new bank with a fixed capacity.
    pub fn new(fs: f32, max_modes: usize) -> Result<Self, SynthError> {
        if !fs.is_finite() || fs <= 0.0 {
            return Err(SynthError::InvalidSampleRate);
        }

        let mut x = Vec::with_capacity(max_modes);
        x.resize(max_modes, 0.0);
        let mut y = Vec::with_capacity(max_modes);
        y.resize(max_modes, 0.0);
        let mut e = Vec::with_capacity(max_modes);
        e.resize(max_modes, 0.0);
        let mut r = Vec::with_capacity(max_modes);
        r.resize(max_modes, 0.0);
        let mut b1 = Vec::with_capacity(max_modes);
        b1.resize(max_modes, 0.0);
        let mut b2 = Vec::with_capacity(max_modes);
        b2.resize(max_modes, 0.0);
        let mut gain = Vec::with_capacity(max_modes);
        gain.resize(max_modes, 0.0);
        let mut theta = Vec::with_capacity(max_modes);
        theta.resize(max_modes, 0.0);

        Ok(Self {
            fs,
            capacity: max_modes,
            active_len: 0,
            x,
            y,
            e,
            r,
            b1,
            b2,
            gain,
            theta,
        })
    }

    /// Sample rate in Hz.
    pub fn fs(&self) -> f32 {
        self.fs
    }

    /// Maximum number of modes.
    pub fn capacity(&self) -> usize {
        self.capacity
    }

    /// Active number of modes.
    pub fn active_len(&self) -> usize {
        self.active_len
    }

    /// Reset all internal states to zero.
    pub fn reset_state(&mut self) {
        for v in &mut self.x {
            *v = 0.0;
        }
        for v in &mut self.y {
            *v = 0.0;
        }
    }

    /// Set mode parameters and compile coefficients, resetting state to zero.
    pub fn set_modes(&mut self, modes: &[ModeParams]) -> Result<(), SynthError> {
        if modes.len() > self.capacity {
            return Err(SynthError::TooManyModes {
                requested: modes.len(),
                capacity: self.capacity,
            });
        }

        self.active_len = modes.len();
        self.reset_state();

        for (i, params) in modes.iter().enumerate() {
            let coeffs = compile_mode(params, self.fs);
            self.e[i] = coeffs.e;
            self.r[i] = coeffs.r;
            self.b1[i] = coeffs.b1;
            self.b2[i] = coeffs.b2;
            self.gain[i] = coeffs.gain;
            self.theta[i] = 2.0 * PI * params.freq_hz / self.fs;
        }

        Ok(())
    }

    /// Set mode parameters and compile coefficients, preserving existing state where possible.
    pub fn set_modes_preserve_state(&mut self, modes: &[ModeParams]) -> Result<(), SynthError> {
        if modes.len() > self.capacity {
            return Err(SynthError::TooManyModes {
                requested: modes.len(),
                capacity: self.capacity,
            });
        }

        let old_len = self.active_len;
        let new_len = modes.len();
        self.active_len = new_len;

        if new_len > old_len {
            for i in old_len..new_len {
                self.x[i] = 0.0;
                self.y[i] = 0.0;
            }
        }

        for (i, params) in modes.iter().enumerate() {
            let coeffs = compile_mode(params, self.fs);
            self.e[i] = coeffs.e;
            self.r[i] = coeffs.r;
            self.b1[i] = coeffs.b1;
            self.b2[i] = coeffs.b2;
            self.gain[i] = coeffs.gain;
            self.theta[i] = 2.0 * PI * params.freq_hz / self.fs;
        }

        Ok(())
    }

    /// Blog baseline: naive per-sample sin/cos rotation with damping.
    #[allow(dead_code)]
    fn process_sample_naive_sin(&mut self, u: f32) -> f32 {
        let mut out = 0.0;
        for i in 0..self.active_len {
            let (s, c) = self.theta[i].sin_cos();
            let r = self.r[i];
            let b1 = self.b1[i];
            let b2 = self.b2[i];
            let gain = self.gain[i];

            let x0 = self.x[i];
            let y0 = self.y[i];

            let rot_x = mul_add_fast(c, x0, -s * y0);
            let rot_y = mul_add_fast(s, x0, c * y0);
            let x1 = mul_add_fast(r, rot_x, b1 * u);
            let y1 = mul_add_fast(r, rot_y, b2 * u);

            self.x[i] = x1;
            self.y[i] = y1;

            out = mul_add_fast(gain, y1, out);
        }

        out
    }

    /// Reference scalar MCF update (no denormal flushing).
    #[allow(dead_code)]
    fn process_sample_ref(&mut self, u: f32) -> f32 {
        let mut out = 0.0;
        for i in 0..self.active_len {
            let e = self.e[i];
            let r = self.r[i];
            let b1 = self.b1[i];
            let b2 = self.b2[i];
            let gain = self.gain[i];

            let x0 = self.x[i];
            let y0 = self.y[i];

            let x1 = r * (x0 - e * y0) + b1 * u;
            let y1 = r * (e * x1 + y0) + b2 * u;

            self.x[i] = x1;
            self.y[i] = y1;

            out += gain * y1;
        }

        out
    }

    /// Blog baseline: scalar MCF update with bounds-checked slices.
    #[allow(dead_code)]
    fn process_sample_magic_scalar_basic(&mut self, u: f32) -> f32 {
        let n = self.active_len;
        let x = &mut self.x[..n];
        let y = &mut self.y[..n];
        let e = &self.e[..n];
        let r = &self.r[..n];
        let b1 = &self.b1[..n];
        let b2 = &self.b2[..n];
        let gain = &self.gain[..n];

        let mut out = 0.0;
        for i in 0..n {
            let x0 = x[i];
            let y0 = y[i];

            let x1 = mul_add_fast(r[i], mul_add_fast(-e[i], y0, x0), b1[i] * u);
            let y1 = mul_add_fast(r[i], mul_add_fast(e[i], x1, y0), b2[i] * u);

            x[i] = x1;
            y[i] = y1;

            out = mul_add_fast(gain[i], y1, out);
        }

        out
    }

    #[allow(dead_code)]
    fn process_sample_scalar(&mut self, u: f32) -> f32 {
        self.process_sample_magic_scalar_basic(u)
    }

    /// Scalar MCF update with unchecked indexing to remove bounds checks.
    #[allow(dead_code)]
    fn process_sample_magic_scalar_unsafe(&mut self, u: f32) -> f32 {
        let n = self.active_len;
        let x_ptr = self.x.as_mut_ptr();
        let y_ptr = self.y.as_mut_ptr();
        let e_ptr = self.e.as_ptr();
        let r_ptr = self.r.as_ptr();
        let b1_ptr = self.b1.as_ptr();
        let b2_ptr = self.b2.as_ptr();
        let gain_ptr = self.gain.as_ptr();

        let mut out = 0.0;

        // Safety: all arrays have length >= active_len, and we only access 0..n.
        unsafe {
            for i in 0..n {
                let x0 = *x_ptr.add(i);
                let y0 = *y_ptr.add(i);
                let e = *e_ptr.add(i);
                let r = *r_ptr.add(i);
                let b1 = *b1_ptr.add(i);
                let b2 = *b2_ptr.add(i);
                let gain = *gain_ptr.add(i);

                let x1 = mul_add_fast(r, mul_add_fast(-e, y0, x0), b1 * u);
                let y1 = mul_add_fast(r, mul_add_fast(e, x1, y0), b2 * u);

                *x_ptr.add(i) = x1;
                *y_ptr.add(i) = y1;

                out = mul_add_fast(gain, y1, out);
            }
        }

        out
    }

    /// Blog baseline: safe SIMD with f32x8 and slice copies.
    #[cfg(feature = "simd-wide")]
    fn process_sample_simd_wide8(&mut self, u: f32) -> f32 {
        let n = self.active_len;
        let n8 = n & !7;
        let x = &mut self.x[..n];
        let y = &mut self.y[..n];
        let e = &self.e[..n];
        let r = &self.r[..n];
        let b1 = &self.b1[..n];
        let b2 = &self.b2[..n];
        let gain = &self.gain[..n];

        let mut out = 0.0;
        let u_vec = f32x8::splat(u);

        for i in (0..n8).step_by(8) {
            let x0_arr: [f32; 8] = x[i..i + 8].try_into().unwrap();
            let y0_arr: [f32; 8] = y[i..i + 8].try_into().unwrap();
            let e_arr: [f32; 8] = e[i..i + 8].try_into().unwrap();
            let r_arr: [f32; 8] = r[i..i + 8].try_into().unwrap();
            let b1_arr: [f32; 8] = b1[i..i + 8].try_into().unwrap();
            let b2_arr: [f32; 8] = b2[i..i + 8].try_into().unwrap();

            let x0 = f32x8::from(x0_arr);
            let y0 = f32x8::from(y0_arr);
            let e_vec = f32x8::from(e_arr);
            let r_vec = f32x8::from(r_arr);
            let b1_vec = f32x8::from(b1_arr);
            let b2_vec = f32x8::from(b2_arr);

            let rot = e_vec.mul_add(-y0, x0);
            let x1_vec = r_vec.mul_add(rot, b1_vec * u_vec);
            let y1_vec = r_vec.mul_add(e_vec.mul_add(x1_vec, y0), b2_vec * u_vec);

            let x1_arr = x1_vec.to_array();
            let y1_arr = y1_vec.to_array();

            x[i..i + 8].copy_from_slice(&x1_arr);
            y[i..i + 8].copy_from_slice(&y1_arr);

            for k in 0..8 {
                out = mul_add_fast(gain[i + k], y1_arr[k], out);
            }
        }

        for i in n8..n {
            let x0 = x[i];
            let y0 = y[i];

            let x1 = mul_add_fast(r[i], mul_add_fast(-e[i], y0, x0), b1[i] * u);
            let y1 = mul_add_fast(r[i], mul_add_fast(e[i], x1, y0), b2[i] * u);

            x[i] = x1;
            y[i] = y1;

            out = mul_add_fast(gain[i], y1, out);
        }

        out
    }

    /// SIMD with f32x8 plus a single f32x4 tail (safe slices).
    #[cfg(feature = "simd-wide")]
    fn process_sample_simd_wide8_tail4(&mut self, u: f32) -> f32 {
        let n = self.active_len;
        let n8 = n & !7;
        let x = &mut self.x[..n];
        let y = &mut self.y[..n];
        let e = &self.e[..n];
        let r = &self.r[..n];
        let b1 = &self.b1[..n];
        let b2 = &self.b2[..n];
        let gain = &self.gain[..n];

        let mut out = 0.0;
        let u8 = f32x8::splat(u);
        let u4 = f32x4::splat(u);

        for i in (0..n8).step_by(8) {
            let x0_arr: [f32; 8] = x[i..i + 8].try_into().unwrap();
            let y0_arr: [f32; 8] = y[i..i + 8].try_into().unwrap();
            let e_arr: [f32; 8] = e[i..i + 8].try_into().unwrap();
            let r_arr: [f32; 8] = r[i..i + 8].try_into().unwrap();
            let b1_arr: [f32; 8] = b1[i..i + 8].try_into().unwrap();
            let b2_arr: [f32; 8] = b2[i..i + 8].try_into().unwrap();

            let x0 = f32x8::from(x0_arr);
            let y0 = f32x8::from(y0_arr);
            let e_vec = f32x8::from(e_arr);
            let r_vec = f32x8::from(r_arr);
            let b1_vec = f32x8::from(b1_arr);
            let b2_vec = f32x8::from(b2_arr);

            let rot = e_vec.mul_add(-y0, x0);
            let x1_vec = r_vec.mul_add(rot, b1_vec * u8);
            let y1_vec = r_vec.mul_add(e_vec.mul_add(x1_vec, y0), b2_vec * u8);

            let x1_arr = x1_vec.to_array();
            let y1_arr = y1_vec.to_array();

            x[i..i + 8].copy_from_slice(&x1_arr);
            y[i..i + 8].copy_from_slice(&y1_arr);

            for k in 0..8 {
                out = mul_add_fast(gain[i + k], y1_arr[k], out);
            }
        }

        let mut idx = n8;
        if n - n8 >= 4 {
            let x0_arr: [f32; 4] = x[idx..idx + 4].try_into().unwrap();
            let y0_arr: [f32; 4] = y[idx..idx + 4].try_into().unwrap();
            let e_arr: [f32; 4] = e[idx..idx + 4].try_into().unwrap();
            let r_arr: [f32; 4] = r[idx..idx + 4].try_into().unwrap();
            let b1_arr: [f32; 4] = b1[idx..idx + 4].try_into().unwrap();
            let b2_arr: [f32; 4] = b2[idx..idx + 4].try_into().unwrap();

            let x0 = f32x4::from(x0_arr);
            let y0 = f32x4::from(y0_arr);
            let e_vec = f32x4::from(e_arr);
            let r_vec = f32x4::from(r_arr);
            let b1_vec = f32x4::from(b1_arr);
            let b2_vec = f32x4::from(b2_arr);

            let rot = e_vec.mul_add(-y0, x0);
            let x1_vec = r_vec.mul_add(rot, b1_vec * u4);
            let y1_vec = r_vec.mul_add(e_vec.mul_add(x1_vec, y0), b2_vec * u4);

            let x1_arr = x1_vec.to_array();
            let y1_arr = y1_vec.to_array();

            x[idx..idx + 4].copy_from_slice(&x1_arr);
            y[idx..idx + 4].copy_from_slice(&y1_arr);

            for k in 0..4 {
                out = mul_add_fast(gain[idx + k], y1_arr[k], out);
            }

            idx += 4;
        }

        for i in idx..n {
            let x0 = x[i];
            let y0 = y[i];

            let x1 = mul_add_fast(r[i], mul_add_fast(-e[i], y0, x0), b1[i] * u);
            let y1 = mul_add_fast(r[i], mul_add_fast(e[i], x1, y0), b2[i] * u);

            x[i] = x1;
            y[i] = y1;

            out = mul_add_fast(gain[i], y1, out);
        }

        out
    }

    /// SIMD fast path with unsafe pointer access to reduce bounds checks/copies.
    #[cfg(feature = "simd-wide")]
    fn process_sample_simd_wide_fast(&mut self, u: f32) -> f32 {
        let n = self.active_len;
        let n8 = n & !7;
        let u8 = f32x8::splat(u);
        let u4 = f32x4::splat(u);

        let x_ptr = self.x.as_mut_ptr();
        let y_ptr = self.y.as_mut_ptr();
        let e_ptr = self.e.as_ptr();
        let r_ptr = self.r.as_ptr();
        let b1_ptr = self.b1.as_ptr();
        let b2_ptr = self.b2.as_ptr();
        let gain_ptr = self.gain.as_ptr();

        let mut out = 0.0;

        // Safety: all arrays have length >= active_len; loops only access valid lanes.
        unsafe {
            for i in (0..n8).step_by(8) {
                let x0_arr = std::ptr::read_unaligned(x_ptr.add(i) as *const [f32; 8]);
                let y0_arr = std::ptr::read_unaligned(y_ptr.add(i) as *const [f32; 8]);
                let e_arr = std::ptr::read_unaligned(e_ptr.add(i) as *const [f32; 8]);
                let r_arr = std::ptr::read_unaligned(r_ptr.add(i) as *const [f32; 8]);
                let b1_arr = std::ptr::read_unaligned(b1_ptr.add(i) as *const [f32; 8]);
                let b2_arr = std::ptr::read_unaligned(b2_ptr.add(i) as *const [f32; 8]);
                let gain_arr = std::ptr::read_unaligned(gain_ptr.add(i) as *const [f32; 8]);

                let x0 = f32x8::from(x0_arr);
                let y0 = f32x8::from(y0_arr);
                let e_vec = f32x8::from(e_arr);
                let r_vec = f32x8::from(r_arr);
                let b1_vec = f32x8::from(b1_arr);
                let b2_vec = f32x8::from(b2_arr);

                let rot = e_vec.mul_add(-y0, x0);
                let x1_vec = r_vec.mul_add(rot, b1_vec * u8);
                let y1_vec = r_vec.mul_add(e_vec.mul_add(x1_vec, y0), b2_vec * u8);

                let x1_arr = x1_vec.to_array();
                let y1_arr = y1_vec.to_array();

                std::ptr::write_unaligned(x_ptr.add(i) as *mut [f32; 8], x1_arr);
                std::ptr::write_unaligned(y_ptr.add(i) as *mut [f32; 8], y1_arr);

                for k in 0..8 {
                    out = mul_add_fast(gain_arr[k], y1_arr[k], out);
                }
            }

            let mut idx = n8;
            if n - n8 >= 4 {
                let x0_arr = std::ptr::read_unaligned(x_ptr.add(idx) as *const [f32; 4]);
                let y0_arr = std::ptr::read_unaligned(y_ptr.add(idx) as *const [f32; 4]);
                let e_arr = std::ptr::read_unaligned(e_ptr.add(idx) as *const [f32; 4]);
                let r_arr = std::ptr::read_unaligned(r_ptr.add(idx) as *const [f32; 4]);
                let b1_arr = std::ptr::read_unaligned(b1_ptr.add(idx) as *const [f32; 4]);
                let b2_arr = std::ptr::read_unaligned(b2_ptr.add(idx) as *const [f32; 4]);
                let gain_arr = std::ptr::read_unaligned(gain_ptr.add(idx) as *const [f32; 4]);

                let x0 = f32x4::from(x0_arr);
                let y0 = f32x4::from(y0_arr);
                let e_vec = f32x4::from(e_arr);
                let r_vec = f32x4::from(r_arr);
                let b1_vec = f32x4::from(b1_arr);
                let b2_vec = f32x4::from(b2_arr);

                let rot = e_vec.mul_add(-y0, x0);
                let x1_vec = r_vec.mul_add(rot, b1_vec * u4);
                let y1_vec = r_vec.mul_add(e_vec.mul_add(x1_vec, y0), b2_vec * u4);

                let x1_arr = x1_vec.to_array();
                let y1_arr = y1_vec.to_array();

                std::ptr::write_unaligned(x_ptr.add(idx) as *mut [f32; 4], x1_arr);
                std::ptr::write_unaligned(y_ptr.add(idx) as *mut [f32; 4], y1_arr);

                for k in 0..4 {
                    out = mul_add_fast(gain_arr[k], y1_arr[k], out);
                }

                idx += 4;
            }

            for i in idx..n {
                let x0 = *x_ptr.add(i);
                let y0 = *y_ptr.add(i);
                let e = *e_ptr.add(i);
                let r = *r_ptr.add(i);
                let b1 = *b1_ptr.add(i);
                let b2 = *b2_ptr.add(i);
                let gain = *gain_ptr.add(i);

                let x1 = mul_add_fast(r, mul_add_fast(-e, y0, x0), b1 * u);
                let y1 = mul_add_fast(r, mul_add_fast(e, x1, y0), b2 * u);

                *x_ptr.add(i) = x1;
                *y_ptr.add(i) = y1;

                out = mul_add_fast(gain, y1, out);
            }
        }

        out
    }

    /// Process a single sample with the damped MCF update.
    #[cfg(all(
        feature = "simd-wide",
        any(target_arch = "x86_64", target_arch = "aarch64")
    ))]
    pub fn process_sample(&mut self, u: f32) -> f32 {
        self.process_sample_simd_wide_fast(u)
    }

    /// Process a single sample with the damped MCF update.
    #[cfg(not(all(
        feature = "simd-wide",
        any(target_arch = "x86_64", target_arch = "aarch64")
    )))]
    pub fn process_sample(&mut self, u: f32) -> f32 {
        self.process_sample_magic_scalar_unsafe(u)
    }

    /// Bench hook: naive per-sample trig baseline.
    #[cfg(any(test, feature = "bench-hooks"))]
    pub fn process_block_mono_naive_sin(&mut self, input: &[f32], output: &mut [f32]) {
        assert_eq!(input.len(), output.len());
        for (u, y) in input.iter().copied().zip(output.iter_mut()) {
            *y = self.process_sample_naive_sin(u);
        }
    }

    /// Bench hook: magic-cycle scalar basic.
    #[cfg(any(test, feature = "bench-hooks"))]
    pub fn process_block_mono_magic_scalar_basic(&mut self, input: &[f32], output: &mut [f32]) {
        assert_eq!(input.len(), output.len());
        for (u, y) in input.iter().copied().zip(output.iter_mut()) {
            *y = self.process_sample_magic_scalar_basic(u);
        }
    }

    /// Bench hook: magic-cycle scalar unchecked.
    #[cfg(any(test, feature = "bench-hooks"))]
    pub fn process_block_mono_magic_scalar_unsafe(&mut self, input: &[f32], output: &mut [f32]) {
        assert_eq!(input.len(), output.len());
        for (u, y) in input.iter().copied().zip(output.iter_mut()) {
            *y = self.process_sample_magic_scalar_unsafe(u);
        }
    }

    /// Bench hook: SIMD safe f32x8 (initial version).
    #[cfg(all(any(test, feature = "bench-hooks"), feature = "simd-wide"))]
    pub fn process_block_mono_simd_safe8(&mut self, input: &[f32], output: &mut [f32]) {
        assert_eq!(input.len(), output.len());
        for (u, y) in input.iter().copied().zip(output.iter_mut()) {
            *y = self.process_sample_simd_wide8(u);
        }
    }

    /// Bench hook: SIMD f32x8 with a single f32x4 tail.
    #[cfg(all(any(test, feature = "bench-hooks"), feature = "simd-wide"))]
    pub fn process_block_mono_simd_tail4(&mut self, input: &[f32], output: &mut [f32]) {
        assert_eq!(input.len(), output.len());
        for (u, y) in input.iter().copied().zip(output.iter_mut()) {
            *y = self.process_sample_simd_wide8_tail4(u);
        }
    }

    /// Bench hook: SIMD fast unsafe path.
    #[cfg(all(any(test, feature = "bench-hooks"), feature = "simd-wide"))]
    pub fn process_block_mono_simd_fast(&mut self, input: &[f32], output: &mut [f32]) {
        assert_eq!(input.len(), output.len());
        for (u, y) in input.iter().copied().zip(output.iter_mut()) {
            *y = self.process_sample_simd_wide_fast(u);
        }
    }

    /// Process a mono block with the scalar backend (bench hook).
    #[cfg(any(test, feature = "bench-hooks"))]
    pub fn process_block_mono_scalar(&mut self, input: &[f32], output: &mut [f32]) {
        self.process_block_mono_magic_scalar_basic(input, output);
    }

    /// Process a mono block with the SIMD backend (bench hook).
    #[cfg(all(any(test, feature = "bench-hooks"), feature = "simd-wide"))]
    pub fn process_block_mono_simd(&mut self, input: &[f32], output: &mut [f32]) {
        self.process_block_mono_simd_safe8(input, output);
    }

    /// Process a mono block; input and output slices must be same length.
    pub fn process_block_mono(&mut self, input: &[f32], output: &mut [f32]) {
        assert_eq!(input.len(), output.len());
        for (u, y) in input.iter().copied().zip(output.iter_mut()) {
            *y = self.process_sample(u);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn set_modes_rejects_over_capacity() {
        let mut bank = ResonatorBank::new(48_000.0, 1).unwrap();
        let modes = [
            ModeParams {
                freq_hz: 220.0,
                t60_s: 0.5,
                gain: 1.0,
                in_gain: 1.0,
            },
            ModeParams {
                freq_hz: 330.0,
                t60_s: 0.5,
                gain: 1.0,
                in_gain: 1.0,
            },
        ];
        let err = bank.set_modes(&modes).unwrap_err();
        assert_eq!(
            err,
            SynthError::TooManyModes {
                requested: 2,
                capacity: 1
            }
        );
    }

    #[test]
    fn process_block_is_deterministic() {
        let mut bank = ResonatorBank::new(48_000.0, 2).unwrap();
        let modes = [
            ModeParams {
                freq_hz: 220.0,
                t60_s: 0.3,
                gain: 0.8,
                in_gain: 0.5,
            },
            ModeParams {
                freq_hz: 440.0,
                t60_s: 0.2,
                gain: 0.4,
                in_gain: 0.3,
            },
        ];
        bank.set_modes(&modes).unwrap();

        let input: Vec<f32> = (0..256).map(|i| ((i as f32) * 0.01).sin()).collect();
        let mut out_a = vec![0.0; input.len()];
        let mut out_b = vec![0.0; input.len()];

        bank.process_block_mono(&input, &mut out_a);
        bank.reset_state();
        bank.process_block_mono(&input, &mut out_b);

        for (a, b) in out_a.iter().zip(out_b.iter()) {
            assert_eq!(a, b);
        }
    }

    #[test]
    fn zero_input_does_not_grow() {
        let fs = 48_000.0;
        let mut bank = ResonatorBank::new(fs, 1).unwrap();
        let mode = ModeParams {
            freq_hz: 440.0,
            t60_s: 0.05,
            gain: 1.0,
            in_gain: 1.0,
        };
        bank.set_modes(&[mode]).unwrap();

        let _ = bank.process_sample(1.0);

        let mut max_abs: f32 = 0.0;
        let mut last: f32 = 0.0;
        for _ in 0..(fs as usize) {
            last = bank.process_sample(0.0);
            max_abs = max_abs.max(last.abs());
            assert!(last.is_finite());
        }

        assert!(max_abs < 2.0, "max_abs={max_abs}");
        assert!(last.abs() < 1.0e-2, "last={last}");
    }

    #[test]
    fn set_modes_does_not_reallocate() {
        let mut bank = ResonatorBank::new(48_000.0, 4).unwrap();
        let ptrs = (
            bank.x.as_ptr(),
            bank.y.as_ptr(),
            bank.e.as_ptr(),
            bank.r.as_ptr(),
            bank.b1.as_ptr(),
            bank.b2.as_ptr(),
            bank.gain.as_ptr(),
            bank.theta.as_ptr(),
        );
        let caps = (
            bank.x.capacity(),
            bank.y.capacity(),
            bank.e.capacity(),
            bank.r.capacity(),
            bank.b1.capacity(),
            bank.b2.capacity(),
            bank.gain.capacity(),
            bank.theta.capacity(),
        );

        let modes_a = [
            ModeParams {
                freq_hz: 220.0,
                t60_s: 0.5,
                gain: 1.0,
                in_gain: 0.1,
            },
            ModeParams {
                freq_hz: 330.0,
                t60_s: 0.3,
                gain: 0.5,
                in_gain: 0.2,
            },
        ];
        let modes_b = [ModeParams {
            freq_hz: 110.0,
            t60_s: 0.2,
            gain: 0.2,
            in_gain: 0.0,
        }];

        bank.set_modes(&modes_a).unwrap();
        assert_eq!(ptrs.0, bank.x.as_ptr());
        assert_eq!(ptrs.1, bank.y.as_ptr());
        assert_eq!(ptrs.2, bank.e.as_ptr());
        assert_eq!(ptrs.3, bank.r.as_ptr());
        assert_eq!(ptrs.4, bank.b1.as_ptr());
        assert_eq!(ptrs.5, bank.b2.as_ptr());
        assert_eq!(ptrs.6, bank.gain.as_ptr());
        assert_eq!(ptrs.7, bank.theta.as_ptr());
        assert_eq!(caps.0, bank.x.capacity());
        assert_eq!(caps.1, bank.y.capacity());
        assert_eq!(caps.2, bank.e.capacity());
        assert_eq!(caps.3, bank.r.capacity());
        assert_eq!(caps.4, bank.b1.capacity());
        assert_eq!(caps.5, bank.b2.capacity());
        assert_eq!(caps.6, bank.gain.capacity());
        assert_eq!(caps.7, bank.theta.capacity());

        bank.set_modes(&modes_b).unwrap();
        assert_eq!(ptrs.0, bank.x.as_ptr());
        assert_eq!(ptrs.1, bank.y.as_ptr());
        assert_eq!(ptrs.2, bank.e.as_ptr());
        assert_eq!(ptrs.3, bank.r.as_ptr());
        assert_eq!(ptrs.4, bank.b1.as_ptr());
        assert_eq!(ptrs.5, bank.b2.as_ptr());
        assert_eq!(ptrs.6, bank.gain.as_ptr());
        assert_eq!(ptrs.7, bank.theta.as_ptr());
        assert_eq!(caps.0, bank.x.capacity());
        assert_eq!(caps.1, bank.y.capacity());
        assert_eq!(caps.2, bank.e.capacity());
        assert_eq!(caps.3, bank.r.capacity());
        assert_eq!(caps.4, bank.b1.capacity());
        assert_eq!(caps.5, bank.b2.capacity());
        assert_eq!(caps.6, bank.gain.capacity());
        assert_eq!(caps.7, bank.theta.capacity());
    }

    #[test]
    fn preserve_state_keeps_xy_for_overlapping_modes() {
        let mut bank = ResonatorBank::new(48_000.0, 8).unwrap();
        let modes_old: Vec<ModeParams> = (0..8)
            .map(|i| ModeParams {
                freq_hz: 110.0 + i as f32 * 10.0,
                t60_s: 0.2,
                gain: 1.0,
                in_gain: 1.0,
            })
            .collect();
        bank.set_modes(&modes_old).unwrap();
        for i in 0..8 {
            bank.x[i] = i as f32 + 0.5;
            bank.y[i] = -(i as f32) - 0.25;
        }

        let modes_new: Vec<ModeParams> = (0..6)
            .map(|i| ModeParams {
                freq_hz: 220.0 + i as f32 * 20.0,
                t60_s: 0.1,
                gain: 0.5,
                in_gain: 0.5,
            })
            .collect();
        bank.set_modes_preserve_state(&modes_new).unwrap();

        for i in 0..6 {
            assert_eq!(bank.x[i], i as f32 + 0.5);
            assert_eq!(bank.y[i], -(i as f32) - 0.25);
        }
    }

    #[test]
    fn preserve_state_initializes_new_modes() {
        let mut bank = ResonatorBank::new(48_000.0, 8).unwrap();
        let modes_old: Vec<ModeParams> = (0..4)
            .map(|i| ModeParams {
                freq_hz: 110.0 + i as f32 * 10.0,
                t60_s: 0.2,
                gain: 1.0,
                in_gain: 1.0,
            })
            .collect();
        bank.set_modes(&modes_old).unwrap();
        for i in 0..4 {
            bank.x[i] = (i + 1) as f32;
            bank.y[i] = -((i + 1) as f32);
        }

        let modes_new: Vec<ModeParams> = (0..8)
            .map(|i| ModeParams {
                freq_hz: 220.0 + i as f32 * 20.0,
                t60_s: 0.1,
                gain: 0.5,
                in_gain: 0.5,
            })
            .collect();
        bank.set_modes_preserve_state(&modes_new).unwrap();

        for i in 0..4 {
            assert_eq!(bank.x[i], (i + 1) as f32);
            assert_eq!(bank.y[i], -((i + 1) as f32));
        }
        for i in 4..8 {
            assert_eq!(bank.x[i], 0.0);
            assert_eq!(bank.y[i], 0.0);
        }
    }

    #[test]
    fn new_rejects_invalid_sample_rate() {
        assert_eq!(
            ResonatorBank::new(0.0, 1).unwrap_err(),
            SynthError::InvalidSampleRate
        );
        assert_eq!(
            ResonatorBank::new(-1.0, 1).unwrap_err(),
            SynthError::InvalidSampleRate
        );
    }

    #[test]
    fn magic_circle_matches_sine_formula() {
        use std::f32::consts::PI;

        let fs = 48_000.0;
        let freq = 440.0;
        let theta = 2.0 * PI * freq / fs;
        let e = 2.0 * (0.5 * theta).sin();
        let denom = (0.5 * theta).cos();

        let mut bank = ResonatorBank::new(fs, 8).unwrap();
        bank.active_len = 8;
        for i in 0..8 {
            bank.x[i] = 1.0;
            bank.y[i] = 0.0;
            bank.e[i] = e;
            bank.r[i] = 1.0;
            bank.b1[i] = 0.0;
            bank.b2[i] = 0.0;
            bank.gain[i] = if i == 0 { 1.0 } else { 0.0 };
        }

        for n in 1..=256 {
            let y = bank.process_sample(0.0);
            let expected = (n as f32 * theta).sin() / denom;
            let err = (y - expected).abs();
            assert!(err < 1.0e-6, "n={n} y={y} expected={expected}");
        }
    }

    #[test]
    fn default_matches_reference_with_tolerance() {
        let mut bank = ResonatorBank::new(48_000.0, 16).unwrap();
        let mut modes = Vec::with_capacity(10);
        for i in 0..10 {
            modes.push(ModeParams {
                freq_hz: 110.0 + i as f32 * 27.5,
                t60_s: 0.05 + i as f32 * 0.01,
                gain: 0.2 + i as f32 * 0.01,
                in_gain: 0.1 + i as f32 * 0.005,
            });
        }
        bank.set_modes(&modes).unwrap();

        let mut bank_ref = bank.clone();
        let mut bank_def = bank.clone();
        for i in 0..1024 {
            let mut u = (i as f32 * 0.01).sin();
            if i == 0 {
                u += 1.0;
            }
            if i % 127 == 0 {
                u += 0.25;
            }
            let y_ref = bank_ref.process_sample_ref(u);
            let y_def = bank_def.process_sample(u);
            if cfg!(any(target_feature = "fma", target_feature = "neon")) {
                let err = (y_ref - y_def).abs();
                assert!(err < 1.0e-5, "i={i} y_ref={y_ref} y_def={y_def}");
            } else {
                assert_eq!(y_ref, y_def);
            }
        }
    }
}
</file>

<file path="src/ui/windows.rs">
use crate::core::db::amp_to_db;
use crate::ui::plots::{
    draw_rhythm_mandala, draw_roughness_harmonicity, log2_plot_hz, neural_activity_plot,
    plot_population_dynamics, spectrum_time_freq_axes, time_plot,
};
use crate::ui::viewdata::{PlaybackState, UiFrame};
use egui::{CentralPanel, Color32, TopBottomPanel, Vec2};
use egui_plot::{Plot, PlotPoints, Points};
use std::collections::VecDeque;
use std::sync::Arc;
use std::sync::atomic::{AtomicBool, Ordering};

fn format_time(sec: f32) -> String {
    let total_secs = sec.max(0.0).floor() as u64;
    let minutes = total_secs / 60;
    let seconds = total_secs % 60;
    format!("{minutes:02}:{seconds:02}")
}

fn draw_level_meters(
    ui: &mut egui::Ui,
    left_inst: f32,
    left_win: f32,
    right_inst: f32,
    right_win: f32,
    meter_width_scale: f32,
) {
    let meter_height = (ui.available_height() * 0.8).max(80.0);
    let label_width = 20.0;
    let meter_width = 22.0 * meter_width_scale;
    let spacing = 8.0;
    let pad_y = 4.0;
    let total_width = label_width + spacing + meter_width * 2.0 + spacing;
    let (rect, _resp) =
        ui.allocate_exact_size(Vec2::new(total_width, meter_height), egui::Sense::hover());
    let painter = ui.painter_at(rect);
    let min_db = -60.0;

    let inner = rect.shrink2(Vec2::new(0.0, pad_y));
    let to_height = |db: f32| ((db - min_db) / -min_db).clamp(0.0, 1.0) * inner.height();
    let color_for = |amp: f32| match amp_to_db(amp) {
        db if db >= 0.0 => egui::Color32::RED,
        db if db >= -6.0 => egui::Color32::YELLOW,
        _ => egui::Color32::GREEN,
    };

    // Tick labels
    for &db in &[0.0, -6.0, -12.0, -30.0, -60.0] {
        let h = to_height(db);
        let y = inner.bottom() - h;
        painter.text(
            egui::pos2(rect.left() + label_width - 2.0, y),
            egui::Align2::RIGHT_CENTER,
            format!("{db:.0}"),
            egui::FontId::proportional(11.0),
            ui.visuals().text_color(),
        );
    }

    let draw_meter = |p: &egui::Painter, base: egui::Pos2, inst: f32, win: f32, label: &str| {
        let inst_db = amp_to_db(inst).max(min_db);
        let win_db = amp_to_db(win).max(min_db);
        let inst_h = to_height(inst_db);
        let win_h = to_height(win_db);

        let m_rect = egui::Rect::from_min_size(
            base + egui::vec2(0.0, pad_y),
            Vec2::new(meter_width, inner.height()),
        );
        p.rect_stroke(
            m_rect,
            2.0,
            egui::Stroke::new(1.0, p.ctx().style().visuals.window_stroke().color),
            egui::StrokeKind::Inside,
        );
        let inst_rect = egui::Rect::from_min_size(
            egui::pos2(m_rect.left() + 3.0, m_rect.bottom() - inst_h),
            Vec2::new(meter_width - 6.0, inst_h),
        );
        p.rect_filled(inst_rect, 0.0, color_for(inst));

        let win_y = m_rect.bottom() - win_h;
        p.line_segment(
            [
                egui::pos2(m_rect.left() + 2.5, win_y),
                egui::pos2(m_rect.right() - 2.5, win_y),
            ],
            egui::Stroke::new(2.0, color_for(win)),
        );

        p.text(
            m_rect.center_top() + egui::vec2(0.0, 4.0),
            egui::Align2::CENTER_TOP,
            label,
            egui::FontId::proportional(12.0),
            p.ctx().style().visuals.text_color(),
        );
    };

    let left_origin = rect.left_top() + egui::vec2(label_width + spacing, 0.0);
    let right_origin = left_origin + egui::vec2(meter_width + spacing, 0.0);
    draw_meter(&painter, left_origin, left_inst, left_win, "L");
    draw_meter(&painter, right_origin, right_inst, right_win, "R");
}

fn split_widths(ui: &egui::Ui, ratio: f32, min_left: f32, min_right: f32) -> (f32, f32) {
    let sep = ui.spacing().item_spacing.x;
    let available = ui.available_width();
    let left_target = (available * ratio).max(min_left);
    let left_width = left_target.min((available - min_right - sep).max(0.0));
    let right_width = (available - left_width - sep).max(0.0);
    (left_width, right_width)
}

const INTENT_PLOT_HEIGHT: f32 = 120.0;
const INTENT_LIST_HEIGHT: f32 = 18.0;
const INTENT_HEADER_HEIGHT: f32 = 40.0;
const INTENT_BOARD_HEIGHT: f32 = INTENT_PLOT_HEIGHT + INTENT_LIST_HEIGHT + INTENT_HEADER_HEIGHT;

/// === Main window ===
#[allow(clippy::too_many_arguments)]
pub fn main_window(
    ctx: &egui::Context,
    frame: &UiFrame,
    rhythm_history: &VecDeque<(f64, crate::core::modulation::NeuralRhythms)>,
    dorsal_history: &VecDeque<(f64, crate::ui::viewdata::DorsalFrame)>,
    audio_error: Option<&str>,
    exit_flag: &Arc<AtomicBool>,
    start_flag: &Arc<AtomicBool>,
    show_raw_nsgt_power: &mut bool,
) {
    TopBottomPanel::top("top").show(ctx, |ui| {
        ui.horizontal(|ui| {
            ui.heading("Conchordal");
            ui.separator();
            let scenario = if frame.meta.scenario_name.is_empty() {
                "Unknown".to_string()
            } else {
                frame.meta.scenario_name.clone()
            };
            let scene = frame
                .meta
                .scene_name
                .clone()
                .unwrap_or_else(|| "—".to_string());
            ui.label(format!("Scenario: {scenario}"));
            ui.separator();
            ui.label(format!("Scene: {scene}"));
            ui.separator();
            ui.label(format!("Events: {}", frame.meta.event_queue_len));
        });

        let progress = if frame.meta.duration_sec > 0.0 {
            (frame.meta.time_sec / frame.meta.duration_sec).clamp(0.0, 1.0)
        } else {
            0.0
        };
        let progress_text = format!(
            "{} / {}",
            format_time(frame.meta.time_sec),
            format_time(frame.meta.duration_sec)
        );

        ui.horizontal(|ui| {
            let btn_size = 18.0;
            let bar_width =
                (ui.available_width() - btn_size - ui.spacing().item_spacing.x).max(50.0);
            ui.add(
                egui::ProgressBar::new(progress)
                    .text(progress_text)
                    .desired_width(bar_width),
            );

            let (rect, resp) = ui.allocate_exact_size(Vec2::splat(btn_size), egui::Sense::click());
            let painter = ui.painter_at(rect);
            let tooltip = match frame.meta.playback_state {
                PlaybackState::NotStarted => {
                    let points = vec![
                        rect.left_top(),
                        egui::pos2(rect.right(), rect.center().y),
                        rect.left_bottom(),
                    ];
                    painter.add(egui::Shape::convex_polygon(
                        points,
                        egui::Color32::GREEN,
                        egui::Stroke::NONE,
                    ));
                    "Start (Space)"
                }
                PlaybackState::Playing => {
                    painter.add(egui::Shape::circle_filled(
                        rect.center(),
                        rect.width() * 0.45,
                        egui::Color32::GREEN,
                    ));
                    "Exit"
                }
                PlaybackState::Finished => {
                    painter.add(egui::Shape::line_segment(
                        [rect.left_top(), rect.right_bottom()],
                        egui::Stroke::new(2.0, egui::Color32::RED),
                    ));
                    painter.add(egui::Shape::line_segment(
                        [rect.right_top(), rect.left_bottom()],
                        egui::Stroke::new(2.0, egui::Color32::RED),
                    ));
                    "Exit"
                }
            };
            let resp = resp.on_hover_text(tooltip);
            if resp.clicked() {
                match frame.meta.playback_state {
                    PlaybackState::NotStarted => start_flag.store(true, Ordering::SeqCst),
                    PlaybackState::Playing | PlaybackState::Finished => {
                        exit_flag.store(true, Ordering::SeqCst)
                    }
                }
            }
        });

        if frame.meta.playback_state == PlaybackState::NotStarted
            && ctx.input(|i| i.focused && i.key_pressed(egui::Key::Space))
        {
            start_flag.store(true, Ordering::SeqCst);
        }
    });

    CentralPanel::default().show(ctx, |ui| {
        if let Some(err) = audio_error {
            ui.colored_label(egui::Color32::RED, format!("Audio init failed: {err}"));
        }
        let time_link_id = "time_freq_link";
        let x_max = rhythm_history.back().map(|(t, _)| *t).unwrap_or(0.0);
        let window_start = x_max - 5.0;
        let window_end = (window_start + 5.0).max(window_start + 0.1);
        let (left_width, _) = split_widths(ui, 0.17, 100.0, 200.0);
        let row_height = 100.0;
        let height = 100.0;
        let legend_room = 12.0;
        let block_height = height + legend_room;
        let attention_height = row_height * 0.7;
        let neural_time_height = block_height * 0.7;
        let left_row_height = attention_height;
        let left_block_height = neural_time_height;
        ui.horizontal(|ui| {
            ui.allocate_ui_with_layout(
                Vec2::new(left_width, left_row_height + left_block_height),
                egui::Layout::top_down(egui::Align::LEFT),
                |ui| {
                    let peak_db = if frame.meta.peak_level > 0.0 {
                        20.0 * frame.meta.peak_level.log10()
                    } else {
                        f32::NEG_INFINITY
                    };
                    let peak_text = if peak_db.is_infinite() {
                        "-inf dB".to_string()
                    } else {
                        format!("{:>5.1} dB", peak_db)
                    };
                    let peak_color = if frame.meta.peak_level > 1.0 {
                        egui::Color32::RED
                    } else {
                        ui.visuals().text_color()
                    };
                    ui.horizontal(|ui| {
                        ui.heading("Audio");
                        ui.separator();
                        ui.colored_label(peak_color, format!("Peak level: {peak_text}"));
                    });
                    ui.allocate_ui_with_layout(
                        Vec2::new(left_width, left_row_height),
                        egui::Layout::left_to_right(egui::Align::Min),
                        |ui| {
                            // === Level meter ===
                            ui.vertical(|ui| {
                                draw_level_meters(
                                    ui,
                                    frame.meta.channel_peak[0],
                                    frame.meta.window_peak[0],
                                    frame.meta.channel_peak[1],
                                    frame.meta.window_peak[1],
                                    0.45,
                                );
                            });

                            ui.separator();
                            // === Waveform ===
                            ui.vertical(|ui| {
                                ui.label("Wave frame");
                                ui.allocate_ui_with_layout(
                                    Vec2::new(ui.available_width(), left_row_height),
                                    egui::Layout::top_down(egui::Align::LEFT),
                                    |ui| {
                                        time_plot(
                                            ui,
                                            "Current Hop Wave",
                                            frame.wave.fs as f64,
                                            frame.wave.samples.as_ref(),
                                            left_row_height,
                                            false,
                                        );
                                    },
                                );
                            });
                        },
                    );

                    ui.separator();
                    ui.heading("Neural Mandala");
                    ui.allocate_ui_with_layout(
                        Vec2::new(left_width, left_block_height),
                        egui::Layout::top_down(egui::Align::LEFT),
                        |ui| {
                            ui.set_min_height(left_block_height);
                            let side_len = ((left_block_height - legend_room) * 0.4).max(60.0);
                            let side = Vec2::splat(side_len);
                            ui.add_space(10.0);
                            ui.horizontal(|ui| {
                                ui.add_space(8.0);
                                draw_rhythm_mandala(ui, &frame.landscape.rhythm, side);
                                ui.vertical(|ui| {
                                    let labels = [
                                        ("Delta", egui::Color32::from_rgb(80, 180, 255)),
                                        ("Theta", egui::Color32::from_rgb(70, 225, 135)),
                                        ("Alpha", egui::Color32::from_rgb(255, 215, 60)),
                                        ("Beta", egui::Color32::from_rgb(255, 110, 90)),
                                    ];
                                    for (label, color) in labels {
                                        ui.label(
                                            egui::RichText::new(label).color(color).size(12.0),
                                        );
                                    }
                                });
                            });
                        },
                    );
                },
            );

            ui.separator();
            let right_width = ui.available_width().max(0.0);
            ui.allocate_ui_with_layout(
                Vec2::new(
                    right_width,
                    attention_height + neural_time_height + INTENT_BOARD_HEIGHT,
                ),
                egui::Layout::top_down(egui::Align::LEFT),
                |ui| {
                    let old_spacing = ui.spacing().item_spacing;
                    ui.spacing_mut().item_spacing.y = 0.0;
                    ui.label("Auditory attention");
                    spectrum_time_freq_axes(
                        ui,
                        dorsal_history,
                        attention_height,
                        window_start,
                        window_end,
                        Some(time_link_id),
                    );
                    ui.spacing_mut().item_spacing = old_spacing;
                    ui.separator();
                    ui.label("Neural activity");
                    ui.allocate_ui_with_layout(
                        Vec2::new(right_width, neural_time_height),
                        egui::Layout::top_down(egui::Align::LEFT),
                        |ui| {
                            ui.set_min_width(right_width);
                            ui.set_min_height(neural_time_height);
                            neural_activity_plot(
                                ui,
                                rhythm_history,
                                neural_time_height,
                                window_start,
                                window_end,
                                Some(time_link_id),
                            );
                        },
                    );
                },
            );
        });

        ui.separator();
        draw_intent_board(ui, frame);
        ui.separator();
        ui.horizontal(|ui| {
            ui.heading("Population Dynamics");
            ui.separator();
            ui.label(format!("Agents: {}", frame.meta.agent_count));
        });
        plot_population_dynamics(
            ui,
            &frame.agents,
            &frame.spec.spec_hz,
            &frame.spec.amps,
            72.0,
        );

        ui.separator();
        ui.horizontal(|ui| {
            ui.heading("Subjective Intensity");
            ui.checkbox(show_raw_nsgt_power, "Show raw NSGT power");
        });

        let intensity_max = frame
            .landscape
            .subjective_intensity
            .iter()
            .cloned()
            .fold(0.0f32, f32::max);
        let y_min = 0.0;
        let y_max = 100.0;

        let overlay_vals = if *show_raw_nsgt_power {
            let raw_max = frame
                .landscape
                .nsgt_power
                .iter()
                .cloned()
                .fold(0.0f32, f32::max)
                .max(1e-6);
            let scale = intensity_max.max(1e-6) / raw_max;
            Some(
                frame
                    .landscape
                    .nsgt_power
                    .iter()
                    .map(|&p| p * scale)
                    .collect::<Vec<f32>>(),
            )
        } else {
            None
        };
        let overlay = overlay_vals.as_ref().map(|vals| {
            (
                vals.as_slice(),
                "NSGT power (linear)",
                Color32::from_rgb(80, 160, 220),
            )
        });

        log2_plot_hz(
            ui,
            "Subjective Intensity",
            &frame.landscape.space.centers_hz,
            &frame.landscape.subjective_intensity,
            "Intensity",
            y_min,
            y_max,
            102.0,
            Some("landscape_group"),
            None,
            overlay,
        );

        ui.separator();

        let consonance = &frame.landscape.consonance;

        ui.columns(1, |cols| {
            let ui = &mut cols[0];

            ui.heading("Consonance Landscape");
            // Combined Consonance C
            log2_plot_hz(
                ui,
                "Consonance Landscape",
                &frame.landscape.space.centers_hz,
                consonance,
                "C",
                -1.0,
                1.0,
                102.0,
                Some("landscape_group"),
                None,
                None,
            );

            ui.heading("Roughness / Harmonicity");
            draw_roughness_harmonicity(
                ui,
                "Roughness / Harmonicity",
                &frame.landscape.space.centers_hz,
                &frame.landscape.harmonicity01,
                &frame.landscape.roughness01,
                102.0,
                Some("landscape_group"),
            );
        });
    });
}

fn draw_intent_board(ui: &mut egui::Ui, frame: &UiFrame) {
    ui.heading("Intent Board");
    let fs = frame.world.fs;
    let now_tick = frame.world.now_tick;
    let now_sec = if fs > 0.0 { now_tick as f32 / fs } else { 0.0 };
    let past_ticks = frame.world.past_ticks;
    let future_ticks = frame.world.future_ticks;
    let past_sec = if fs > 0.0 {
        past_ticks as f32 / fs
    } else {
        0.0
    };
    let future_sec = if fs > 0.0 {
        future_ticks as f32 / fs
    } else {
        0.0
    };
    let next_gate_tick = frame
        .world
        .next_gate_tick_est
        .map(|tick| tick.to_string())
        .unwrap_or_else(|| "None".to_string());
    let next_gate_sec = frame
        .world
        .next_gate_sec_est
        .map(|sec| format!("{sec:.3}"))
        .unwrap_or_else(|| "None".to_string());
    let planned_live_count = frame.world.planned_next_live.len();
    let planned_last_count = frame.world.planned_last_committed.len();

    ui.horizontal(|ui| {
        ui.label(format!("now_tick={now_tick}"));
        ui.separator();
        ui.label(format!("now_sec={now_sec:.3}"));
        ui.separator();
        ui.label(format!("intents={}", frame.world.intents.len()));
        ui.separator();
        ui.label(format!("past={} ({past_sec:.2}s)", past_ticks));
        ui.separator();
        ui.label(format!("future={} ({future_sec:.2}s)", future_ticks));
        ui.separator();
        ui.label(format!("next_gate_tick={next_gate_tick}"));
        ui.separator();
        ui.label(format!("next_gate_sec={next_gate_sec}"));
        ui.separator();
        ui.label(format!(
            "planned_live={} planned_last={}",
            planned_live_count, planned_last_count
        ));
    });

    let series: PlotPoints = frame
        .world
        .intents
        .iter()
        .filter_map(|intent| {
            if intent.freq_hz <= 0.0 || fs <= 0.0 {
                return None;
            }
            let x = (intent.freq_hz as f64).max(1.0).log2();
            let y = intent.onset_tick as f64 / fs as f64;
            Some([x, y])
        })
        .collect();
    let planned_live_series: PlotPoints = frame
        .world
        .planned_next_live
        .iter()
        .filter_map(|planned| {
            let gate_sec = frame.world.next_gate_sec_est?;
            if planned.freq_hz <= 0.0 {
                return None;
            }
            let x = (planned.freq_hz as f64).max(1.0).log2();
            let y = gate_sec;
            Some([x, y])
        })
        .collect();
    let planned_last_series: PlotPoints = frame
        .world
        .planned_last_committed
        .iter()
        .filter_map(|planned| {
            let gate_tick = frame.world.planned_last_gate_tick?;
            if planned.freq_hz <= 0.0 || fs <= 0.0 {
                return None;
            }
            let x = (planned.freq_hz as f64).max(1.0).log2();
            let y = gate_tick as f64 / fs as f64;
            Some([x, y])
        })
        .collect();
    let points = Points::new("intents", series)
        .radius(3.0)
        .color(Color32::from_rgb(240, 120, 120));
    let planned_points = Points::new("planned_intents_live", planned_live_series)
        .radius(4.0)
        .color(Color32::from_rgb(120, 220, 160));
    let planned_last_points = Points::new("planned_intents_last", planned_last_series)
        .radius(4.0)
        .color(Color32::from_rgb(120, 160, 240));
    let x_min_log2 = (20.0f64).log2();
    let x_max_log2 = (20_000.0f64).log2();
    let y_min = (now_sec - past_sec) as f64;
    let y_max = (now_sec + future_sec) as f64;
    let y_max_fixed = if y_max <= y_min { y_min + 1.0 } else { y_max };

    Plot::new("intent_board_plot")
        .height(INTENT_PLOT_HEIGHT)
        .allow_drag(false)
        .allow_scroll(false)
        .include_x(x_min_log2)
        .include_x(x_max_log2)
        .default_x_bounds(x_min_log2, x_max_log2)
        .include_y(y_min)
        .include_y(y_max_fixed)
        .default_y_bounds(y_min, y_max_fixed)
        .x_axis_formatter(|mark, _range| {
            let hz = 2f64.powf(mark.value);
            if hz < 1000.0 {
                format!("{:.0} Hz", hz)
            } else {
                format!("{:.1} kHz", hz / 1000.0)
            }
        })
        .y_axis_formatter(|mark, _| format!("{:.2}s", mark.value))
        .show(ui, |plot_ui| {
            plot_ui.points(points);
            if planned_live_count > 0 && frame.world.next_gate_sec_est.is_some() {
                plot_ui.points(planned_points);
            }
            if planned_last_count > 0 && frame.world.planned_last_gate_tick.is_some() {
                plot_ui.points(planned_last_points);
            }
        });

    let mut list_text = String::new();
    for (idx, intent) in frame.world.intents.iter().enumerate() {
        if idx > 0 {
            list_text.push_str(" | ");
        }
        let onset_sec = if fs > 0.0 {
            intent.onset_tick as f32 / fs
        } else {
            0.0
        };
        let tag = intent.tag.as_deref().unwrap_or("-");
        list_text.push_str(&format!(
            "t={onset_sec:.3}s f={:.1}Hz amp={:.3} src={} tag={}",
            intent.freq_hz, intent.amp, intent.source_id, tag
        ));
    }
    let line_height = ui.text_style_height(&egui::TextStyle::Body);
    egui::ScrollArea::horizontal()
        .id_salt("intent_list_scroll")
        .max_height(line_height.max(INTENT_LIST_HEIGHT))
        .show(ui, |ui| {
            ui.add(egui::Label::new(list_text).extend());
        });

    let mut planned_text = String::new();
    for (idx, planned) in frame.world.planned_next_live.iter().enumerate() {
        if idx > 0 {
            planned_text.push_str(" | ");
        }
        let tag = planned.tag.as_deref().unwrap_or("-");
        planned_text.push_str(&format!(
            "f={:.1}Hz amp={:.3} conf={:.2} src={} tag={}",
            planned.freq_hz, planned.amp, planned.confidence, planned.source_id, tag
        ));
    }
    let mut planned_last_text = String::new();
    for (idx, planned) in frame.world.planned_last_committed.iter().enumerate() {
        if idx > 0 {
            planned_last_text.push_str(" | ");
        }
        let tag = planned.tag.as_deref().unwrap_or("-");
        planned_last_text.push_str(&format!(
            "f={:.1}Hz amp={:.3} conf={:.2} src={} tag={}",
            planned.freq_hz, planned.amp, planned.confidence, planned.source_id, tag
        ));
    }
    egui::ScrollArea::horizontal()
        .id_salt("planned_list_scroll")
        .max_height(line_height.max(INTENT_LIST_HEIGHT))
        .show(ui, |ui| {
            ui.add(egui::Label::new(planned_text).extend());
        });
    egui::ScrollArea::horizontal()
        .id_salt("planned_last_list_scroll")
        .max_height(line_height.max(INTENT_LIST_HEIGHT))
        .show(ui, |ui| {
            ui.add(egui::Label::new(planned_last_text).extend());
        });
}
</file>

<file path="src/cli.rs">
use clap::Parser;

#[derive(Parser, Debug, Clone)]
#[command(author, version, about)]
pub struct Args {
    /// Play audio in realtime
    #[arg(long, default_value_t = true, num_args = 0..=1, default_missing_value = "true")]
    pub play: bool,

    /// Write audio to wav file (debug builds only)
    #[cfg(debug_assertions)]
    #[arg(long)]
    pub wav: Option<String>,

    /// Scenario path (.rhai only)
    #[arg(value_name = "SCENARIO_PATH")]
    pub scenario_path: String,

    /// Path to config TOML
    #[arg(long, default_value = "config.toml")]
    pub config: String,

    /// Wait for user action to exit after playback (overrides config)
    #[arg(long, num_args = 0..=1, default_missing_value = "false")]
    pub wait_user_exit: Option<bool>,

    /// Wait for user action before starting playback (overrides config)
    #[arg(long, num_args = 0..=1, default_missing_value = "true")]
    pub wait_user_start: Option<bool>,

    /// Run without GUI (headless)
    #[arg(long, default_value_t = false)]
    pub nogui: bool,

    /// Compile scenario script only (no GUI, no audio, no execution)
    #[arg(long, default_value_t = false)]
    pub compile_only: bool,
}
</file>

<file path="src/main.rs">
#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(unused_variables)]

// Entry point: launches the egui/eframe app.
// Worker threads (including the harmonicity analysis worker) are spawned from `src/app.rs` and
// receive only the minimal data they need (fs/Log2Space/HarmonicityKernel), not a full Landscape.
mod app;
mod audio;
mod cli;
mod config;
mod core;
mod life;
mod synth;
mod ui;

use clap::Parser;
use std::path::Path;
use std::sync::{
    Arc,
    atomic::{AtomicBool, Ordering},
};
use tracing_subscriber::EnvFilter;

use crate::cli::Args;
use crate::config::AppConfig;

fn main() -> eframe::Result<()> {
    // Initialize tracing/logging (honors RUST_LOG).
    // Use an info default when RUST_LOG is unset; no wall-clock timestamps (we log sim time instead).
    let filter = EnvFilter::try_from_default_env().unwrap_or_else(|_| EnvFilter::new("info"));
    let _ = tracing_subscriber::fmt()
        .with_env_filter(filter)
        .with_target(false)
        .with_level(true)
        .without_time()
        .try_init();

    let args = Args::parse();
    let mut config = AppConfig::load_or_default(&args.config);
    if let Some(val) = args.wait_user_exit {
        config.playback.wait_user_exit = val;
    }
    if let Some(val) = args.wait_user_start {
        config.playback.wait_user_start = val;
    }

    let ext = Path::new(&args.scenario_path)
        .extension()
        .and_then(|s| s.to_str())
        .unwrap_or("")
        .to_ascii_lowercase();
    if ext != "rhai" {
        eprintln!("Scenario must be a .rhai script: {}", args.scenario_path);
        std::process::exit(1);
    }

    let stop_flag = Arc::new(AtomicBool::new(false));
    let stop_flag_for_ctrlc = stop_flag.clone();

    ctrlc::set_handler(move || {
        stop_flag_for_ctrlc.store(true, Ordering::SeqCst);
    })
    .expect("Error setting Ctrl-C handler");

    if args.compile_only {
        app::run_compile_only(args, config);
        return Ok(());
    }

    if args.nogui {
        if config.playback.wait_user_start {
            eprintln!("--nogui forces wait_user_start=false");
        }
        if config.playback.wait_user_exit {
            eprintln!("--nogui forces wait_user_exit=false");
        }
        config.playback.wait_user_start = false;
        config.playback.wait_user_exit = false;
        app::run_headless(args, config, stop_flag);
        return Ok(());
    }

    let native_options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default().with_inner_size([1200.0, 1020.0]),
        ..Default::default()
    };

    eframe::run_native(
        "Conchordal",
        native_options,
        Box::new(move |cc| {
            Ok(Box::new(app::App::new(
                cc,
                args.clone(),
                config.clone(),
                stop_flag.clone(),
            )))
        }),
    )
    .map_err(|e| {
        eprintln!("Error: {:?}", e);
        e
    })
}
</file>

<file path="README.md">
# Conchordal

**A bio-acoustic instrument for generative composition.**

> **Note: Research Alpha** — An early preview for researchers and developers. Features are incomplete and may be unstable. Composers and creators: please wait for beta.

![Conchordal Interface](assets/screenshot1.png)

## Concept: Emergence over Composition

Conchordal is a computational ecosystem where sound is treated as a living organism.

It does not rely on fixed grids—no equal temperament, no metronomic time. Instead, it simulates a **physiological environment** based on human auditory perception. Within this environment, autonomous "Individuals" struggle, coexist, and evolve.

Their survival depends on finding **Spectral Consonance** (minimizing sensory roughness) and establishing **Virtual Pitch** (maximizing harmonic stability). The resulting music is not composed by a human; it *emerges* from the physical interactions of sound itself.

## The Architecture

The system models a dynamic feedback loop across three layers, unifying Pitch (Space) and Rhythm (Time) under biological principles:

### 1. The Landscape (The Cognitive Environment)

The environment represents the structure of human hearing in both frequency and time domains:

* **Spectral Potential (Pitch):** Using a Non-Stationary Gabor Transform (NSGT) on a Log2 axis—simulating the **Cochlear Tonotopic Map**—it calculates potentials corresponding to physiological mechanisms:
    * **Roughness (R):** Simulates **Basilar Membrane Interference** (Critical Bands).
    * **Harmonicity (H):** Simulates **Neural Phase-Locking** (Temporal Periodicity detection).
    * **Consonance (C):** Simulates **Cognitive Integration**. The resultant fitness terrain ($C = H - R_{norm}$).

* **Neural Rhythms (Time):** Instead of a grid, rhythm emerges from entrainment to simulated **Neural Oscillations (Brainwaves)**:

	* **Delta Band (~0.5-4Hz):** Governs the macroscopic **Pulse** and musical **Phrasing**.

    * **Theta Band (~4-8Hz):** Dictates **Articulation** and syllabic grouping.

    * **Alpha Band (~8-13Hz):** Influences **Texture** and timbral fluctuation (e.g., unison detuning).

    * **Beta Band (~13-30Hz):** Controls micro-timing (groove) and ensemble tightness.
	

### 2. The Population (The Collective)

Sound is not a singular event but a mass phenomenon. The **Population** manages the aggregate state of all active agents. It represents the "species" or "society" of sound that inhabits the Landscape, handling the density, diversity, and collective spectral footprint that feeds back into the environment.

### 3. The Individual (The Agent)

The atomic unit of the system. Each **Individual** is an autonomous entity:
* **Proprioception:** It senses the Landscape's spectral potentials and synchronizes its internal clock to the environmental Neural Rhythms.
* **Metabolism:** It consumes energy to sustain articulation.
* **Autonomy:** It makes local decisions—moving away from dissonance (segregation) or locking onto harmonic peaks (fusion)—without a central conductor.

## The Role of the Artist: Scenarios as Macro-Structure

While the *micro-structure* (harmony, rhythm, articulation) emerges autonomously, the **macro-structure** (the timeline and narrative arc) is crafted by the artist.

Using **Rhai** scripts, the creator acts not as a composer of notes, but as a **Director of Ecosystems**. Through the scenario file, you define:

* **Phases:** The sectional progression of the piece (e.g., "Genesis", "Conflict", "Resolution").
* **Interventions:** Injecting new populations or altering environmental constants (e.g., changing the system's "temperature" or consonance sensitivity).
* **Constraints:** Setting boundaries within which the system evolves.

This allows for the creation of structured "works" where the overall form is intentional, but the momentary details are emergent.

## Technical Stack

* Written entirely in **Rust** for high performance and memory safety.
* **Multi-platform** support (Linux, macOS, and Windows).
* Multi-threaded architecture with **lock-free concurrency** to ensure real-time DSP stability.
* High-performance **Non-stationary Gabor transform (NSGT)** analysis engine, complemented by dedicated psychoacoustic evaluation and synthesis kernels.
* Extensible **ALife engine** utilizing energy metabolism and Kuramoto-style entrainment for emergent behavior.
* Scenario scripting via an embedded **Rhai** interpreter for dynamic control.
* Real-time psychoacoustic monitoring and visualization via `egui`.

## Getting Started

### Installation & Run


Run a sample scenario.

```bash
git clone https://github.com/ktakahashi74/conchordal.git
cd conchordal
cargo run --release -- samples/03_structures/autumn_cycle.rhai
```

On Linux, you need `libasound2-dev` installed (ALSA headers required by `cpal`).


### Scenario scripting example

Define the ecosystem's initial conditions using Rhai scripts as follows and save it as `sample.rhai`.

```rust
for i in 0..5 {
    spawn("a", 1);
    wait(0.5);
}
end_at(5)
```

then run the script with

``` bash
cargo run -- sample.rhai
```

Core scenario API (v2):
- `spawn(tag, count[, opts])`
- `wait(dt)`, `scene(name)`, `end()`, `end_at(t_abs)`
- `set(target, patch)`, `release(target, duration)`, `remove(target)`
- Prelude helpers: `after`, `at`, `parallel`, `repeat`, `every`, `spawn_every`

Strict keys:
- `spawn` opts: `amp`, `method`, `life`
- `set` patch: `amp`, `freq`, `exploration`, `persistence`


### Testing and other commands

Run the test suite with:

```bash
cargo test
```

If you want to pass the GitHub CI checks after code changes, run:

```bash
cargo fmt --all
cargo clippy -- -D warnings
```

The following command generates plot images under `target/` for visual kernel checks.

```bash
cargo test -- --ignored
```

If you want the docs to be up to date after changes, run:

```bash
cargo run --example gen_schemas
cargo run --example generate_script_docs
scripts/generate_rhai_docs.sh
```

`cargo run --example gen_schemas` regenerates `docs/schemas/*` (including `agent_patch`).


### Running options


Headless execution (no GUI): `--nogui`

```bash
cargo run -- --nogui sample.rhai
```

Compile-only (no GUI/audio execution) for script syntax check: `--compile-only`

```bash
cargo run -- --compile-only sample.rhai
```

Setting log levels with `RUST_LOG`:

```bash
RUST_LOG=debug cargo run -- sample.rhai
```

log levels are either `error`, `warn`, `info`, `debug`, or `trace`.




## Timeline & Roadmap

- **circa 1994** — Core concept conceived 
- **Aug 25, 2025** — Project started 
- **Dec 25, 2025** — Source & web release (pre-alpha) ← *current* 
- **Early 2026** — Demo scenario and tutorials
- **Summer 2026** — Beta, featuring first compositions



### Contributing

We invite engineers and artists who are exploring the frontiers of Auditory Scene Analysis and Computational Creativity. Check the Issue Tracker for open research topics.

### License

Distributed under the terms of both the MIT license and the Apache License (Version 2.0).

### Author

Created by Koichi Takahashi <info@conchordal.org>
</file>

<file path="samples/02_mechanisms/agent_interaction.rhai">
print(">>> Scan & Pursue Demo: Intelligent Harmony <<<");

// ==========================================
// Phase 1: Stable drone (C major context)
// ==========================================
scene("Phase 1: Anchor C2");
print("--- [1] Anchoring C2 (65.41Hz) ---");

// Anchor (immobile)
let anchor_method = #{ mode: "random_log_uniform", min_freq: 65.41, max_freq: 65.41 };
let anchor_tag = "anchor";
spawn(
    anchor_tag,
    1,
    #{ method: anchor_method },
    #{ body: #{ amp: 0.6, method: "sine" }, phonation: #{ type: "hold" } }
);
set(anchor_tag, #{ pitch: #{ persistence: 1.0 } });

wait(1.0);

// ==========================================
// Phase 2: Inject seekers (dissonance -> resolution)
// ==========================================
scene("Phase 2: The Seekers");
print("--- [2] Spawning Seekers at Dissonant Intervals ---");

// Relative to C2 (65.41), drop dissonant agents:
// F# (tritone): 92.5 Hz -> likely resolves to G (98.0) or F (87.3)
// C# (minor 2nd): 69.3 Hz -> likely resolves to C (65.4) or D (73.4)

// Place them slightly off the comfy spots
let seeker_tritone_method = #{ mode: "random_log_uniform", min_freq: 92.5, max_freq: 92.5 };
let seeker_m2_method = #{ mode: "random_log_uniform", min_freq: 140.0, max_freq: 140.0 };
let seeker_tritone_tag = "seeker_tritone";
spawn(
    seeker_tritone_tag,
    1,
    #{ method: seeker_tritone_method },
    #{ body: #{ amp: 0.4, method: "sine" }, phonation: #{ type: "hold" } }
);
let seeker_m2_tag = "seeker_m2";
spawn(
    seeker_m2_tag,
    1,
    #{ method: seeker_m2_method },
    #{ body: #{ amp: 0.4, method: "sine" }, phonation: #{ type: "hold" } }
); // near C3 (~130 Hz)

// Set persistence (higher = more stubborn)
set(seeker_tritone_tag, #{ pitch: #{ persistence: 0.5 } });
set(seeker_m2_tag, #{ pitch: #{ persistence: 0.67 } }); // moves more slowly

print(">>> Observe: They should hop to the nearest consonant peak (G or C) <<<");
wait(5.0);

// ==========================================
// Phase 3: Tectonic shift (exploration)
// ==========================================
scene("Phase 3: Modulation to F");
print("--- [3] Moving Anchor to F2 (87.31Hz) ---");

// Force-move the anchor; landscape flips.
// Formerly comfy spots (C, G) may become dissonant relative to F.
set(anchor_tag, #{ pitch: #{ freq: 87.31 } });

// Agents scan periodically; they should notice F overtones feel better and retarget.

wait(8.0);

// ==========================================
// Phase 4: Swarm behavior (harmonic density)
// ==========================================
scene("Phase 4: Swarm Intelligence");
print("--- [4] Spawning a swarm ---");

// Add many bodies; peaks they create become targets, so watch for clustering vs dispersing.
let method = #{ mode: "harmonic_density", min_freq: 200.0, max_freq: 800.0 };
for i in 0..4 {
    let swarm_tag = "swarm_" + i;
    spawn(
        swarm_tag,
        1,
        #{ method: method },
        #{ body: #{ amp: 0.15, method: "sine" }, phonation: #{ type: "hold" } }
    );
    set(swarm_tag, #{ pitch: #{ persistence: 0.56 } });
    wait(0.5);
}

wait(5.0);
end();
</file>

<file path="samples/04_ecosystems/drift_flow.rhai">
print(">>> Drift & Flow: Physics Verification Demo <<<");

// ==========================================
// Phase 1: Gravity Test (adhesion experiment)
// ==========================================
scene("Phase 1: Gravity Pull");
print("--- [1] Anchoring C2 (65.41Hz) ---");

// Base tone (static anchor)
let anchor_method = #{ mode: "random_log_uniform", min_freq: 65.41, max_freq: 65.41 };
let anchor_tag = "anchor";
let anchor_patch = #{ body: #{ amp: 0.6, method: "sine" }, phonation: #{ type: "hold" } };
spawn(anchor_tag, 1, #{ method: anchor_method }, anchor_patch);
// Anchor stays put (high persistence = resists movement)
set(anchor_tag, #{ pitch: #{ persistence: 1.0 } });

wait(1.0);

print("--- Injecting Dissonant Tone (C#3) -> Watch it hop to C3 or E3 ---");
// Drop a semitone-above tone (C#3 ≈ 138.59) above C3 (130.81)
// Check whether the pull guides it toward C3 or E3
let slider_method = #{ mode: "random_log_uniform", min_freq: 138.59, max_freq: 138.59 };
let slider_tag = "slider";
let slider_patch = #{ body: #{ amp: 0.4, method: "sine" }, phonation: #{ type: "hold" } };
spawn(slider_tag, 1, #{ method: slider_method }, slider_patch);

// Low persistence = moves easily
set(slider_tag, #{ pitch: #{ persistence: 0.33 } }); // eager to move

wait(4.0);

// ==========================================
// Phase 2: Perceptual Adaptation
// ==========================================
scene("Phase 2: Perceptual Push");
print("--- [2] Perceptual adaptation (self + environment) ---");

// Expect perceptual traces to grow under the slider

print("--- Slider should be pushed away by red arrow ---");
// As boredom accumulates, the peak flattens into a valley, nudging the agent to a neighboring harmonic.
wait(6.0);

// ==========================================
// Phase 3: Mass Migration (exploration and pursuit)
// ==========================================
scene("Phase 3: Modulation");
print("--- [3] Spawning Swarm & Moving Anchor ---");

remove(slider_tag);
// Lightly reset environment

// Drop a swarm (spread across C overtones)
let method = #{ mode: "harmonicity", min_freq: 130.0, max_freq: 800.0 };
let swarm_patch = #{ body: #{ amp: 0.15, method: "sine" }, phonation: #{ type: "hold" } };

for i in 0..5 {
    let swarm_tag = "swarm_" + i;
    spawn(swarm_tag, 1, #{ method: method }, swarm_patch);
    set(swarm_tag, #{ pitch: #{ persistence: 0.56 } }); // hop loosely
    wait(0.5);
}

wait(2.0);

print(">>> MOVING ANCHOR to F2 (87.31Hz) <<<");
print(">>> Watch the blue arrows flip direction! <<<");

// Move anchor to F2.
// Landscape flips: C-major valleys disappear, F-major basins emerge.
// Swarm should move toward F overtones (A, C, Eb...).
set(anchor_tag, #{ pitch: #{ freq: 87.31 } }); 

wait(8.0);

print(">>> Releasing Anchor (Dissolution) <<<");
remove(anchor_tag);
// Removing the anchor flattens the landscape; swarm should disperse/decay.
wait(5.0);

end();
</file>

<file path="samples/04_ecosystems/emergent_harmony.rhai">
// Autonomous Harmonic Progression demo
scene("anchor_intro");

// Phase 1: anchor on C2
let anchor_method = #{ mode: "random_log_uniform", min_freq: 65.406, max_freq: 65.406 };
let anchor_tag = "anchor";
let anchor_patch = #{ body: #{ amp: 0.12, method: "sine" }, phonation: #{ type: "hold" } };
spawn(
    anchor_tag,
    1,
    #{ method: anchor_method },
    anchor_patch
);
set(anchor_tag, #{ pitch: #{ persistence: 0.9 } });

wait(4.0);

scene("seekers_arrive");
// Phase 2: seekers at dissonant intervals (F#, C#)
let seeker_patch = #{ body: #{ amp: 0.08, method: "sine" }, phonation: #{ type: "hold" } };
let seeker_fsharp_method = #{ mode: "random_log_uniform", min_freq: 92.499, max_freq: 92.499 };
let seeker_csharp_method = #{ mode: "random_log_uniform", min_freq: 69.296, max_freq: 69.296 };
let seeker_fsharp_tag = "seeker_fsharp";
spawn(seeker_fsharp_tag, 1, #{ method: seeker_fsharp_method }, seeker_patch);
let seeker_csharp_tag = "seeker_csharp";
spawn(seeker_csharp_tag, 1, #{ method: seeker_csharp_method }, seeker_patch);
set(seeker_fsharp_tag, #{ pitch: #{ persistence: 0.25 } });
set(seeker_csharp_tag, #{ pitch: #{ persistence: 0.25 } });

wait(8.0);

scene("anchor_moves");
// Phase 3: anchor hops to F2; swarm should re-lock on F-major colors
set(anchor_tag, #{ pitch: #{ freq: 87.307 } }); // F2
set(anchor_tag, #{ pitch: #{ persistence: 0.8 } });

wait(10.0);
end();
</file>

<file path="src/core/landscape.rs">
//! core/landscape.rs — Data container for the psychoacoustic map (The Map).
//!
//! This module now holds only the data structures and lightweight helpers.
//! Processing lives in the Dorsal (rhythm), Roughness, and Harmonicity streams.

use crate::core::log2space::Log2Space;
use crate::core::modulation::NeuralRhythms;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug)]
pub struct LandscapeParams {
    pub fs: f32,
    pub max_hist_cols: usize,
    pub alpha: f32,
    pub roughness_kernel: crate::core::roughness_kernel::RoughnessKernel,
    pub harmonicity_kernel: crate::core::harmonicity_kernel::HarmonicityKernel,
    /// Scalar roughness summary used for normalization and diagnostics.
    pub roughness_scalar_mode: RoughnessScalarMode,
    /// Half-saturation point for roughness range compression (legacy).
    pub roughness_half: f32,
    /// Weight for perc_potential_R when computing consonance01 (H - w*R).
    pub consonance_roughness_weight: f32,

    /// Exponent for subjective intensity (≈ specific loudness). Typical: 0.23
    pub loudness_exp: f32,
    /// Reference power for normalization. Tune to your signal scale.
    pub ref_power: f32,
    /// Leaky integration time constant [ms]. Typical: 60–120 ms.
    pub tau_ms: f32,

    /// Roughness normalization constant (k) for physiological saturation.
    /// Reference-normalized ratio x=1 maps to roughness01=1/(1+k).
    /// Larger k reduces roughness01 for the same reference ratio.
    pub roughness_k: f32,

    /// Reference f0 (Hz) for roughness shape normalization.
    pub roughness_ref_f0_hz: f32,
    /// ERB separation for the 2-peak reference stimulus.
    pub roughness_ref_sep_erb: f32,
    /// Mass split between the two reference peaks (peak A mass).
    pub roughness_ref_mass_split: f32,
    /// Epsilon for roughness normalization and mass checks.
    pub roughness_ref_eps: f32,
}

#[derive(Clone, Copy, Debug, Default, Serialize, Deserialize)]
pub struct LandscapeUpdate {
    pub mirror: Option<f32>,
    pub limit: Option<u32>,
    pub roughness_k: Option<f32>,
}

#[derive(Clone, Copy, Debug)]
pub enum RoughnessScalarMode {
    Total,
    Max,
    P95,
}

/// Pure data snapshot for UI and agent evaluation.
/// Values here are perceptual (perc_*) unless stated otherwise.
#[derive(Clone, Debug)]
pub struct Landscape {
    pub space: Log2Space,
    /// perc_potential_R over log2 frequency.
    pub roughness: Vec<f32>,
    /// Raw shape for perc_potential_R normalization.
    pub roughness_shape_raw: Vec<f32>,
    /// Normalized perc_potential_R [0, 1].
    pub roughness01: Vec<f32>,
    /// perc_potential_H over log2 frequency.
    pub harmonicity: Vec<f32>,
    /// Normalized perc_potential_H [0, 1].
    pub harmonicity01: Vec<f32>,
    /// Combined perc_potential_H - w*perc_potential_R.
    pub consonance: Vec<f32>,
    /// Normalized combined consonance [0, 1].
    pub consonance01: Vec<f32>,
    pub subjective_intensity: Vec<f32>,
    pub nsgt_power: Vec<f32>,
    /// perc_state_R (summary statistics).
    pub roughness_total: f32,
    pub roughness_max: f32,
    pub roughness_p95: f32,
    pub roughness_scalar_raw: f32,
    pub roughness_norm: f32,
    pub roughness01_scalar: f32,
    pub loudness_mass: f32,
    pub rhythm: NeuralRhythms,
}

/// Alias retained for existing call sites.
pub type LandscapeFrame = Landscape;

impl Landscape {
    pub fn new(space: Log2Space) -> Self {
        let n = space.n_bins();
        Self {
            space,
            roughness: vec![0.0; n],
            roughness_shape_raw: vec![0.0; n],
            roughness01: vec![0.0; n],
            harmonicity: vec![0.0; n],
            harmonicity01: vec![0.0; n],
            consonance: vec![0.0; n],
            consonance01: vec![0.0; n],
            subjective_intensity: vec![0.0; n],
            nsgt_power: vec![0.0; n],
            roughness_total: 0.0,
            roughness_max: 0.0,
            roughness_p95: 0.0,
            roughness_scalar_raw: 0.0,
            roughness_norm: 0.0,
            roughness01_scalar: 0.0,
            loudness_mass: 0.0,
            rhythm: NeuralRhythms::default(),
        }
    }

    pub fn resize_to_space(&mut self, space: Log2Space) {
        let n = space.n_bins();
        self.space = space;
        self.roughness.resize(n, 0.0);
        self.roughness_shape_raw.resize(n, 0.0);
        self.roughness01.resize(n, 0.0);
        self.harmonicity.resize(n, 0.0);
        self.harmonicity01.resize(n, 0.0);
        self.consonance.resize(n, 0.0);
        self.consonance01.resize(n, 0.0);
        self.subjective_intensity.resize(n, 0.0);
        self.nsgt_power.resize(n, 0.0);
    }

    fn assert_scan_lengths(&self) {
        self.space
            .assert_scan_len_named(&self.roughness, "roughness");
        self.space
            .assert_scan_len_named(&self.roughness_shape_raw, "roughness_shape_raw");
        self.space
            .assert_scan_len_named(&self.roughness01, "roughness01");
        self.space
            .assert_scan_len_named(&self.harmonicity, "harmonicity");
        self.space
            .assert_scan_len_named(&self.harmonicity01, "harmonicity01");
        self.space
            .assert_scan_len_named(&self.consonance, "consonance");
        self.space
            .assert_scan_len_named(&self.consonance01, "consonance01");
        self.space
            .assert_scan_len_named(&self.subjective_intensity, "subjective_intensity");
        self.space
            .assert_scan_len_named(&self.nsgt_power, "nsgt_power");
    }

    /// Signed consonance [-1, 1]. Prefer `evaluate_pitch01` for normalized usage.
    pub fn evaluate_pitch(&self, freq_hz: f32) -> f32 {
        self.assert_scan_lengths();
        self.sample_linear(&self.consonance, freq_hz)
    }

    /// Signed consonance [-1, 1]. Prefer `evaluate_pitch01_log2` for normalized usage.
    pub fn evaluate_pitch_log2(&self, log_freq: f32) -> f32 {
        self.assert_scan_lengths();
        self.sample_linear_log2(&self.consonance, log_freq)
    }

    pub fn evaluate_pitch01(&self, freq_hz: f32) -> f32 {
        self.assert_scan_lengths();
        self.sample_linear(&self.consonance01, freq_hz)
            .clamp(0.0, 1.0)
    }

    pub fn evaluate_pitch01_log2(&self, log_freq: f32) -> f32 {
        self.assert_scan_lengths();
        self.sample_linear_log2(&self.consonance01, log_freq)
            .clamp(0.0, 1.0)
    }

    pub fn consonance_at(&self, freq_hz: f32) -> f32 {
        self.assert_scan_lengths();
        self.evaluate_pitch(freq_hz)
    }

    pub fn consonance01_at(&self, freq_hz: f32) -> f32 {
        self.assert_scan_lengths();
        self.evaluate_pitch01(freq_hz)
    }

    pub fn freq_bounds(&self) -> (f32, f32) {
        (self.space.fmin, self.space.fmax)
    }

    pub fn freq_bounds_log2(&self) -> (f32, f32) {
        (self.space.fmin.log2(), self.space.fmax.log2())
    }

    pub fn recompute_consonance(&mut self, params: &LandscapeParams) {
        self.assert_scan_lengths();
        let w_r = params.consonance_roughness_weight.max(0.0);
        if self.harmonicity01.len() != self.harmonicity.len() {
            self.harmonicity01 = vec![0.0; self.harmonicity.len()];
        }
        if self.consonance01.len() != self.consonance.len() {
            self.consonance01 = vec![0.0; self.consonance.len()];
        }
        if self.roughness01.len() != self.roughness.len() {
            self.roughness01 = vec![0.0; self.roughness.len()];
        }
        let perc_h_pot_scan = &self.harmonicity;
        let perc_r_state01_scan = &self.roughness01;
        crate::core::psycho_state::h_pot_scan_to_h_state01_scan(
            perc_h_pot_scan,
            1.0,
            &mut self.harmonicity01,
        );
        debug_assert_eq!(self.harmonicity01.len(), self.consonance.len());
        debug_assert_eq!(perc_r_state01_scan.len(), self.consonance.len());
        for ((c_signed, c01), (h01, r01)) in self
            .consonance
            .iter_mut()
            .zip(self.consonance01.iter_mut())
            .zip(self.harmonicity01.iter().zip(perc_r_state01_scan.iter()))
        {
            let (c_signed_val, c01_val) =
                crate::core::psycho_state::compose_c_statepm1(*h01, *r01, w_r);
            *c_signed = c_signed_val;
            *c01 = c01_val.clamp(0.0, 1.0);
        }
    }

    fn sample_linear(&self, data: &[f32], freq_hz: f32) -> f32 {
        if data.is_empty() || freq_hz < self.space.fmin || freq_hz > self.space.fmax {
            return 0.0;
        }
        let l = freq_hz.log2();
        self.sample_linear_log2(data, l)
    }

    fn sample_linear_log2(&self, data: &[f32], log_freq: f32) -> f32 {
        if data.is_empty() {
            return 0.0;
        }
        let step = self.space.step();
        let base = self.space.centers_log2[0];
        let pos = (log_freq - base) / step;
        let idx = pos.floor() as usize;
        let frac = pos - pos.floor();
        let idx0 = idx.min(data.len().saturating_sub(1));
        let idx1 = (idx0 + 1).min(data.len().saturating_sub(1));
        let v0 = data.get(idx0).copied().unwrap_or(0.0);
        let v1 = data.get(idx1).copied().unwrap_or(v0);
        v0 + (v1 - v0) * frac
    }
}

pub fn map_roughness01(r_norm: f32, r_half: f32) -> f32 {
    // Range compression helper (not a psychoacoustic normalization).
    let half = r_half.max(1e-12);
    let denom = r_norm + half;
    if denom <= 0.0 {
        0.0
    } else {
        (r_norm / denom).clamp(0.0, 1.0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::harmonicity_kernel::{HarmonicityKernel, HarmonicityParams};
    use crate::core::roughness_kernel::{KernelParams, RoughnessKernel};

    fn build_params(space: &Log2Space) -> LandscapeParams {
        LandscapeParams {
            fs: 48_000.0,
            max_hist_cols: 1,
            alpha: 0.0,
            roughness_kernel: RoughnessKernel::new(KernelParams::default(), 0.005),
            harmonicity_kernel: HarmonicityKernel::new(space, HarmonicityParams::default()),
            roughness_scalar_mode: RoughnessScalarMode::Total,
            roughness_half: 0.1,
            consonance_roughness_weight: 0.5,
            loudness_exp: 1.0,
            ref_power: 1.0,
            tau_ms: 1.0,
            roughness_k: 1.0,
            roughness_ref_f0_hz: 1000.0,
            roughness_ref_sep_erb: 0.25,
            roughness_ref_mass_split: 0.5,
            roughness_ref_eps: 1e-12,
        }
    }

    #[test]
    fn roughness01_in_range_and_halfpoint() {
        let r_half = 0.2;
        let r0 = map_roughness01(0.0, r_half);
        let r_half_out = map_roughness01(r_half, r_half);
        let r_big = map_roughness01(10.0, r_half);
        assert!(r0 >= 0.0 && r0 <= 1.0);
        assert!((r_half_out - 0.5).abs() < 1e-6);
        assert!(r_big >= 0.0 && r_big <= 1.0);
    }

    #[test]
    fn roughness01_invariant_to_joint_scaling() {
        let r_half = 0.3;
        let r_raw = 2.0;
        let loudness = 5.0;
        let r_norm = r_raw / (loudness + 1e-12);
        let r01 = map_roughness01(r_norm, r_half);
        let scale = 4.0;
        let r_norm2 = (r_raw * scale) / (loudness * scale + 1e-12);
        let r012 = map_roughness01(r_norm2, r_half);
        assert!((r01 - r012).abs() < 1e-6);
    }

    #[test]
    fn c01_stays_in_range() {
        let h01 = [0.0f32, 0.5, 1.0];
        let r01 = [0.0f32, 0.4, 1.0];
        for &h in &h01 {
            for &r in &r01 {
                let c_signed = (h - r).clamp(-1.0, 1.0);
                let c = ((c_signed + 1.0) * 0.5).clamp(0.0, 1.0);
                assert!(c >= 0.0 && c <= 1.0);
            }
        }
    }

    #[test]
    fn evaluate_pitch01_uses_consonance01() {
        let mut landscape = Landscape::new(Log2Space::new(100.0, 400.0, 12));
        landscape.consonance.fill(10.0);
        landscape.consonance01.fill(0.3);
        let val = landscape.evaluate_pitch01(200.0);
        assert!((val - 0.3).abs() < 1e-6, "val={val}");
    }

    #[test]
    fn evaluate_pitch01_is_clamped() {
        let mut landscape = Landscape::new(Log2Space::new(100.0, 400.0, 12));
        landscape.consonance01.fill(1.2);
        let val = landscape.evaluate_pitch01(200.0);
        assert!((val - 1.0).abs() < 1e-6, "val={val}");
    }

    #[test]
    fn consonance01_matches_formula_after_updates() {
        let space = Log2Space::new(100.0, 400.0, 12);
        let params = build_params(&space);
        let mut landscape = Landscape::new(space);
        let n = landscape.roughness01.len();
        landscape.harmonicity = vec![0.25; n];
        landscape.roughness = vec![0.0; n];
        landscape.roughness01 = vec![0.4; n];
        landscape.recompute_consonance(&params);

        let w_r = params.consonance_roughness_weight;
        for i in 0..n {
            let h = landscape.harmonicity[i].clamp(0.0, 1.0);
            let r = landscape.roughness01[i].clamp(0.0, 1.0);
            let c_signed = (h - w_r * r).clamp(-1.0, 1.0);
            let c_pred = ((c_signed + 1.0) * 0.5).clamp(0.0, 1.0);
            let c = landscape.consonance01[i];
            assert!((c - c_pred).abs() < 1e-6, "i={i} c={c} c_pred={c_pred}");
        }
    }

    #[test]
    fn consonance01_independent_of_update_order() {
        let space = Log2Space::new(100.0, 400.0, 12);
        let params = build_params(&space);
        let mut a = Landscape::new(space.clone());
        let n = a.roughness01.len();
        a.harmonicity = vec![0.75; n];
        a.roughness01 = vec![0.35; n];
        a.recompute_consonance(&params);
        let c_a = a.consonance01.clone();

        let mut b = Landscape::new(space);
        b.roughness01 = vec![0.35; n];
        b.harmonicity = vec![0.75; n];
        b.recompute_consonance(&params);
        for i in 0..n {
            let da = c_a[i];
            let db = b.consonance01[i];
            assert!((da - db).abs() < 1e-6, "i={i} da={da} db={db}");
        }
    }

    #[test]
    fn consonance01_decreases_linearly_with_roughness() {
        let space = Log2Space::new(100.0, 400.0, 12);
        let mut params = build_params(&space);
        params.consonance_roughness_weight = 1.0;

        let mut landscape = Landscape::new(space);
        let n = landscape.roughness01.len();
        landscape.harmonicity = vec![1.0; n];
        landscape.roughness = vec![0.0; n];

        landscape.roughness01 = vec![0.0; n];
        landscape.recompute_consonance(&params);
        assert!((landscape.consonance01[0] - 1.0).abs() < 1e-6);

        landscape.roughness01 = vec![0.5; n];
        landscape.recompute_consonance(&params);
        assert!((landscape.consonance01[0] - 0.75).abs() < 1e-6);

        landscape.roughness01 = vec![1.0; n];
        landscape.recompute_consonance(&params);
        assert!((landscape.consonance01[0] - 0.5).abs() < 1e-6);
    }

    #[test]
    fn resize_to_space_keeps_lengths_and_allows_recompute() {
        let space_a = Log2Space::new(100.0, 400.0, 12);
        let space_b = Log2Space::new(80.0, 800.0, 24);
        let mut landscape = Landscape::new(space_a);
        landscape.harmonicity.fill(0.6);
        landscape.roughness01.fill(0.2);

        landscape.resize_to_space(space_b.clone());
        let n = space_b.n_bins();
        assert_eq!(landscape.roughness.len(), n);
        assert_eq!(landscape.roughness01.len(), n);
        assert_eq!(landscape.harmonicity.len(), n);
        assert_eq!(landscape.harmonicity01.len(), n);
        assert_eq!(landscape.consonance.len(), n);
        assert_eq!(landscape.consonance01.len(), n);
        assert_eq!(landscape.subjective_intensity.len(), n);
        assert_eq!(landscape.nsgt_power.len(), n);

        let params = build_params(&space_b);
        landscape.recompute_consonance(&params);
    }
}

impl Default for Landscape {
    fn default() -> Self {
        Self::new(Log2Space::new(1.0, 2.0, 1))
    }
}
</file>

<file path="src/core/log2space.rs">
//! core/log2.rs — Log2 frequency space (octave-based).
//!
//! Provides uniform log2(Hz) mapping used by NSGT and kernel convolution.
//! Example: 27.5 Hz → log2(27.5)=4.78, 55 Hz→5.78 (1 octave up).

/// Uniform log2(Hz) frequency space.
#[derive(Clone, Debug)]
pub struct Log2Space {
    pub fmin: f32,
    pub fmax: f32,
    pub bins_per_oct: u32,
    pub centers_hz: Vec<f32>,
    pub centers_log2: Vec<f32>,
    pub step_log2: f32,
}

/// Explicit log2 axis specification (for external DSP handoff or regeneration).
#[derive(Clone, Copy, Debug)]
pub struct Log2SpaceSpec {
    pub fmin: f32,
    pub fmax: f32,
    pub bins_per_oct: u32,
}

impl Log2Space {
    /// Create a log2-space grid between fmin..fmax (inclusive).
    pub fn new(fmin: f32, fmax: f32, bins_per_oct: u32) -> Self {
        assert!(fmin > 0.0 && fmax > fmin);
        assert!(bins_per_oct > 0);

        let lo = fmin.log2();
        let hi = fmax.log2();
        let step_log2 = 1.0 / bins_per_oct as f32;
        let n_bins = ((hi - lo) / step_log2).floor() as usize + 1;

        let centers_log2: Vec<f32> = (0..n_bins).map(|i| lo + i as f32 * step_log2).collect();
        let centers_hz: Vec<f32> = centers_log2.iter().map(|&x| 2f32.powf(x)).collect();

        Self {
            fmin,
            fmax,
            bins_per_oct,
            centers_hz,
            centers_log2,
            step_log2,
        }
    }

    /// Number of bins.
    #[inline]
    pub fn n_bins(&self) -> usize {
        self.centers_hz.len()
    }

    #[inline]
    pub fn assert_scan_len<T>(&self, scan: &[T]) {
        debug_assert_eq!(scan.len(), self.n_bins());
    }

    #[inline]
    pub fn assert_scan_len_named<T>(&self, scan: &[T], name: &str) {
        debug_assert_eq!(scan.len(), self.n_bins(), "scan length mismatch: {name}");
    }

    /// Compact metadata for re-creating this log2 axis elsewhere.
    #[inline]
    pub fn spec(&self) -> Log2SpaceSpec {
        Log2SpaceSpec {
            fmin: self.fmin,
            fmax: self.fmax,
            bins_per_oct: self.bins_per_oct,
        }
    }

    /// Convert Hz → log2(Hz)
    #[inline]
    pub fn hz_to_log2(&self, hz: f32) -> f32 {
        hz.log2()
    }

    /// Convert log2(Hz) → Hz
    #[inline]
    pub fn log2_to_hz(&self, l: f32) -> f32 {
        2f32.powf(l)
    }

    /// Return Δlog2 per bin (1/bins_per_oct).
    #[inline]
    pub fn step(&self) -> f32 {
        self.step_log2
    }

    /// Find nearest bin index for given frequency.
    pub fn index_of_freq(&self, hz: f32) -> Option<usize> {
        if hz < self.fmin || hz > self.fmax {
            return None;
        }
        let l = hz.log2();
        let idx = ((l - self.centers_log2[0]) / self.step_log2).round() as usize;
        self.centers_hz.get(idx)?;
        Some(idx)
    }

    /// Map Hz to a continuous bin position (0..n_bins-1).
    pub fn bin_pos_of_freq(&self, hz: f32) -> Option<f32> {
        if !hz.is_finite() || hz < self.fmin || hz > self.fmax {
            return None;
        }
        let l = hz.log2();
        let pos = (l - self.centers_log2[0]) / self.step_log2;
        if pos.is_finite() { Some(pos) } else { None }
    }

    /// Find nearest bin index for a log2(Hz) coordinate.
    pub fn index_of_log2(&self, log2_hz: f32) -> Option<usize> {
        let hz = 2f32.powf(log2_hz);
        self.index_of_freq(hz)
    }

    pub fn freq_of_index(&self, i: usize) -> f32 {
        self.centers_hz[i]
    }

    /// Approximate linear bandwidth (Hz) of a log2-space bin.
    ///
    /// - Constant-Q spacing: Δlog2 = 1 / bins_per_oct.
    /// - Formula: Δf = f * (2^(Δlog2/2) − 2^(−Δlog2/2)).
    /// - Q = f / Δf = 1 / (2^(Δlog2/2) − 2^(−Δlog2/2)).
    ///
    /// Use `bandwidth_hz_at(i)` for bin index, or this for arbitrary frequency.
    #[inline]
    pub fn bandwidth_hz(&self, f_hz: f32) -> f32 {
        let half_step = 0.5 * self.step_log2;
        let delta = 2f32.powf(half_step) - 2f32.powf(-half_step);
        (f_hz * delta).max(1e-6)
    }

    /// Bandwidth (Hz) of the i-th bin center.
    #[inline]
    pub fn bandwidth_hz_at(&self, i: usize) -> f32 {
        if let Some(&f_hz) = self.centers_hz.get(i) {
            self.bandwidth_hz(f_hz)
        } else {
            0.0
        }
    }

    /// Return Δlog2 between two frequencies.
    #[inline]
    pub fn delta_log2(&self, f1: f32, f2: f32) -> f32 {
        f2.log2() - f1.log2()
    }
}

/// Sample a Log2Space-aligned scan by linear interpolation in log2-frequency.
pub fn sample_scan_linear_log2(space: &Log2Space, scan: &[f32], freq_hz: f32) -> f32 {
    if scan.is_empty() || scan.len() != space.n_bins() {
        return f32::NEG_INFINITY;
    }
    if !freq_hz.is_finite() || freq_hz <= 0.0 {
        return f32::NEG_INFINITY;
    }
    if freq_hz < space.fmin || freq_hz > space.fmax {
        return f32::NEG_INFINITY;
    }
    let pos = match space.bin_pos_of_freq(freq_hz) {
        Some(pos) => pos,
        None => return f32::NEG_INFINITY,
    };
    let idx_base = pos.floor();
    let idx = idx_base as isize;
    if idx < 0 {
        return f32::NEG_INFINITY;
    }
    let idx = idx as usize;
    let frac = pos - idx_base;
    if idx + 1 < scan.len() {
        let v0 = scan[idx];
        let v1 = scan[idx + 1];
        let out = (v0 * (1.0 - frac)) + (v1 * frac);
        if out.is_finite() {
            out
        } else {
            f32::NEG_INFINITY
        }
    } else if idx < scan.len() {
        let out = scan[idx];
        if out.is_finite() {
            out
        } else {
            f32::NEG_INFINITY
        }
    } else {
        f32::NEG_INFINITY
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_log2space_basic() {
        let s = Log2Space::new(27.5, 880.0, 12);
        assert!(s.n_bins() > 0);
        assert!(s.centers_hz[0] >= 27.5);
        assert!(s.centers_hz.last().unwrap() <= &880.1);
        let idx = s.index_of_freq(55.0).unwrap();
        let ratio = s.centers_hz[idx] / s.centers_hz[0];
        // One octave ≈ factor 2
        assert!(ratio > 1.9 && ratio < 2.1);
    }

    #[test]
    fn test_log2space_geometric_spacing() {
        let s = Log2Space::new(55.0, 3520.0, 24);
        let ratios: Vec<f32> = s.centers_hz.windows(2).map(|w| w[1] / w[0]).collect();
        let target = ratios[0];
        assert!(ratios.iter().all(|&r| (r / target - 1.0).abs() < 1e-6));
        assert!(s.centers_hz.windows(2).all(|w| w[1] > w[0]));
        assert!(s.centers_hz[0] >= s.fmin);
        assert!(s.centers_hz.last().unwrap() <= &s.fmax);
    }

    #[test]
    fn test_bandwidth_constant_q_relation() {
        let space = Log2Space::new(100.0, 6400.0, 24);
        let q_target = 1.0 / (2f32.powf(1.0 / (24.0 * 2.0)) - 2f32.powf(-1.0 / (24.0 * 2.0)));
        for &f in &[100.0, 400.0, 1600.0, 6400.0] {
            let bw = space.bandwidth_hz(f);
            let q = f / bw;
            assert!(
                (q / q_target - 1.0).abs() < 1e-5,
                "Q mismatch: got {q}, want {q_target}"
            );
        }
    }

    #[test]
    fn test_bandwidth_hz_at_matches_bandwidth_hz() {
        let space = Log2Space::new(100.0, 6400.0, 24);
        for i in [0, space.n_bins() / 2, space.n_bins() - 1] {
            let bw_f = space.bandwidth_hz(space.centers_hz[i]);
            let bw_i = space.bandwidth_hz_at(i);
            assert!((bw_f - bw_i).abs() / bw_f < 1e-6, "Mismatch at bin {i}");
        }
    }

    #[test]
    fn test_bandwidth_scales_linearly_with_frequency() {
        let space = Log2Space::new(100.0, 6400.0, 12);
        let bw1 = space.bandwidth_hz(100.0);
        let bw2 = space.bandwidth_hz(200.0);
        let bw4 = space.bandwidth_hz(400.0);
        let ratio12 = bw2 / bw1;
        let ratio24 = bw4 / bw2;
        assert!((ratio12 - 2.0).abs() < 0.05);
        assert!((ratio24 - 2.0).abs() < 0.05);
    }
}
</file>

<file path="src/life/control.rs">
use schemars::JsonSchema;
use serde::{Deserialize, Deserializer, Serialize};
use serde_json::Value;

const AMP_MIN: f32 = 0.0;
const AMP_MAX: f32 = 1.0;
const TIMBRE_MIN: f32 = 0.0;
const TIMBRE_MAX: f32 = 1.0;
const RANGE_OCT_MIN: f32 = 0.0;
const RANGE_OCT_MAX: f32 = 6.0;
const FREQ_MIN_HZ: f32 = 1.0;
const FREQ_MAX_HZ: f32 = 20_000.0;

fn de_f32<'de, D>(deserializer: D) -> Result<f32, D::Error>
where
    D: Deserializer<'de>,
{
    let v = f64::deserialize(deserializer)?;
    Ok(v as f32)
}

fn de_f32_clamp_amp<'de, D>(deserializer: D) -> Result<f32, D::Error>
where
    D: Deserializer<'de>,
{
    let v = de_f32(deserializer)?;
    Ok(v.clamp(AMP_MIN, AMP_MAX))
}

fn de_f32_clamp_timbre<'de, D>(deserializer: D) -> Result<f32, D::Error>
where
    D: Deserializer<'de>,
{
    let v = de_f32(deserializer)?;
    Ok(v.clamp(TIMBRE_MIN, TIMBRE_MAX))
}

fn de_f32_clamp_range_oct<'de, D>(deserializer: D) -> Result<f32, D::Error>
where
    D: Deserializer<'de>,
{
    let v = de_f32(deserializer)?;
    Ok(v.clamp(RANGE_OCT_MIN, RANGE_OCT_MAX))
}

fn de_f32_clamp_unit<'de, D>(deserializer: D) -> Result<f32, D::Error>
where
    D: Deserializer<'de>,
{
    let v = de_f32(deserializer)?;
    Ok(v.clamp(0.0, 1.0))
}

fn de_f32_clamp_freq<'de, D>(deserializer: D) -> Result<f32, D::Error>
where
    D: Deserializer<'de>,
{
    let v = de_f32(deserializer)?;
    Ok(v.clamp(FREQ_MIN_HZ, FREQ_MAX_HZ))
}

fn de_opt_f32_clamp_amp<'de, D>(deserializer: D) -> Result<Option<f32>, D::Error>
where
    D: Deserializer<'de>,
{
    let v = Option::<f64>::deserialize(deserializer)?;
    Ok(v.map(|v| (v as f32).clamp(AMP_MIN, AMP_MAX)))
}

fn de_opt_f32_clamp_timbre<'de, D>(deserializer: D) -> Result<Option<f32>, D::Error>
where
    D: Deserializer<'de>,
{
    let v = Option::<f64>::deserialize(deserializer)?;
    Ok(v.map(|v| (v as f32).clamp(TIMBRE_MIN, TIMBRE_MAX)))
}

fn de_opt_f32_clamp_range_oct<'de, D>(deserializer: D) -> Result<Option<f32>, D::Error>
where
    D: Deserializer<'de>,
{
    let v = Option::<f64>::deserialize(deserializer)?;
    Ok(v.map(|v| (v as f32).clamp(RANGE_OCT_MIN, RANGE_OCT_MAX)))
}

fn de_opt_f32_clamp_unit<'de, D>(deserializer: D) -> Result<Option<f32>, D::Error>
where
    D: Deserializer<'de>,
{
    let v = Option::<f64>::deserialize(deserializer)?;
    Ok(v.map(|v| (v as f32).clamp(0.0, 1.0)))
}

fn de_opt_f32_clamp_freq<'de, D>(deserializer: D) -> Result<Option<f32>, D::Error>
where
    D: Deserializer<'de>,
{
    let v = Option::<f64>::deserialize(deserializer)?;
    Ok(v.map(|v| (v as f32).clamp(FREQ_MIN_HZ, FREQ_MAX_HZ)))
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct WorldControl {}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct AgentControl {
    #[serde(default)]
    pub body: BodyControl,
    #[serde(default)]
    pub pitch: PitchControl,
    #[serde(default)]
    pub phonation: PhonationControl,
    #[serde(default)]
    pub perceptual: PerceptualControl,
}

impl AgentControl {
    pub fn validate(&self) -> Result<(), String> {
        let freq = self.pitch.freq;
        if !freq.is_finite() || freq <= 0.0 {
            return Err("pitch.freq must be finite and > 0".to_string());
        }
        Ok(())
    }

    pub fn to_json(&self) -> Result<Value, String> {
        serde_json::to_value(self).map_err(|e| format!("serialize AgentControl: {e}"))
    }

    pub fn from_json(value: Value) -> Result<Self, String> {
        let control: AgentControl =
            serde_json::from_value(value).map_err(|e| format!("parse AgentControl: {e}"))?;
        control.validate()?;
        Ok(control)
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum BodyMethod {
    #[default]
    Sine,
    Harmonic,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct TimbreControl {
    #[serde(default, deserialize_with = "de_f32_clamp_timbre")]
    pub brightness: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_timbre")]
    pub inharmonic: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_timbre")]
    pub width: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_timbre")]
    pub motion: f32,
}

impl Default for TimbreControl {
    fn default() -> Self {
        Self {
            brightness: 0.6,
            inharmonic: 0.0,
            width: 0.0,
            motion: 0.0,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct BodyControl {
    #[serde(default)]
    pub method: BodyMethod,
    #[serde(default, deserialize_with = "de_f32_clamp_amp")]
    pub amp: f32,
    #[serde(default)]
    pub timbre: TimbreControl,
}

impl Default for BodyControl {
    fn default() -> Self {
        Self {
            method: BodyMethod::default(),
            amp: 0.18,
            timbre: TimbreControl::default(),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum PitchMode {
    #[default]
    Free,
    Lock,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct PitchControl {
    #[serde(default)]
    pub mode: PitchMode,
    /// Frequency in Hz: center for free mode, fixed output for lock.
    #[serde(default, deserialize_with = "de_f32_clamp_freq")]
    pub freq: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_range_oct")]
    pub range_oct: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub gravity: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub exploration: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub persistence: f32,
}

impl Default for PitchControl {
    fn default() -> Self {
        Self {
            mode: PitchMode::Free,
            freq: 220.0,
            range_oct: RANGE_OCT_MAX,
            gravity: 0.5,
            exploration: 0.0,
            persistence: 0.5,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum PhonationType {
    #[default]
    Interval,
    Clock,
    Field,
    /// Sustain once per lifecycle; ignores density/sync/legato.
    Hold,
    None,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct PhonationControl {
    #[serde(default, rename = "type")]
    pub r#type: PhonationType,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub density: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub sync: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub legato: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub sociality: f32,
}

impl Default for PhonationControl {
    fn default() -> Self {
        Self {
            r#type: PhonationType::default(),
            density: 0.5,
            sync: 0.5,
            legato: 0.5,
            sociality: 0.0,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct PerceptualControl {
    #[serde(default)]
    pub enabled: bool,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub adaptation: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub novelty_bias: f32,
    #[serde(default, deserialize_with = "de_f32_clamp_unit")]
    pub self_focus: f32,
}

impl Default for PerceptualControl {
    fn default() -> Self {
        Self {
            enabled: true,
            adaptation: 0.5,
            novelty_bias: 1.0,
            self_focus: 0.15,
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct AgentPatch {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub body: Option<BodyPatch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub pitch: Option<PitchPatch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub phonation: Option<PhonationPatch>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub perceptual: Option<PerceptualPatch>,
}

impl AgentPatch {
    pub fn contains_type_switch(&self) -> bool {
        self.body
            .as_ref()
            .and_then(|body| body.method.as_ref())
            .is_some()
            || self
                .phonation
                .as_ref()
                .and_then(|phonation| phonation.r#type.as_ref())
                .is_some()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct BodyPatch {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<BodyMethod>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_amp",
        skip_serializing_if = "Option::is_none"
    )]
    pub amp: Option<f32>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub timbre: Option<TimbrePatch>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct TimbrePatch {
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_timbre",
        skip_serializing_if = "Option::is_none"
    )]
    pub brightness: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_timbre",
        skip_serializing_if = "Option::is_none"
    )]
    pub inharmonic: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_timbre",
        skip_serializing_if = "Option::is_none"
    )]
    pub width: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_timbre",
        skip_serializing_if = "Option::is_none"
    )]
    pub motion: Option<f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct PitchPatch {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub mode: Option<PitchMode>,
    /// Frequency in Hz: center for free mode, fixed output for lock.
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_freq",
        skip_serializing_if = "Option::is_none"
    )]
    pub freq: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_range_oct",
        skip_serializing_if = "Option::is_none"
    )]
    pub range_oct: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub gravity: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub exploration: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub persistence: Option<f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct PhonationPatch {
    #[serde(default, rename = "type", skip_serializing_if = "Option::is_none")]
    pub r#type: Option<PhonationType>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub density: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub sync: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub legato: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub sociality: Option<f32>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct PerceptualPatch {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub adaptation: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub novelty_bias: Option<f32>,
    #[serde(
        default,
        deserialize_with = "de_opt_f32_clamp_unit",
        skip_serializing_if = "Option::is_none"
    )]
    pub self_focus: Option<f32>,
}

pub fn merge_json(base: Value, patch: Value) -> Value {
    match (base, patch) {
        (Value::Object(mut base_map), Value::Object(patch_map)) => {
            for (k, v) in patch_map {
                let base_val = base_map.remove(&k).unwrap_or(Value::Null);
                base_map.insert(k, merge_json(base_val, v));
            }
            Value::Object(base_map)
        }
        (_, patch_val) => patch_val,
    }
}

pub fn remove_json_path(value: &mut Value, path: &str) -> bool {
    let mut parts = path.split('.').filter(|p| !p.is_empty()).peekable();
    let mut cursor = value;
    while let Some(part) = parts.next() {
        let is_last = parts.peek().is_none();
        match cursor {
            Value::Object(map) => {
                if is_last {
                    return map.remove(part).is_some();
                }
                if let Some(next) = map.get_mut(part) {
                    cursor = next;
                } else {
                    return false;
                }
            }
            _ => return false,
        }
    }
    false
}

#[derive(Clone, Copy, Debug)]
enum GlobToken {
    AnySeq,
    AnyChar,
    Literal(char),
}

fn parse_glob_pattern(pattern: &str) -> Vec<GlobToken> {
    let mut tokens = Vec::new();
    let mut chars = pattern.chars().peekable();
    while let Some(ch) = chars.next() {
        match ch {
            '\\' => {
                if let Some(next) = chars.next() {
                    tokens.push(GlobToken::Literal(next));
                } else {
                    tokens.push(GlobToken::Literal('\\'));
                }
            }
            '*' => tokens.push(GlobToken::AnySeq),
            '?' => tokens.push(GlobToken::AnyChar),
            _ => tokens.push(GlobToken::Literal(ch)),
        }
    }
    tokens
}

pub(crate) fn matches_tag_pattern(pattern: &str, text: &str) -> bool {
    let tokens = parse_glob_pattern(pattern);
    let chars: Vec<char> = text.chars().collect();
    let mut dp = vec![vec![false; chars.len() + 1]; tokens.len() + 1];
    dp[0][0] = true;
    for (i, token) in tokens.iter().enumerate() {
        match token {
            GlobToken::AnySeq => {
                for j in 0..=chars.len() {
                    if dp[i][j] {
                        dp[i + 1][j] = true;
                        if j < chars.len() {
                            dp[i][j + 1] = true;
                        }
                    }
                }
            }
            GlobToken::AnyChar => {
                for j in 0..chars.len() {
                    if dp[i][j] {
                        dp[i + 1][j + 1] = true;
                    }
                }
            }
            GlobToken::Literal(ch) => {
                for j in 0..chars.len() {
                    if dp[i][j] && chars[j] == *ch {
                        dp[i + 1][j + 1] = true;
                    }
                }
            }
        }
    }
    dp[tokens.len()][chars.len()]
}
</file>

<file path="src/life/pitch_controller.rs">
use super::pitch_core::{AnyPitchCore, PitchCore};
use crate::core::landscape::Landscape;
use crate::core::modulation::NeuralRhythms;
use crate::life::control::{PitchControl, PitchMode};
use crate::life::perceptual::{FeaturesNow, PerceptualContext};
use rand::rngs::SmallRng;

#[derive(Debug)]
pub struct PitchController {
    core: AnyPitchCore,
    perceptual: PerceptualContext,
    target_pitch_log2: f32,
    integration_window: f32,
    accumulated_time: f32,
    last_theta_phase: f32,
    theta_phase_initialized: bool,
    last_target_salience: f32,
    rng: SmallRng,
    perceptual_enabled: bool,
}

impl PitchController {
    pub fn new(
        core: AnyPitchCore,
        perceptual: PerceptualContext,
        target_pitch_log2: f32,
        integration_window: f32,
        rng: SmallRng,
    ) -> Self {
        Self {
            core,
            perceptual,
            target_pitch_log2,
            integration_window,
            accumulated_time: 0.0,
            last_theta_phase: 0.0,
            theta_phase_initialized: false,
            last_target_salience: 0.0,
            rng,
            perceptual_enabled: true,
        }
    }

    pub fn target_pitch_log2(&self) -> f32 {
        self.target_pitch_log2
    }

    pub fn integration_window(&self) -> f32 {
        self.integration_window
    }

    pub fn last_target_salience(&self) -> f32 {
        self.last_target_salience
    }

    pub fn core_mut(&mut self) -> &mut AnyPitchCore {
        &mut self.core
    }

    pub fn perceptual_mut(&mut self) -> &mut PerceptualContext {
        &mut self.perceptual
    }

    pub fn set_perceptual_enabled(&mut self, enabled: bool) {
        self.perceptual_enabled = enabled;
    }

    pub fn force_set_target_pitch_log2(&mut self, log_freq: f32) {
        self.target_pitch_log2 = log_freq.max(0.0);
        self.accumulated_time = 0.0;
        self.last_theta_phase = 0.0;
        self.theta_phase_initialized = false;
        self.last_target_salience = 0.0;
    }

    /// Update pitch targets at control rate (hop-sized steps).
    pub fn update_pitch_target(
        &mut self,
        current_freq_hz: f32,
        rhythms: &NeuralRhythms,
        dt_sec: f32,
        landscape: &Landscape,
        pitch: &PitchControl,
    ) {
        let dt_sec = dt_sec.max(0.0);
        let current_freq = current_freq_hz.max(1.0);
        let current_pitch_log2 = current_freq.log2();
        let mut target_pitch_log2 = if self.target_pitch_log2 <= 0.0 {
            current_pitch_log2
        } else {
            self.target_pitch_log2
        };
        self.integration_window = 2.0 + 10.0 / current_freq.max(1.0);
        self.accumulated_time += dt_sec;

        // Detect theta wrap to avoid missing zero-crossings at control rate.
        let theta_phase = rhythms.theta.phase;
        let theta_cross = if theta_phase.is_finite() && self.last_theta_phase.is_finite() {
            let wrapped = self.theta_phase_initialized && theta_phase < self.last_theta_phase;
            wrapped && rhythms.theta.mag.is_finite() && rhythms.theta.mag > 0.0
        } else {
            false
        };
        self.last_theta_phase = if theta_phase.is_finite() {
            self.theta_phase_initialized = true;
            theta_phase
        } else {
            self.theta_phase_initialized = false;
            0.0
        };

        // Perceptual gating only affects proposal/learning, not lock overrides.
        if self.perceptual_enabled
            && theta_cross
            && self.accumulated_time >= self.integration_window
        {
            let elapsed = self.accumulated_time;
            self.accumulated_time = 0.0;
            let features = FeaturesNow::from_subjective_intensity(&landscape.subjective_intensity);
            debug_assert_eq!(features.distribution.len(), landscape.space.n_bins());
            self.perceptual.ensure_len(features.distribution.len());
            let proposal = self.core.propose_target(
                current_pitch_log2,
                target_pitch_log2,
                current_freq,
                self.integration_window,
                landscape,
                &self.perceptual,
                &features,
                &mut self.rng,
            );
            target_pitch_log2 = proposal.target_pitch_log2;
            self.last_target_salience = proposal.salience;
            if let Some(idx) = landscape.space.index_of_log2(target_pitch_log2) {
                self.perceptual.update(idx, &features, elapsed);
            }
        }

        let (fmin, fmax) = landscape.freq_bounds_log2();
        if matches!(pitch.mode, PitchMode::Lock) {
            let freq = if pitch.freq.is_finite() && pitch.freq > 0.0 {
                pitch.freq
            } else {
                current_freq
            };
            let lock_log2 = freq.log2();
            self.target_pitch_log2 = lock_log2.clamp(fmin, fmax);
            return;
        }
        let center_log2 = if pitch.freq.is_finite() && pitch.freq > 0.0 {
            pitch.freq.log2()
        } else {
            current_pitch_log2
        };
        let range_oct = pitch.range_oct.clamp(0.0, 6.0);
        let (min_range, max_range) = if range_oct <= 0.0 {
            (center_log2, center_log2)
        } else {
            let half = range_oct * 0.5;
            (center_log2 - half, center_log2 + half)
        };
        let min = fmin.max(min_range);
        let max = fmax.min(max_range);
        let clamped = if min <= max {
            target_pitch_log2.clamp(min, max)
        } else {
            target_pitch_log2.clamp(fmin, fmax)
        };
        target_pitch_log2 = clamped;
        self.target_pitch_log2 = target_pitch_log2;
    }
}

#[cfg(test)]
impl PitchController {
    pub(crate) fn set_accumulated_time_for_test(&mut self, value: f32) {
        self.accumulated_time = value;
    }

    pub(crate) fn accumulated_time_for_test(&self) -> f32 {
        self.accumulated_time
    }

    pub(crate) fn set_theta_phase_state_for_test(&mut self, last_phase: f32, initialized: bool) {
        self.last_theta_phase = last_phase;
        self.theta_phase_initialized = initialized;
    }
}
</file>

<file path="tests/compile_only_samples.rs">
use std::path::Path;

use walkdir::WalkDir;

use conchordal::app::compile_scenario_from_script;
use conchordal::cli::Args;
use conchordal::config::AppConfig;

fn args_for_path(path: &Path) -> Args {
    #[cfg(debug_assertions)]
    let args = Args {
        play: false,
        wav: None,
        scenario_path: path.to_string_lossy().to_string(),
        config: "config.toml".to_string(),
        wait_user_exit: None,
        wait_user_start: None,
        nogui: false,
        compile_only: false,
    };
    #[cfg(not(debug_assertions))]
    let args = Args {
        play: false,
        scenario_path: path.to_string_lossy().to_string(),
        config: "config.toml".to_string(),
        wait_user_exit: None,
        wait_user_start: None,
        nogui: false,
        compile_only: false,
    };
    args
}

fn default_config() -> AppConfig {
    AppConfig::default()
}

#[test]
fn compile_only_samples_tests() {
    let dir = Path::new("samples");
    let mut count = 0;
    for entry in WalkDir::new(dir).into_iter().filter_map(Result::ok) {
        let path = entry.path();
        if let Some(name) = path.file_name().and_then(|n| n.to_str())
            && name.starts_with(".#")
        {
            continue;
        }
        if path.extension().and_then(|s| s.to_str()) != Some("rhai") {
            continue;
        }
        count += 1;
        let args = args_for_path(path);
        let config = default_config();
        compile_scenario_from_script(path, &args, &config)
            .unwrap_or_else(|e| panic!("compile-only failed for {}: {e}", path.display()));
    }
    assert!(count > 0, "no .rhai scripts found in samples");
}
</file>

<file path="tests/control_rate_dt_invariance.rs">
use conchordal::core::landscape::Landscape;
use conchordal::core::log2space::Log2Space;
use conchordal::core::modulation::{NeuralRhythms, RhythmBand};
use conchordal::life::control::AgentControl;
use conchordal::life::individual::{
    AgentMetadata, AnyArticulationCore, ArticulationState, Individual,
};
use conchordal::life::scenario::IndividualConfig;

fn build_agent() -> Individual {
    let mut control = AgentControl::default();
    control.pitch.freq = 440.0;
    control.body.amp = 0.3;
    let cfg = IndividualConfig { control, tag: None };
    let metadata = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    cfg.spawn(1, 0, metadata, 48_000.0, 0)
}

fn prepare_agent(mut agent: Individual) -> Individual {
    agent.articulation.set_gate(0.2);
    if let AnyArticulationCore::Entrain(core) = &mut agent.articulation.core {
        core.base_sigma = 0.0;
        core.beta_gain = 0.0;
        core.retrigger = false;
        core.state = ArticulationState::Decay;
        core.env_level = 0.7;
        core.energy = 0.9;
        core.bootstrap_timer = 0.0;
        core.rhythm_phase = 0.2;
    } else {
        panic!("expected entrain articulation core");
    }
    agent
}

#[test]
fn control_rate_dt_invariance() {
    let space = Log2Space::new(55.0, 8000.0, 96);
    let landscape = Landscape::new(space);
    let rhythms = NeuralRhythms {
        theta: RhythmBand {
            phase: 0.1,
            freq_hz: 6.0,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.0,
        },
        delta: RhythmBand {
            phase: 0.0,
            freq_hz: 1.0,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.0,
        },
        env_open: 1.0,
        env_level: 1.0,
    };

    let mut fine = prepare_agent(build_agent());
    let mut coarse = prepare_agent(build_agent());

    let total_sec = 0.05;
    let steps = 10;
    let dt = total_sec / steps as f32;
    for _ in 0..steps {
        fine.update_articulation(dt, &rhythms, &landscape, 1.0);
    }
    coarse.update_articulation(total_sec, &rhythms, &landscape, 1.0);

    let tol = 1e-2;
    let gate_fine = fine.articulation.gate();
    let gate_coarse = coarse.articulation.gate();
    assert!(
        (gate_fine - gate_coarse).abs() <= tol,
        "gate delta fine={gate_fine:.6} coarse={gate_coarse:.6}"
    );

    let (energy_fine, env_fine) = match &fine.articulation.core {
        AnyArticulationCore::Entrain(core) => (core.energy, core.env_level),
        _ => panic!("expected entrain articulation core"),
    };
    let (energy_coarse, env_coarse) = match &coarse.articulation.core {
        AnyArticulationCore::Entrain(core) => (core.energy, core.env_level),
        _ => panic!("expected entrain articulation core"),
    };

    assert!(
        (energy_fine - energy_coarse).abs() <= tol,
        "energy delta fine={energy_fine:.6} coarse={energy_coarse:.6}"
    );
    assert!(
        (env_fine - env_coarse).abs() <= tol,
        "env_level delta fine={env_fine:.6} coarse={env_coarse:.6}"
    );
}
</file>

<file path="src/life/api.rs">
use rhai::{EvalAltResult, FLOAT, Map, Position};

use super::scripting::ScriptContext;

pub fn push_time(ctx: &mut ScriptContext, position: Position) -> Result<(), Box<EvalAltResult>> {
    ctx.push_time(position)
}

pub fn pop_time(ctx: &mut ScriptContext, position: Position) -> Result<(), Box<EvalAltResult>> {
    ctx.pop_time(position)
}

pub fn set_time(
    ctx: &mut ScriptContext,
    sec: FLOAT,
    position: Position,
) -> Result<(), Box<EvalAltResult>> {
    ctx.set_time(sec as f32, position)
}

pub fn spawn_min_at(
    ctx: &mut ScriptContext,
    tag: &str,
    count: i64,
    position: Position,
) -> Result<i64, Box<EvalAltResult>> {
    ctx.spawn_default(tag, count, position)
}

pub fn spawn_with_third_at(
    ctx: &mut ScriptContext,
    tag: &str,
    count: i64,
    third: Map,
    position: Position,
) -> Result<i64, Box<EvalAltResult>> {
    ctx.spawn_with_third_map(tag, count, third, position)
}

pub fn spawn_with_opts_and_patch_at(
    ctx: &mut ScriptContext,
    tag: &str,
    count: i64,
    opts: Map,
    patch: Map,
    position: Position,
) -> Result<i64, Box<EvalAltResult>> {
    ctx.spawn_with_opts_and_patch(tag, count, Some(opts), Some(patch), position)
}
</file>

<file path="tests/intent_renderer_body_snapshot.rs">
use conchordal::core::modulation::NeuralRhythms;
use conchordal::core::timebase::Timebase;
use conchordal::life::intent::{BodySnapshot, Intent, IntentBoard};
use conchordal::life::schedule_renderer::ScheduleRenderer;

fn make_intent(kind: &str, brightness: f32) -> Intent {
    Intent {
        source_id: 0,
        intent_id: 1,
        onset: 5,
        duration: 20,
        freq_hz: 440.0,
        amp: 0.4,
        tag: None,
        confidence: 1.0,
        body: Some(BodySnapshot {
            kind: kind.to_string(),
            amp_scale: 1.0,
            brightness,
            noise_mix: 0.0,
        }),
        articulation: None,
    }
}

#[test]
fn body_snapshot_changes_timbre_without_shifting_onset() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let mut board_a = IntentBoard::new(tb.sec_to_tick(1.0), tb.sec_to_tick(1.0));
    let mut board_b = IntentBoard::new(tb.sec_to_tick(1.0), tb.sec_to_tick(1.0));
    board_a.publish(make_intent("sine", 0.0));
    board_b.publish(make_intent("harmonic", 0.8));

    let mut renderer_a = ScheduleRenderer::new(tb);
    let mut renderer_b = ScheduleRenderer::new(tb);
    let rhythms = NeuralRhythms::default();
    let out_a = renderer_a.render(&board_a, &[], 0, &rhythms, &[], &[]);
    let out_b = renderer_b.render(&board_b, &[], 0, &rhythms, &[], &[]);

    let eps = 1e-6_f32;
    let first_a = out_a
        .iter()
        .position(|&s| s.abs() > eps)
        .expect("expected onset sample");
    let first_b = out_b
        .iter()
        .position(|&s| s.abs() > eps)
        .expect("expected onset sample");
    assert_eq!(first_a, 5);
    assert_eq!(first_b, 5);

    assert!(
        out_a
            .iter()
            .zip(out_b.iter())
            .any(|(a, b)| (a - b).abs() > eps),
        "expected different timbre output"
    );
}
</file>

<file path="tests/intent_renderer_limiter.rs">
use conchordal::core::modulation::NeuralRhythms;
use conchordal::core::timebase::Timebase;
use conchordal::life::intent::{Intent, IntentBoard};
use conchordal::life::schedule_renderer::ScheduleRenderer;

#[test]
fn limiter_clamps_peak_and_stays_finite() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 128,
    };
    let mut board = IntentBoard::new(tb.sec_to_tick(1.0), tb.sec_to_tick(1.0));
    for i in 0..10u64 {
        board.publish(Intent {
            source_id: 0,
            intent_id: i,
            onset: 0,
            duration: 64,
            freq_hz: 440.0 + (i as f32 * 2.0),
            amp: 1.0,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        });
    }

    let mut renderer = ScheduleRenderer::new(tb);
    let rhythms = NeuralRhythms::default();
    let out = renderer.render(&board, &[], 0, &rhythms, &[], &[]);
    let mut peak = 0.0f32;
    for &s in out {
        assert!(s.is_finite());
        peak = peak.max(s.abs());
    }
    assert!(peak <= 0.981, "peak too high: {peak}");
}
</file>

<file path="tests/intent_renderer_onset.rs">
use conchordal::core::modulation::NeuralRhythms;
use conchordal::core::timebase::{Tick, Timebase};
use conchordal::life::intent::{Intent, IntentBoard};
use conchordal::life::schedule_renderer::ScheduleRenderer;

fn make_intent(intent_id: u64, onset: Tick, duration: Tick, freq: f32, amp: f32) -> Intent {
    Intent {
        source_id: 0,
        intent_id,
        onset,
        duration,
        freq_hz: freq,
        amp,
        tag: None,
        confidence: 1.0,
        body: None,
        articulation: None,
    }
}

#[test]
fn onset_is_sample_accurate_across_hops() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let mut board = IntentBoard::new(tb.sec_to_tick(10.0), tb.sec_to_tick(10.0));
    let onset: Tick = tb.hop as Tick + 7;
    board.publish(make_intent(1, onset, 40, 440.0, 0.5));

    let mut renderer = ScheduleRenderer::new(tb);
    let rhythms = NeuralRhythms::default();
    let mut out = Vec::new();
    out.extend_from_slice(renderer.render(&board, &[], 0, &rhythms, &[], &[]));
    out.extend_from_slice(renderer.render(&board, &[], tb.hop as Tick, &rhythms, &[], &[]));

    let eps = 1e-6_f32;
    let first = out
        .iter()
        .position(|&s| s.abs() > eps)
        .expect("expected onset sample");
    assert_eq!(first as u64, onset);
    assert!(out[onset as usize - 1].abs() <= eps);
    assert!(out[onset as usize].abs() > eps);
}
</file>

<file path="tests/schedule_renderer_cutoff.rs">
use conchordal::core::modulation::NeuralRhythms;
use conchordal::core::timebase::Timebase;
use conchordal::life::intent::{Intent, IntentBoard};
use conchordal::life::schedule_renderer::ScheduleRenderer;

#[test]
fn cutoff_skips_future_intents() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let mut board = IntentBoard::new(tb.sec_to_tick(1.0), tb.sec_to_tick(1.0));
    board.publish(Intent {
        source_id: 0,
        intent_id: 1,
        onset: 0,
        duration: 20,
        freq_hz: 440.0,
        amp: 0.6,
        tag: None,
        confidence: 1.0,
        body: None,
        articulation: None,
    });
    let rhythms = NeuralRhythms::default();

    let mut renderer_on = ScheduleRenderer::new(tb);
    let out_on = renderer_on.render(&board, &[], 0, &rhythms, &[], &[]);
    assert!(out_on.iter().any(|s| s.abs() > 1e-6));

    let mut renderer_cut = ScheduleRenderer::new(tb);
    renderer_cut.set_cutoff_tick(Some(0));
    let out_cut = renderer_cut.render(&board, &[], 0, &rhythms, &[], &[]);
    assert!(out_cut.iter().all(|s| s.abs() <= 1e-6));
}

#[test]
fn shutdown_releases_active_voices() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let mut board = IntentBoard::new(tb.sec_to_tick(2.0), tb.sec_to_tick(2.0));
    board.publish(Intent {
        source_id: 0,
        intent_id: 1,
        onset: 0,
        duration: tb.sec_to_tick(1.0),
        freq_hz: 440.0,
        amp: 0.6,
        tag: None,
        confidence: 1.0,
        body: None,
        articulation: None,
    });
    let rhythms = NeuralRhythms::default();

    let mut renderer = ScheduleRenderer::new(tb);
    let _ = renderer.render(&board, &[], 0, &rhythms, &[], &[]);
    assert!(!renderer.is_idle());

    renderer.shutdown_at(0);
    let mut now: u64 = 0;
    for _ in 0..16 {
        let _ = renderer.render(&board, &[], now, &rhythms, &[], &[]);
        now = now.saturating_add(tb.hop as u64);
    }
    assert!(renderer.is_idle());
}
</file>

<file path="tests/schedule_renderer_rhythm_signal.rs">
use conchordal::core::modulation::NeuralRhythms;
use conchordal::core::timebase::{Tick, Timebase};
use conchordal::life::intent::{BodySnapshot, Intent, IntentBoard};
use conchordal::life::schedule_renderer::ScheduleRenderer;

fn make_intent(intent_id: u64, onset: Tick, duration: Tick, freq: f32, amp: f32) -> Intent {
    Intent {
        source_id: 0,
        intent_id,
        onset,
        duration,
        freq_hz: freq,
        amp,
        tag: None,
        confidence: 1.0,
        body: Some(BodySnapshot {
            kind: "harmonic".to_string(),
            amp_scale: 1.0,
            brightness: 0.5,
            noise_mix: 1.0,
        }),
        articulation: None,
    }
}

#[test]
fn rhythm_signal_changes_output() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let retention = tb.sec_to_tick(2.0);
    let future = tb.sec_to_tick(2.0);
    let mut board = IntentBoard::new(retention, future);
    let duration = tb.hop as Tick;
    board.publish(make_intent(1, 0, duration, 440.0, 0.5));

    let mut renderer0 = ScheduleRenderer::new(tb);
    let mut rhythms0 = NeuralRhythms::default();
    rhythms0.theta.beta = 0.0;
    let out0 = renderer0.render(&board, &[], 0, &rhythms0, &[], &[]);

    let mut renderer1 = ScheduleRenderer::new(tb);
    let mut rhythms1 = NeuralRhythms::default();
    rhythms1.theta.beta = 1.0;
    let out1 = renderer1.render(&board, &[], 0, &rhythms1, &[], &[]);

    let mut any_diff = false;
    for (a, b) in out0.iter().zip(out1.iter()) {
        if (a - b).abs() > 1e-6 {
            any_diff = true;
            break;
        }
    }
    assert!(any_diff);
}
</file>

<file path="tests/schedule_renderer_short_duration.rs">
use conchordal::core::modulation::NeuralRhythms;
use conchordal::core::timebase::{Tick, Timebase};
use conchordal::life::intent::{Intent, IntentBoard};
use conchordal::life::schedule_renderer::ScheduleRenderer;

fn make_intent(intent_id: u64, onset: Tick, duration: Tick, freq: f32, amp: f32) -> Intent {
    Intent {
        source_id: 0,
        intent_id,
        onset,
        duration,
        freq_hz: freq,
        amp,
        tag: None,
        confidence: 1.0,
        body: None,
        articulation: None,
    }
}

#[test]
fn short_intent_silence_after_end() {
    let tb = Timebase {
        fs: 1000.0,
        hop: 16,
    };
    let retention = tb.sec_to_tick(2.0);
    let future = tb.sec_to_tick(2.0);
    let mut board = IntentBoard::new(retention, future);
    let onset: Tick = 0;
    let duration: Tick = (tb.hop as Tick).min(4).max(1);
    board.publish(make_intent(1, onset, duration, 440.0, 0.5));

    let mut renderer = ScheduleRenderer::new(tb);
    let rhythms = NeuralRhythms::default();

    let out_start = renderer.render(&board, &[], onset, &rhythms, &[], &[]);
    let mut max_start = 0.0f32;
    for &s in out_start {
        max_start = max_start.max(s.abs());
    }
    assert!(max_start > 1e-6_f32);

    let now_tick = onset.saturating_add(tb.sec_to_tick(1.0));
    let out_end = renderer.render(&board, &[], now_tick, &rhythms, &[], &[]);
    let mut max_end = 0.0f32;
    for &s in out_end {
        max_end = max_end.max(s.abs());
    }
    assert!(max_end <= 1e-6_f32);
}
</file>

<file path="tests/sound_voice_note_off_at_onset.rs">
use conchordal::core::modulation::NeuralRhythms;
use conchordal::core::timebase::Timebase;
use conchordal::life::intent::Intent;
use conchordal::life::sound::Voice;

#[test]
fn note_off_at_onset_still_releases() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let intent = Intent {
        source_id: 1,
        intent_id: 42,
        onset: 0,
        duration: tb.sec_to_tick(0.5),
        freq_hz: 440.0,
        amp: 0.5,
        tag: None,
        confidence: 1.0,
        body: None,
        articulation: None,
    };

    let mut voice = Voice::from_intent(tb, intent).expect("voice");
    voice.note_off(0);
    voice.arm_onset_trigger(1.0);

    let dt = 1.0 / tb.fs;
    let mut rhythms = NeuralRhythms::default();
    let mut max_amp = 0.0f32;
    let sample_ticks = tb.sec_to_tick(0.02).max(1);
    for tick in 0..sample_ticks {
        let s = voice.render_tick(tick, tb.fs, dt, &rhythms);
        max_amp = max_amp.max(s.abs());
        rhythms.advance_in_place(dt);
    }
    assert!(max_amp > 1e-6);

    let done_tick = tb.sec_to_tick(0.2);
    assert!(voice.is_done(done_tick));
}
</file>

<file path="src/life/intent.rs">
use std::collections::VecDeque;
use std::ops::Range;

use crate::core::timebase::Tick;

#[derive(Clone, Debug)]
pub struct Intent {
    pub source_id: u64,
    pub intent_id: u64,
    pub onset: Tick,
    pub duration: Tick,
    pub freq_hz: f32,
    pub amp: f32,
    pub tag: Option<String>,
    pub confidence: f32,
    pub body: Option<BodySnapshot>,
    pub articulation: Option<crate::life::individual::ArticulationWrapper>,
}

#[derive(Clone, Debug, PartialEq)]
pub struct BodySnapshot {
    pub kind: String,
    pub amp_scale: f32,
    pub brightness: f32,
    pub noise_mix: f32,
}

/// Schedule of committed intents (definitive timeline).
pub struct IntentBoard {
    pub retention_past: Tick,
    pub horizon_future: Tick,
    intents: VecDeque<Intent>,
}

impl IntentBoard {
    pub fn new(retention_past: Tick, horizon_future: Tick) -> Self {
        Self {
            retention_past,
            horizon_future,
            intents: VecDeque::new(),
        }
    }

    pub fn len(&self) -> usize {
        self.intents.len()
    }

    pub fn is_empty(&self) -> bool {
        self.intents.is_empty()
    }

    pub fn publish(&mut self, intent: Intent) {
        if self.intents.is_empty() {
            self.intents.push_back(intent);
            return;
        }

        let push_back = matches!(
            self.intents.back(),
            Some(last) if last.onset <= intent.onset
        );
        if push_back {
            self.intents.push_back(intent);
        } else if matches!(
            self.intents.front(),
            Some(first) if intent.onset < first.onset
        ) {
            self.intents.push_front(intent);
        } else {
            let insert_at = self
                .intents
                .iter()
                .position(|existing| existing.onset > intent.onset)
                .unwrap_or(self.intents.len());
            self.intents.insert(insert_at, intent);
        }
        debug_assert!(self.is_sorted_by_onset());
    }

    fn is_sorted_by_onset(&self) -> bool {
        self.intents
            .iter()
            .zip(self.intents.iter().skip(1))
            .all(|(a, b)| a.onset <= b.onset)
    }

    pub fn prune(&mut self, now_tick: Tick) {
        let min_keep_end = now_tick.saturating_sub(self.retention_past);
        self.intents.retain(|intent| {
            let end = intent.onset.saturating_add(intent.duration);
            end >= min_keep_end
        });

        let max_keep_onset = now_tick.saturating_add(self.horizon_future);
        while let Some(back) = self.intents.back() {
            if back.onset > max_keep_onset {
                self.intents.pop_back();
            } else {
                break;
            }
        }
    }

    pub fn query_range<'a>(&'a self, range: Range<Tick>) -> impl Iterator<Item = &'a Intent> + 'a {
        let start = range.start;
        let end = range.end;
        self.intents
            .iter()
            .take_while(move |intent| intent.onset < end)
            .filter(move |intent| {
                let intent_end = intent.onset.saturating_add(intent.duration);
                intent.onset < end && intent_end > start
            })
    }

    pub fn snapshot(&self, now_tick: Tick, past: Tick, future: Tick) -> Vec<Intent> {
        let t0 = now_tick.saturating_sub(past);
        let t1 = now_tick.saturating_add(future);
        self.query_range(t0..t1).cloned().collect()
    }

    pub fn remove_onset_from(&mut self, cutoff: Tick) {
        self.intents.retain(|intent| intent.onset < cutoff);
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "conchordal"
version = "0.1.0"
edition = "2024"
license = "MIT OR Apache-2.0"
description = "A bio-acoustic instrument for generative composition"
repository = "https://github.com/ktakahashi74/conchordal"
keywords = ["audio", "alife", "music", "art", "sound","synthesizer"]
categories = ["multimedia::audio"]

[lib]
test = false

[profile.dev]
opt-level = 1
debug = true
overflow-checks = true
incremental = true

[profile.release]
opt-level = 3
lto = true
#debug = true


[dependencies]
anyhow = "1.0"

clap = { version = "4.5", features = ["derive"]}
ctrlc = "3.5"

# GUI
eframe = "0.33"
egui = "0.33"
egui_plot = "0.34"

# Concurrency
crossbeam-channel = "0.5"

# DSP / Math
rustfft = "6"
rand = "0.9"

# Serde for future config
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
schemars = { version = "1.2", features = ["derive"] }
toml = "0.9"

# Logging / tracing (optional)
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }

# Audio I/O
cpal = "0.17"
hound = "3.5"

ringbuf = "0.4"
rhai = { version = "1.23", features = ["metadata", "serde"] }
wide = { version = "1.1.1", optional = true }

[features]
default = ["bench-hooks", "simd-wide"]
simd-wide = ["dep:wide"]
bench-hooks = []

[dev-dependencies]
criterion = "0.5"
approx = "0.5"
plotters = "0.3"
rhai-autodocs = "0.10"
walkdir = "2.5"

[[bench]]
name = "synth_resonator_bank"
harness = false
</file>

<file path="src/life/articulation_core.rs">
use crate::core::modulation::NeuralRhythms;
use crate::core::phase::{angle_diff_pm_pi, wrap_0_tau};
use crate::core::utils::pink_noise_tick;
use crate::life::lifecycle::LifecycleConfig;
use crate::life::phonation_engine::PhonationKick;
use crate::life::scenario::ArticulationCoreConfig;
use rand::{Rng, SeedableRng, rngs::SmallRng};
use std::f32::consts::{PI, TAU};
use tracing::debug;

#[derive(Debug, Clone, Copy, Default)]
pub struct ArticulationSignal {
    pub amplitude: f32,
    pub is_active: bool,
    pub relaxation: f32,
    pub tension: f32,
}

#[derive(Debug, Clone, Copy, Default)]
pub struct PlannedPitch {
    pub target_pitch_log2: f32,
    pub jump_cents_abs: f32,
    pub salience: f32,
}

#[derive(Debug, Clone, Copy, Default)]
pub struct PlannedGate {
    pub gate: f32,
}

impl PlannedGate {
    pub fn update(&mut self, planned: &PlannedPitch, rhythms: &NeuralRhythms, dt: f32) -> bool {
        let dt = dt.max(0.0);
        let move_threshold = 10.0;
        if planned.jump_cents_abs > move_threshold {
            self.gate = (self.gate - dt * 1.5).max(0.0);
            self.gate < 0.1
        } else {
            let attack_rate = 1.0 + rhythms.theta.beta;
            self.gate = (self.gate + dt * attack_rate).clamp(0.0, 1.0);
            true
        }
    }
}

#[derive(Debug, Clone)]
pub struct ArticulationWrapper {
    pub core: AnyArticulationCore,
    pub planned_gate: PlannedGate,
}

impl ArticulationWrapper {
    pub fn new(core: AnyArticulationCore, gate: f32) -> Self {
        Self {
            core,
            planned_gate: PlannedGate { gate },
        }
    }

    pub fn process(
        &mut self,
        consonance: f32,
        rhythms: &NeuralRhythms,
        dt: f32,
        global_coupling: f32,
    ) -> ArticulationSignal {
        self.core.process(consonance, rhythms, dt, global_coupling)
    }

    pub fn is_alive(&self) -> bool {
        self.core.is_alive()
    }

    pub fn update_gate(
        &mut self,
        planned: &PlannedPitch,
        rhythms: &NeuralRhythms,
        dt: f32,
    ) -> bool {
        self.planned_gate.update(planned, rhythms, dt)
    }

    pub fn gate(&self) -> f32 {
        self.planned_gate.gate
    }

    pub fn set_gate(&mut self, gate: f32) {
        self.planned_gate.gate = gate.clamp(0.0, 1.0);
    }

    pub fn kick_planned(&mut self, kick: PhonationKick, rhythms: &NeuralRhythms, dt: f32) {
        self.core.kick_planned(kick, rhythms, dt);
    }
}

pub trait ArticulationCore {
    fn process(
        &mut self,
        consonance: f32,
        rhythms: &NeuralRhythms,
        dt: f32,
        global_coupling: f32,
    ) -> ArticulationSignal;
    fn is_alive(&self) -> bool;
}

#[derive(Debug, Clone, Copy, Default)]
pub struct Sensitivity {
    pub delta: f32,
    pub theta: f32,
    pub alpha: f32,
    pub beta: f32,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ArticulationState {
    Idle,
    Attack,
    Decay,
}

#[derive(Debug, Clone)]
pub struct PinkNoise {
    rng: SmallRng,
    b0: f32,
    b1: f32,
    b2: f32,
    gain: f32,
}

impl PinkNoise {
    pub fn new(seed: u64, gain: f32) -> Self {
        Self {
            rng: SmallRng::seed_from_u64(seed),
            b0: 0.0,
            b1: 0.0,
            b2: 0.0,
            gain,
        }
    }

    pub fn sample(&mut self) -> f32 {
        let pink = pink_noise_tick(&mut self.rng, &mut self.b0, &mut self.b1, &mut self.b2);
        pink * self.gain
    }
}

#[derive(Debug, Clone)]
pub struct KuramotoCore {
    pub energy: f32,
    pub energy_cap: f32,
    pub vitality_exponent: f32,
    pub vitality_level: f32,
    pub basal_cost: f32,
    pub action_cost: f32,
    pub recharge_rate: f32,
    pub sensitivity: Sensitivity,
    pub rhythm_phase: f32,
    pub rhythm_freq: f32,
    pub omega_rad: f32,
    pub phase_offset: f32,
    pub debug_id: u64,
    pub env_level: f32,
    pub state: ArticulationState,
    pub attack_step: f32,
    pub decay_rate: f32,
    pub retrigger: bool,
    pub noise_1f: PinkNoise,
    pub base_sigma: f32,
    pub beta_gain: f32,
    pub k_omega: f32,
    pub bootstrap_timer: f32,
    pub env_open_threshold: f32,
    pub env_level_min: f32,
    pub mag_threshold: f32,
    pub alpha_threshold: f32,
    pub beta_threshold: f32,
    pub dbg_accum_time: f32,
    pub dbg_wraps: u32,
    pub dbg_attacks: u32,
    pub dbg_boot_attacks: u32,
    pub dbg_attack_logs_left: u32,
    pub dbg_attack_count_normal: u32,
    pub dbg_attack_sum_abs_diff: f32,
    pub dbg_attack_sum_cos: f32,
    pub dbg_attack_sum_sin: f32,
    pub dbg_fail_env: u32,
    pub dbg_fail_env_level: u32,
    pub dbg_fail_mag: u32,
    pub dbg_fail_alpha: u32,
    pub dbg_fail_beta: u32,
    pub dbg_last_env_open: f32,
    pub dbg_last_env_level: f32,
    pub dbg_last_theta_mag: f32,
    pub dbg_last_theta_alpha: f32,
    pub dbg_last_theta_beta: f32,
    pub dbg_last_k_eff: f32,
}

#[derive(Clone, Copy, Debug)]
struct GateStatus {
    env_open_ok: bool,
    env_level_ok: bool,
    mag_ok: bool,
    alpha_ok: bool,
    beta_ok: bool,
    env_level_ok_boot: bool,
    mag_ok_boot: bool,
    alpha_ok_boot: bool,
}

impl GateStatus {
    #[inline]
    fn normal_ok(&self) -> bool {
        self.env_open_ok && self.env_level_ok && self.mag_ok && self.alpha_ok && self.beta_ok
    }

    #[inline]
    fn bootstrap_ok(&self) -> bool {
        self.env_level_ok_boot && (self.mag_ok_boot || self.alpha_ok_boot)
    }
}

#[derive(Clone, Copy, Debug)]
struct PhaseStep {
    k_eff: f32,
}

#[derive(Clone, Copy, Debug)]
struct ThetaView {
    phase: f32,
    freq_hz: f32,
    mag: f32,
    alpha: f32,
    beta: f32,
}

fn normalized_vitality(energy: f32, energy_cap: f32, vitality_exponent: f32) -> f32 {
    if !energy.is_finite() || !energy_cap.is_finite() || energy_cap <= 0.0 {
        return 0.0;
    }
    let energy_clamped = energy.clamp(0.0, energy_cap);
    let mut vitality = (energy_clamped / energy_cap).clamp(0.0, 1.0);
    let exponent = if vitality_exponent.is_finite() && vitality_exponent > 0.0 {
        vitality_exponent
    } else {
        1.0
    };
    vitality = vitality.powf(exponent);
    if vitality.is_finite() { vitality } else { 0.0 }
}

impl KuramotoCore {
    #[inline]
    fn compute_gate_status(&mut self, rhythms: &NeuralRhythms, theta: &ThetaView) -> GateStatus {
        self.dbg_last_env_open = rhythms.env_open;
        self.dbg_last_env_level = rhythms.env_level;
        self.dbg_last_theta_mag = theta.mag;
        self.dbg_last_theta_alpha = theta.alpha;
        self.dbg_last_theta_beta = theta.beta;

        GateStatus {
            env_open_ok: rhythms.env_open > self.env_open_threshold,
            env_level_ok: rhythms.env_level > self.env_level_min,
            mag_ok: theta.mag > self.mag_threshold,
            alpha_ok: theta.alpha > self.alpha_threshold,
            beta_ok: theta.beta < self.beta_threshold,
            env_level_ok_boot: rhythms.env_level > (self.env_level_min * 0.5),
            mag_ok_boot: theta.mag > (self.mag_threshold * 0.5),
            alpha_ok_boot: theta.alpha > (self.alpha_threshold * 0.5),
        }
    }

    #[inline]
    fn record_gate_failures(&mut self, gate: &GateStatus) {
        if !gate.env_open_ok {
            self.dbg_fail_env += 1;
        }
        if !gate.env_level_ok {
            self.dbg_fail_env_level += 1;
        }
        if !gate.mag_ok {
            self.dbg_fail_mag += 1;
        }
        if !gate.alpha_ok {
            self.dbg_fail_alpha += 1;
        }
        if !gate.beta_ok {
            self.dbg_fail_beta += 1;
        }
    }

    #[inline]
    fn update_phase(
        &mut self,
        theta: &ThetaView,
        rhythms: &NeuralRhythms,
        dt: f32,
        global_coupling: f32,
        bootstrap_active: bool,
    ) -> PhaseStep {
        let omega_target = TAU * theta.freq_hz;
        // base_k scales with target omega so coupling stays in rad/s units.
        let base_k = omega_target.max(20.0);
        let env_gate = rhythms.env_open;
        let env_amp = rhythms.env_level.sqrt();
        let k_eff = base_k
            * global_coupling
            * self.sensitivity.theta
            * theta.mag
            * theta.alpha
            * env_gate
            * env_amp;
        self.dbg_last_k_eff = k_eff;

        let mut pull = self.k_omega * theta.alpha * env_gate;
        if pull > 0.0 {
            if bootstrap_active {
                pull *= 4.0;
            }
            let blend = (pull * dt).min(1.0);
            self.omega_rad = self.omega_rad + (omega_target - self.omega_rad) * blend;
        }
        let min_omega = TAU * 3.0;
        let max_omega = TAU * 12.0;
        self.omega_rad = self.omega_rad.clamp(min_omega, max_omega);
        self.rhythm_freq = self.omega_rad / TAU;

        let sigma = self.base_sigma * (1.0 + self.beta_gain * theta.beta);
        let noise = self.noise_1f.sample() * sigma;

        let target = wrap_0_tau(theta.phase + self.phase_offset);
        let diff = angle_diff_pm_pi(target, wrap_0_tau(self.rhythm_phase));
        let d_phi = self.omega_rad + noise + k_eff * diff.sin();
        self.rhythm_phase += d_phi * dt;

        PhaseStep { k_eff }
    }

    #[inline]
    fn maybe_trigger_attack(
        &mut self,
        gate: &GateStatus,
        rhythms: &NeuralRhythms,
        theta: &ThetaView,
        consonance: f32,
        bootstrap_active: bool,
        k_eff: f32,
    ) -> bool {
        self.record_gate_failures(gate);

        let target_phase = wrap_0_tau(theta.phase + self.phase_offset);
        let agent_phase = wrap_0_tau(self.rhythm_phase);
        let phase_err_at_attack = angle_diff_pm_pi(target_phase, agent_phase);

        let mut attack = false;
        let mut boot_attack = false;
        if self.state == ArticulationState::Idle && self.retrigger {
            if bootstrap_active {
                if gate.bootstrap_ok() {
                    attack = true;
                    boot_attack = true;
                }
            } else if gate.normal_ok() {
                attack = true;
            }
        }

        if attack {
            self.env_level = 0.0;
            self.state = ArticulationState::Attack;
            self.energy -= self.action_cost;
            if consonance > 0.5 {
                self.energy += self.recharge_rate * consonance;
            }
            self.dbg_attacks += 1;
            if boot_attack {
                self.dbg_boot_attacks += 1;
            }
            if !boot_attack {
                self.dbg_attack_count_normal += 1;
                self.dbg_attack_sum_abs_diff += phase_err_at_attack.abs();
                self.dbg_attack_sum_cos += phase_err_at_attack.cos();
                self.dbg_attack_sum_sin += phase_err_at_attack.sin();
            }
            if self.dbg_attack_logs_left > 0 {
                debug!(
                    target: "rhythm::attack",
                    id = self.debug_id,
                    mode = if boot_attack { "bootstrap" } else { "normal" },
                    env_open = rhythms.env_open,
                    env_level = rhythms.env_level,
                    env_open_threshold = self.env_open_threshold,
                    env_level_min = self.env_level_min,
                    mag_threshold = self.mag_threshold,
                    alpha_threshold = self.alpha_threshold,
                    beta_threshold = self.beta_threshold,
                    theta_mag = theta.mag,
                    theta_alpha = theta.alpha,
                    theta_beta = theta.beta,
                    k_eff,
                    target_phase,
                    agent_phase,
                    phase_err_at_attack,
                    phase_offset = self.phase_offset
                );
                self.dbg_attack_logs_left -= 1;
            }
        }

        attack
    }

    #[inline]
    fn update_envelope(&mut self, dt: f32) {
        let dt = dt.max(0.0);
        match self.state {
            ArticulationState::Attack => {
                self.env_level += self.attack_step * dt;
                if self.env_level >= 1.0 {
                    self.env_level = 1.0;
                    self.state = ArticulationState::Decay;
                }
            }
            ArticulationState::Decay => {
                let decay = (-self.decay_rate * dt).exp();
                self.env_level *= decay;
                if self.env_level < 0.001 {
                    self.env_level = 0.0;
                    self.state = ArticulationState::Idle;
                }
            }
            ArticulationState::Idle => {}
        }
    }

    #[inline]
    fn handle_energy_depletion(&mut self) {
        if !self.energy.is_finite() {
            self.energy = 0.0;
        }
        if self.energy <= 0.0 {
            self.energy = 0.0;
            self.retrigger = false;
            if self.state != ArticulationState::Idle {
                self.state = ArticulationState::Decay;
            }
        }
    }

    #[inline]
    fn update_vitality(&mut self) -> f32 {
        let computed = normalized_vitality(self.energy, self.energy_cap, self.vitality_exponent);
        if !self.energy.is_finite() {
            self.vitality_level = 0.0;
            return self.vitality_level;
        }
        if self.state == ArticulationState::Idle || self.energy > 0.0 {
            self.vitality_level = computed;
        }
        self.vitality_level
    }
}

impl ArticulationCore for KuramotoCore {
    fn process(
        &mut self,
        consonance: f32,
        rhythms: &NeuralRhythms,
        dt: f32,
        global_coupling: f32,
    ) -> ArticulationSignal {
        self.energy -= self.basal_cost * dt;
        self.handle_energy_depletion();

        let theta = ThetaView {
            phase: rhythms.theta.phase,
            freq_hz: rhythms.theta.freq_hz,
            mag: rhythms.theta.mag,
            alpha: rhythms.theta.alpha,
            beta: rhythms.theta.beta,
        };

        let gate = self.compute_gate_status(rhythms, &theta);
        self.dbg_accum_time += dt;

        self.bootstrap_timer = (self.bootstrap_timer - dt).max(0.0);
        let bootstrap_active = self.bootstrap_timer > 0.0;
        let step = self.update_phase(&theta, rhythms, dt, global_coupling, bootstrap_active);
        let mut attacked_this_sample = false;

        while self.rhythm_phase >= 2.0 * PI {
            self.rhythm_phase -= 2.0 * PI;
            self.dbg_wraps += 1;
            let attacked = self.maybe_trigger_attack(
                &gate,
                rhythms,
                &theta,
                consonance,
                bootstrap_active,
                step.k_eff,
            );
            attacked_this_sample = attacked_this_sample || attacked;
        }
        if attacked_this_sample {
            self.handle_energy_depletion();
        }
        self.update_envelope(dt);

        if self.dbg_accum_time >= 1.0 {
            let agent_freq_hz = self.omega_rad / TAU;
            let freq_err_hz = agent_freq_hz - rhythms.theta.freq_hz;
            let (attack_plv, attack_mean_abs_diff) = if self.dbg_attack_count_normal > 0 {
                let count = self.dbg_attack_count_normal as f32;
                let plv = (self.dbg_attack_sum_cos * self.dbg_attack_sum_cos
                    + self.dbg_attack_sum_sin * self.dbg_attack_sum_sin)
                    .sqrt()
                    / count;
                let mean_abs_diff = self.dbg_attack_sum_abs_diff / count;
                (plv, mean_abs_diff)
            } else {
                (0.0, 0.0)
            };
            debug!(
                target: "rhythm::metrics",
                id = self.debug_id,
                attack_count_normal = self.dbg_attack_count_normal,
                attack_mean_abs_diff = attack_mean_abs_diff,
                attack_plv_target = attack_plv,
                last_env_open = self.dbg_last_env_open,
                last_env_level = self.dbg_last_env_level,
                last_theta_mag = self.dbg_last_theta_mag,
                last_theta_alpha = self.dbg_last_theta_alpha,
                last_theta_beta = self.dbg_last_theta_beta,
                last_k_eff = self.dbg_last_k_eff,
                fail_env_open = self.dbg_fail_env,
                fail_env_level = self.dbg_fail_env_level,
                fail_mag = self.dbg_fail_mag,
                fail_alpha = self.dbg_fail_alpha,
                fail_beta = self.dbg_fail_beta
            );
            debug!(
                target: "rhythm::agent",
                id = self.debug_id,
                agent_freq_hz,
                freq_err_hz,
                wraps = self.dbg_wraps,
                attacks = self.dbg_attacks,
                boot_attacks = self.dbg_boot_attacks,
                fail_env = self.dbg_fail_env,
                fail_mag = self.dbg_fail_mag,
                fail_alpha = self.dbg_fail_alpha,
                fail_beta = self.dbg_fail_beta,
                last_env_open = self.dbg_last_env_open,
                last_env_level = self.dbg_last_env_level,
                last_theta_mag = self.dbg_last_theta_mag,
                last_theta_alpha = self.dbg_last_theta_alpha,
                last_theta_beta = self.dbg_last_theta_beta,
                last_k_eff = self.dbg_last_k_eff,
                omega_rad = self.omega_rad,
                theta_freq_hz = rhythms.theta.freq_hz
            );
            self.dbg_accum_time = 0.0;
            self.dbg_wraps = 0;
            self.dbg_attacks = 0;
            self.dbg_boot_attacks = 0;
            self.dbg_attack_count_normal = 0;
            self.dbg_attack_sum_abs_diff = 0.0;
            self.dbg_attack_sum_cos = 0.0;
            self.dbg_attack_sum_sin = 0.0;
            self.dbg_fail_env = 0;
            self.dbg_fail_env_level = 0;
            self.dbg_fail_mag = 0;
            self.dbg_fail_alpha = 0;
            self.dbg_fail_beta = 0;
        }

        let relaxation = rhythms.theta.alpha * self.sensitivity.alpha;
        let tension = rhythms.theta.beta * self.sensitivity.beta;
        let vitality = self.update_vitality();
        let is_active = self.env_level * vitality > 1e-6 && self.state != ArticulationState::Idle;
        ArticulationSignal {
            amplitude: self.env_level * vitality,
            is_active,
            relaxation,
            tension,
        }
    }

    fn is_alive(&self) -> bool {
        if self.energy <= 0.0 {
            return self.state != ArticulationState::Idle;
        }
        if !self.retrigger && self.state == ArticulationState::Idle {
            return false;
        }
        true
    }
}

#[derive(Debug, Clone)]
pub struct SequencedCore {
    pub timer: f32,
    pub duration: f32,
    pub env_level: f32,
}

impl ArticulationCore for SequencedCore {
    fn process(
        &mut self,
        _consonance: f32,
        rhythms: &NeuralRhythms,
        dt: f32,
        _global_coupling: f32,
    ) -> ArticulationSignal {
        self.timer += dt.max(0.0);
        let active = self.timer < self.duration;
        self.env_level = if active { 1.0 } else { 0.0 };
        ArticulationSignal {
            amplitude: self.env_level,
            is_active: active,
            relaxation: rhythms.theta.alpha,
            tension: 0.0,
        }
    }

    fn is_alive(&self) -> bool {
        self.timer < self.duration
    }
}

#[derive(Debug, Clone)]
pub struct DroneCore {
    pub phase: f32,
    pub sway_rate: f32,
}

impl ArticulationCore for DroneCore {
    fn process(
        &mut self,
        _consonance: f32,
        rhythms: &NeuralRhythms,
        dt: f32,
        _global_coupling: f32,
    ) -> ArticulationSignal {
        let omega = 2.0 * PI * self.sway_rate.max(0.01);
        self.phase = (self.phase + omega * dt).rem_euclid(2.0 * PI);
        let lfo = 0.5 * (self.phase.sin() + 1.0);
        let relax_boost = 1.0 + rhythms.theta.alpha * 0.5;
        let amplitude = (0.3 + 0.7 * lfo) * relax_boost;
        ArticulationSignal {
            amplitude: amplitude.clamp(0.0, 1.0),
            is_active: true,
            relaxation: rhythms.theta.alpha,
            tension: rhythms.theta.beta * 0.25,
        }
    }

    fn is_alive(&self) -> bool {
        true
    }
}

#[derive(Debug, Clone)]
#[allow(clippy::large_enum_variant)]
pub enum AnyArticulationCore {
    Entrain(KuramotoCore),
    Seq(SequencedCore),
    Drone(DroneCore),
}

impl ArticulationCore for AnyArticulationCore {
    fn process(
        &mut self,
        consonance: f32,
        rhythms: &NeuralRhythms,
        dt: f32,
        global_coupling: f32,
    ) -> ArticulationSignal {
        match self {
            AnyArticulationCore::Entrain(c) => c.process(consonance, rhythms, dt, global_coupling),
            AnyArticulationCore::Seq(c) => c.process(consonance, rhythms, dt, global_coupling),
            AnyArticulationCore::Drone(c) => c.process(consonance, rhythms, dt, global_coupling),
        }
    }

    fn is_alive(&self) -> bool {
        match self {
            AnyArticulationCore::Entrain(c) => c.is_alive(),
            AnyArticulationCore::Seq(c) => c.is_alive(),
            AnyArticulationCore::Drone(c) => c.is_alive(),
        }
    }
}

impl AnyArticulationCore {
    pub fn from_config<R: Rng + ?Sized>(
        config: &ArticulationCoreConfig,
        fs: f32,
        noise_seed: u64,
        rng: &mut R,
    ) -> Self {
        match config {
            ArticulationCoreConfig::Entrain {
                lifecycle,
                rhythm_freq,
                rhythm_sensitivity,
                ..
            } => {
                let (
                    energy,
                    basal_cost,
                    recharge_rate,
                    attack_step,
                    decay_rate,
                    state,
                    sensitivity,
                    retrigger,
                    action_cost,
                ) = envelope_from_lifecycle(lifecycle, fs);
                let energy_cap = energy.max(0.0);
                let vitality_exponent = 0.5;
                let vitality_level = normalized_vitality(energy, energy_cap, vitality_exponent);
                let env_level = if matches!(state, ArticulationState::Attack) {
                    attack_step
                } else {
                    0.0
                };
                let init_freq = rhythm_freq.unwrap_or_else(|| rng.random_range(5.0..7.0));
                // Phase/offset seed diversity; theta lock uses base_k ~ omega_target in process.
                AnyArticulationCore::Entrain(KuramotoCore {
                    energy,
                    energy_cap,
                    vitality_exponent,
                    vitality_level,
                    basal_cost,
                    action_cost,
                    recharge_rate,
                    sensitivity: Sensitivity {
                        // rhythm_sensitivity targets theta coupling strength.
                        theta: rhythm_sensitivity.unwrap_or(sensitivity.theta),
                        ..sensitivity
                    },
                    rhythm_phase: rng.random_range(0.0..std::f32::consts::TAU),
                    rhythm_freq: init_freq,
                    omega_rad: TAU * init_freq,
                    phase_offset: rng.random_range(-std::f32::consts::PI..std::f32::consts::PI),
                    debug_id: noise_seed,
                    env_level,
                    state,
                    attack_step,
                    decay_rate,
                    retrigger,
                    noise_1f: PinkNoise::new(noise_seed, 0.001),
                    base_sigma: 0.3, // rad/s noise floor
                    beta_gain: 1.0,  // beta -> noise gain
                    k_omega: 3.0,    // omega pull toward theta
                    bootstrap_timer: 1.5,
                    env_open_threshold: 0.55,
                    env_level_min: 0.02,
                    mag_threshold: 0.04,
                    alpha_threshold: 0.2,
                    beta_threshold: 0.9,
                    dbg_accum_time: 0.0,
                    dbg_wraps: 0,
                    dbg_attacks: 0,
                    dbg_boot_attacks: 0,
                    dbg_attack_logs_left: 5,
                    dbg_attack_count_normal: 0,
                    dbg_attack_sum_abs_diff: 0.0,
                    dbg_attack_sum_cos: 0.0,
                    dbg_attack_sum_sin: 0.0,
                    dbg_fail_env: 0,
                    dbg_fail_env_level: 0,
                    dbg_fail_mag: 0,
                    dbg_fail_alpha: 0,
                    dbg_fail_beta: 0,
                    dbg_last_env_open: 0.0,
                    dbg_last_env_level: 0.0,
                    dbg_last_theta_mag: 0.0,
                    dbg_last_theta_alpha: 0.0,
                    dbg_last_theta_beta: 0.0,
                    dbg_last_k_eff: 0.0,
                })
            }
            ArticulationCoreConfig::Seq { duration, .. } => {
                AnyArticulationCore::Seq(SequencedCore {
                    timer: 0.0,
                    duration: duration.max(0.0),
                    env_level: 0.0,
                })
            }
            ArticulationCoreConfig::Drone { sway, .. } => {
                let sway_rate = sway.unwrap_or(0.05);
                let sway_rate = if sway_rate <= 0.0 { 0.05 } else { sway_rate };
                AnyArticulationCore::Drone(DroneCore {
                    phase: rng.random_range(0.0..std::f32::consts::TAU),
                    sway_rate,
                })
            }
        }
    }

    pub fn kick_planned(&mut self, kick: PhonationKick, _rhythms: &NeuralRhythms, _dt: f32) {
        let strength = kick.strength();
        match self {
            AnyArticulationCore::Entrain(core) => core.kick_planned(strength),
            AnyArticulationCore::Seq(core) => core.kick_planned(strength),
            AnyArticulationCore::Drone(core) => core.kick_planned(strength),
        }
    }
}

impl KuramotoCore {
    fn kick_planned(&mut self, strength: f32) {
        let strength = strength.clamp(0.0, 1.0);
        self.state = ArticulationState::Attack;
        if self.energy.is_finite() && self.energy >= self.action_cost {
            self.energy -= self.action_cost * strength;
        }
    }
}

impl SequencedCore {
    fn kick_planned(&mut self, _strength: f32) {
        self.timer = 0.0;
    }
}

impl DroneCore {
    fn kick_planned(&mut self, _strength: f32) {}
}

fn envelope_from_lifecycle(
    lifecycle: &LifecycleConfig,
    _fs: f32,
) -> (
    f32,
    f32,
    f32,
    f32,
    f32,
    ArticulationState,
    Sensitivity,
    bool,
    f32,
) {
    match lifecycle {
        LifecycleConfig::Decay {
            initial_energy,
            half_life_sec,
            attack_sec,
        } => {
            let atk = attack_sec.max(0.0005);
            let attack_step = 1.0 / atk;
            let decay_sec = half_life_sec.max(0.01);
            let decay_rate = 1.0 / decay_sec;
            let basal = 0.0;
            (
                *initial_energy,
                basal,
                0.0,
                attack_step,
                decay_rate,
                ArticulationState::Attack,
                Sensitivity::default(),
                false,
                0.02,
            )
        }
        LifecycleConfig::Sustain {
            initial_energy,
            metabolism_rate,
            recharge_rate,
            action_cost,
            envelope,
        } => {
            let atk = envelope.attack_sec.max(0.0005);
            let attack_step = 1.0 / atk;
            let decay_sec = envelope.decay_sec.max(0.01);
            let decay_rate = 1.0 / decay_sec;
            (
                *initial_energy,
                *metabolism_rate,
                recharge_rate.unwrap_or(0.5),
                attack_step,
                decay_rate,
                ArticulationState::Idle,
                Sensitivity {
                    delta: 1.0,
                    theta: 1.0,
                    alpha: 0.5,
                    beta: 0.5,
                },
                true,
                action_cost.unwrap_or(0.02),
            )
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::modulation::NeuralRhythms;
    use std::f32::consts::TAU;

    fn test_core(energy: f32) -> KuramotoCore {
        let energy_cap = 1.0;
        let vitality_exponent = 0.5;
        let vitality_level = normalized_vitality(energy, energy_cap, vitality_exponent);
        KuramotoCore {
            energy,
            energy_cap,
            vitality_exponent,
            vitality_level,
            basal_cost: 0.0,
            action_cost: 0.0,
            recharge_rate: 0.0,
            sensitivity: Sensitivity::default(),
            rhythm_phase: 0.0,
            rhythm_freq: 5.0,
            omega_rad: TAU * 5.0,
            phase_offset: 0.0,
            debug_id: 0,
            env_level: 1.0,
            state: ArticulationState::Decay,
            attack_step: 0.1,
            decay_rate: 1.0,
            retrigger: true,
            noise_1f: PinkNoise::new(1, 0.0),
            base_sigma: 0.0,
            beta_gain: 0.0,
            k_omega: 0.0,
            bootstrap_timer: 0.0,
            env_open_threshold: 0.0,
            env_level_min: 0.0,
            mag_threshold: 0.0,
            alpha_threshold: 0.0,
            beta_threshold: 1.0,
            dbg_accum_time: 0.0,
            dbg_wraps: 0,
            dbg_attacks: 0,
            dbg_boot_attacks: 0,
            dbg_attack_logs_left: 0,
            dbg_attack_count_normal: 0,
            dbg_attack_sum_abs_diff: 0.0,
            dbg_attack_sum_cos: 0.0,
            dbg_attack_sum_sin: 0.0,
            dbg_fail_env: 0,
            dbg_fail_env_level: 0,
            dbg_fail_mag: 0,
            dbg_fail_alpha: 0,
            dbg_fail_beta: 0,
            dbg_last_env_open: 0.0,
            dbg_last_env_level: 0.0,
            dbg_last_theta_mag: 0.0,
            dbg_last_theta_alpha: 0.0,
            dbg_last_theta_beta: 0.0,
            dbg_last_k_eff: 0.0,
        }
    }

    #[test]
    fn energy_depletion_enters_decay_without_instant_silence() {
        let mut core = test_core(0.01);
        core.basal_cost = 2.0;
        core.retrigger = true;
        core.env_level = 1.0;
        core.state = ArticulationState::Decay;

        let rhythms = NeuralRhythms::default();
        let signal = core.process(0.0, &rhythms, 0.01, 0.0);

        assert!(core.energy <= 0.0);
        assert_eq!(core.state, ArticulationState::Decay);
        assert!(!core.retrigger);
        assert!(
            signal.amplitude > 0.0,
            "amplitude should release, not drop to zero immediately"
        );
    }

    #[test]
    fn attack_depletion_enters_decay_without_instant_silence() {
        let mut core = test_core(0.01);
        core.basal_cost = 2.0;
        core.retrigger = true;
        core.env_level = 0.4;
        core.state = ArticulationState::Attack;

        let rhythms = NeuralRhythms::default();
        let signal = core.process(0.0, &rhythms, 0.01, 0.0);

        assert!(core.energy <= 0.0);
        assert_eq!(core.state, ArticulationState::Decay);
        assert!(!core.retrigger);
        assert!(
            signal.amplitude > 0.0,
            "attack depletion should release, not drop to zero immediately"
        );
    }

    #[test]
    fn energy_zero_releases_to_idle() {
        let mut core = test_core(0.0);
        core.energy = 0.0;
        core.env_level = 1.0;
        core.state = ArticulationState::Decay;
        core.decay_rate = 5.0;

        let rhythms = NeuralRhythms::default();
        for _ in 0..240 {
            core.process(0.0, &rhythms, 0.01, 0.0);
        }

        assert_eq!(core.state, ArticulationState::Idle);
        assert_eq!(core.env_level, 0.0);
    }

    #[test]
    fn vitality_resets_after_idle() {
        let mut core = test_core(0.0);
        core.energy = 0.0;
        core.env_level = 1.0;
        core.state = ArticulationState::Decay;
        core.decay_rate = 6.0;
        core.vitality_level = 0.5;

        let rhythms = NeuralRhythms::default();
        for _ in 0..300 {
            core.process(0.0, &rhythms, 0.01, 0.0);
        }
        assert_eq!(core.state, ArticulationState::Idle);

        let signal = core.process(0.0, &rhythms, 0.01, 0.0);
        assert!(core.vitality_level <= 1e-6);
        assert!(!signal.is_active);
    }

    #[test]
    fn is_active_tracks_amplitude() {
        let mut core = test_core(0.0);
        core.energy = 0.0;
        core.vitality_level = 0.0;
        core.env_level = 0.5;
        core.state = ArticulationState::Decay;
        core.decay_rate = 0.0;

        let rhythms = NeuralRhythms::default();
        let signal = core.process(0.0, &rhythms, 0.01, 0.0);

        assert!(signal.amplitude <= 1e-6);
        assert!(!signal.is_active);
    }

    #[test]
    fn vitality_scales_amplitude() {
        let rhythms = NeuralRhythms::default();
        let mut high = test_core(1.0);
        high.decay_rate = 0.0;

        let mut low = test_core(0.25);
        low.decay_rate = 0.0;

        let high_signal = high.process(0.0, &rhythms, 0.01, 0.0);
        let low_signal = low.process(0.0, &rhythms, 0.01, 0.0);

        assert!(
            low_signal.amplitude < high_signal.amplitude,
            "lower energy should yield lower amplitude via vitality"
        );
    }
}
</file>

<file path="tests/spawn_birth_once.rs">
use conchordal::core::landscape::Landscape;
use conchordal::core::log2space::Log2Space;
use conchordal::core::timebase::{Tick, Timebase};
use conchordal::life::control::AgentControl;
use conchordal::life::individual::AgentMetadata;
use conchordal::life::population::Population;
use conchordal::life::scenario::IndividualConfig;
use conchordal::life::schedule_renderer::ScheduleRenderer;
use conchordal::life::sound::{AudioCommand, VoiceTarget};
use conchordal::life::world_model::WorldModel;

fn test_timebase() -> Timebase {
    Timebase {
        fs: 48_000.0,
        hop: 64,
    }
}

fn spawn_agent(freq: f32, amp: f32) -> IndividualConfig {
    let mut control = AgentControl::default();
    control.pitch.freq = freq;
    control.body.amp = amp;
    IndividualConfig { control, tag: None }
}

#[test]
fn spawn_does_not_publish_birth_intent() {
    let tb = test_timebase();
    let space = Log2Space::new(55.0, 8000.0, 96);
    let mut world = WorldModel::new(tb, space.clone());
    let mut pop = Population::new(tb);

    let cfg = spawn_agent(440.0, 0.4);
    let meta = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    pop.add_individual(cfg.spawn(1, 0, meta, tb.fs, 0));

    let landscape = Landscape::new(space);
    let now: Tick = 0;
    let batches = pop.publish_intents(&mut world, &landscape, now);
    assert!(batches.is_empty());
    assert!(world.board.is_empty());
}

#[test]
fn spawn_sounds_only_with_audio_trigger() {
    let tb = test_timebase();
    let space = Log2Space::new(55.0, 8000.0, 96);
    let mut world = WorldModel::new(tb, space.clone());
    let mut pop = Population::new(tb);

    let cfg = spawn_agent(440.0, 0.4);
    let meta = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    pop.add_individual(cfg.spawn(1, 0, meta, tb.fs, 0));

    let landscape = Landscape::new(space);
    let now: Tick = 0;
    let _ = pop.publish_intents(&mut world, &landscape, now);
    let mut voice_targets: Vec<VoiceTarget> = Vec::new();
    pop.fill_voice_targets(&mut voice_targets);

    let mut renderer = ScheduleRenderer::new(tb);
    let silent = renderer.render(
        &world.board,
        &[],
        now,
        &landscape.rhythm,
        &voice_targets,
        &[],
    );
    assert!(silent.iter().all(|s| s.abs() <= 1e-6));

    let body = conchordal::life::intent::BodySnapshot {
        kind: "sine".to_string(),
        amp_scale: 1.0,
        brightness: 0.0,
        noise_mix: 0.0,
    };
    let ensure = AudioCommand::EnsureVoice {
        id: 1,
        body,
        pitch_hz: 440.0,
        amp: 0.4,
    };
    let ensured = renderer.render(
        &world.board,
        &[],
        now,
        &landscape.rhythm,
        &voice_targets,
        &[ensure],
    );
    assert!(ensured.iter().all(|s| s.abs() <= 1e-6));

    let impulse = AudioCommand::Impulse { id: 1, energy: 1.0 };
    let voiced = renderer.render(
        &world.board,
        &[],
        now,
        &landscape.rhythm,
        &voice_targets,
        &[impulse],
    );
    assert!(voiced.iter().any(|s| s.abs() > 1e-6));
}
</file>

<file path="samples/03_structures/autumn_cycle.rhai">
print(">>> Cycle of Fifths <<<");

fn play_step(name, root, dur) {
    print(" -> " + name + " @ " + root + "Hz");

    // Use hold so the bass sustains across the step.
    let bass_patch = #{
        body: #{ amp: 0.38, method: "sine" },
        phonation: #{ type: "hold" },
        pitch: #{ mode: "lock", freq: root }
    };
    let bass_tag = "bass_" + name;
    spawn(bass_tag, 1, bass_patch);

    // Let the bass register in the landscape before sampling pads.
    wait(0.20);

    // Pad timbre is fixed; pitch is sampled via harmonicity.
    let pad_patch = #{
        body: #{ amp: 0.14, method: "sine", timbre: #{ brightness: 0.7, width: 0.2 } },
        phonation: #{ type: "hold" },
        pitch: #{ mode: "lock" }
        // Leave pitch.freq unset (sampling decides it).
    };

    // Harmonicity sampling (band-limited around the root).
    let pad_method = #{
        mode: "harmonicity",
        min_freq: root * 2.0,
        max_freq: root * 5.0,
        min_dist_erb: 1.0
    };
    let pad_opts = #{ method: pad_method };

    let pads = [];
    for i in 0..3 {
        let pad_tag = "pad_" + name + "_" + i;

        // Sample pad pitch at spawn time using harmonicity.
        spawn(pad_tag, 1, pad_opts, pad_patch);

        pads.push(pad_tag);
        wait(0.15);
    }

    wait(dur);

    remove(bass_tag);
    for pad in pads { remove(pad); }
}

let chords = [
    #{ name: "Am",   freq: 110.00, dur: 1.6 },
    #{ name: "Dm",   freq: 146.83, dur: 1.6 },
    #{ name: "G7",   freq: 196.00, dur: 1.6 },
    #{ name: "Cmaj", freq: 130.81, dur: 1.6 },
    #{ name: "Fmaj", freq: 174.61, dur: 1.6 },
    #{ name: "Bdim", freq: 246.94, dur: 1.6 },
    #{ name: "E7",   freq: 164.81, dur: 1.6 },
    #{ name: "Am",   freq: 110.00, dur: 1.8 },
];

scene("cycle");

for ch in chords {
    play_step(ch.name, ch.freq, ch.dur);
}

wait(1.0);
end();
</file>

<file path="src/life/scripting.rs">
use std::fs;
use std::sync::{Arc, Mutex};

use crate::core::landscape::LandscapeUpdate;
use rhai::{
    Dynamic, Engine, EvalAltResult, EvalContext, Expression, FLOAT, INT, Map, NativeCallContext,
    Position,
};

use super::api::{
    pop_time, push_time, set_time, spawn_min_at, spawn_with_opts_and_patch_at, spawn_with_third_at,
};
use super::control::{AgentPatch, matches_tag_pattern};
use super::scenario::{Action, Scenario, SceneMarker, SpawnOpts, TimedEvent};

const SCRIPT_PRELUDE: &str = r#"
__internal_debug_seed();

fn parallel(callback) {
    after(0.0, callback);
}

fn after(dt, callback) {
    __internal_push_time();
    wait(dt);
    callback.call();
    __internal_pop_time();
}

fn at(t, callback) {
    __internal_push_time();
    __internal_set_time(t);
    callback.call();
    __internal_pop_time();
}

fn repeat(n, callback) {
    let i = 0;
    while i < n {
        callback.call(i);
        i += 1;
    }
}

fn every(interval, count, callback) {
    let i = 0;
    while i < count {
        __internal_push_time();
        wait(i * interval);
        callback.call(i);
        __internal_pop_time();
        i += 1;
    }
}

fn spawn_every(tag, count, interval, opts) {
    let i = 0;
    while i < count {
        __internal_push_time();
        wait(i * interval);
        spawn(tag, 1, opts);
        __internal_pop_time();
        i += 1;
    }
}

fn spawn_every(tag, count, interval) {
    spawn_every(tag, count, interval, #{});
}
"#;

#[derive(Debug, Clone)]
pub struct ScriptContext {
    pub cursor: f32,
    pub time_stack: Vec<f32>,
    pub scenario: Scenario,
    pub seed: u64,
    pub next_event_order: u64,
    pub ended: bool,
}

impl Default for ScriptContext {
    fn default() -> Self {
        let seed = rand::random::<u64>();
        Self {
            cursor: 0.0,
            time_stack: Vec::new(),
            scenario: Scenario {
                seed,
                scene_markers: Vec::new(),
                events: Vec::new(),
                duration_sec: 0.0,
            },
            seed,
            next_event_order: 1,
            ended: false,
        }
    }
}

impl ScriptContext {
    fn ensure_not_ended(&self, position: Position) -> Result<(), Box<EvalAltResult>> {
        if self.ended {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "script already ended".into(),
                position,
            )));
        }
        Ok(())
    }

    pub fn scene(&mut self, name: &str, position: Position) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        let order = self.next_event_order;
        self.next_event_order += 1;
        self.scenario.scene_markers.push(SceneMarker {
            name: name.to_string(),
            time: self.cursor,
            order,
        });
        Ok(())
    }

    pub fn wait(&mut self, sec: f32, position: Position) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        self.cursor += sec.max(0.0);
        Ok(())
    }

    pub fn set_time(
        &mut self,
        time_sec: f32,
        position: Position,
    ) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        self.cursor = time_sec.max(0.0);
        Ok(())
    }

    pub fn set_seed(&mut self, seed: i64, position: Position) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        if seed < 0 {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "seed must be >= 0".into(),
                position,
            )));
        }
        let seed = seed as u64;
        self.seed = seed;
        self.scenario.seed = seed;
        println!("[rhai][debug] seed={seed}");
        Ok(())
    }

    pub fn push_time(&mut self, position: Position) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        self.time_stack.push(self.cursor);
        Ok(())
    }

    pub fn pop_time(&mut self, position: Position) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        if let Some(t) = self.time_stack.pop() {
            self.cursor = t;
        }
        Ok(())
    }

    fn push_event(&mut self, time_sec: f32, actions: Vec<Action>) {
        let order = self.next_event_order;
        self.next_event_order += 1;
        self.scenario.events.push(TimedEvent {
            time: time_sec,
            order,
            actions,
        });
    }

    pub fn spawn_with_opts_and_patch(
        &mut self,
        tag: &str,
        count: i64,
        opts: Option<Map>,
        patch: Option<Map>,
        position: Position,
    ) -> Result<i64, Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        let c = count.max(0).min(u32::MAX as i64) as u32;

        let opts_struct = if let Some(opts) = opts {
            let debug_map = format!("{:?}", opts);
            Some(Self::parse_spawn_opts(opts, &debug_map, position)?)
        } else {
            None
        };

        let (_patch_struct, patch_json) = if let Some(patch) = patch {
            Self::parse_agent_patch(patch, position)?
        } else {
            (
                AgentPatch::default(),
                serde_json::Value::Object(serde_json::Map::new()),
            )
        };

        let action = Action::Spawn {
            tag: tag.to_string(),
            count: c,
            opts: opts_struct,
            patch: patch_json,
        };
        self.push_event(self.cursor, vec![action]);
        Ok(c as i64)
    }

    pub fn spawn_with_third_map(
        &mut self,
        tag: &str,
        count: i64,
        third: Map,
        position: Position,
    ) -> Result<i64, Box<EvalAltResult>> {
        let debug_map = format!("{:?}", third);
        if Self::parse_spawn_opts(third.clone(), &debug_map, position).is_ok() {
            return self.spawn_with_opts_and_patch(tag, count, Some(third), None, position);
        }
        match Self::parse_agent_patch(third.clone(), position) {
            Ok(_) => self.spawn_with_opts_and_patch(tag, count, None, Some(third), position),
            Err(err) => Err(err),
        }
    }

    pub fn spawn_default(
        &mut self,
        tag: &str,
        count: i64,
        position: Position,
    ) -> Result<i64, Box<EvalAltResult>> {
        self.spawn_with_opts_and_patch(tag, count, None, None, position)
    }

    pub fn intent(
        &mut self,
        freq_hz: f32,
        dt: f32,
        duration_sec: f32,
        amp: f32,
        opts: Option<Map>,
        position: Position,
    ) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;

        let mut source_id: u64 = 0;
        let mut tag: Option<String> = None;
        let mut confidence: f32 = 1.0;

        if let Some(opts) = opts {
            let mut unknown_keys = Vec::new();
            for key in opts.keys() {
                match key.as_str() {
                    "source_id" | "tag" | "confidence" => {}
                    _ => unknown_keys.push(key.to_string()),
                }
            }
            if !unknown_keys.is_empty() {
                unknown_keys.sort();
                let msg = format!(
                    "intent opts has unknown keys: [{}] (allowed: source_id, tag, confidence)",
                    unknown_keys.join(", ")
                );
                return Err(Box::new(EvalAltResult::ErrorRuntime(msg.into(), position)));
            }

            if let Some(value) = opts.get("source_id") {
                let id = value
                    .as_int()
                    .ok()
                    .or_else(|| value.as_float().ok().map(|v| v as i64))
                    .ok_or_else(|| {
                        Box::new(EvalAltResult::ErrorRuntime(
                            "intent opts source_id must be an integer".into(),
                            position,
                        ))
                    })?;
                if id < 0 {
                    return Err(Box::new(EvalAltResult::ErrorRuntime(
                        "intent opts source_id must be non-negative".into(),
                        position,
                    )));
                }
                source_id = id as u64;
            }

            if let Some(value) = opts.get("tag") {
                let tag_value = value.clone().try_cast::<String>().ok_or_else(|| {
                    Box::new(EvalAltResult::ErrorRuntime(
                        "intent opts tag must be a string".into(),
                        position,
                    ))
                })?;
                tag = Some(tag_value);
            }

            if let Some(value) = opts.get("confidence") {
                confidence = value
                    .as_float()
                    .ok()
                    .map(|v| v as f32)
                    .or_else(|| value.as_int().ok().map(|v| v as f32))
                    .ok_or_else(|| {
                        Box::new(EvalAltResult::ErrorRuntime(
                            "intent opts confidence must be a number".into(),
                            position,
                        ))
                    })?;
            }
        }

        let onset_sec = (self.cursor + dt).max(0.0);
        let duration_sec = duration_sec.max(0.0);
        let action = Action::PostIntent {
            source_id,
            onset_sec,
            duration_sec,
            freq_hz,
            amp,
            tag,
            confidence,
        };
        self.push_event(self.cursor, vec![action]);
        Ok(())
    }

    pub fn set_patch(
        &mut self,
        target: &str,
        patch: Map,
        position: Position,
    ) -> Result<i64, Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        let (patch_struct, patch_json) = Self::parse_agent_patch(patch, position)?;
        if patch_struct.contains_type_switch() {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "set() cannot change body.method or phonation.type; use spawn() for type selection"
                    .into(),
                position,
            )));
        }
        let action = Action::Set {
            target: target.to_string(),
            patch: patch_json,
        };
        self.push_event(self.cursor, vec![action]);
        Ok(self.estimate_match_count(target))
    }

    pub fn set_harmonicity(
        &mut self,
        opts: Map,
        position: Position,
    ) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;

        let mut unknown_keys = Vec::new();
        for key in opts.keys() {
            match key.as_str() {
                "mirror" | "limit" => {}
                _ => unknown_keys.push(key.to_string()),
            }
        }
        if !unknown_keys.is_empty() {
            unknown_keys.sort();
            let msg = format!(
                "set_harmonicity opts has unknown keys: [{}] (allowed: mirror, limit)",
                unknown_keys.join(", ")
            );
            return Err(Box::new(EvalAltResult::ErrorRuntime(msg.into(), position)));
        }

        let mut update = LandscapeUpdate::default();
        if let Some(value) = opts.get("mirror") {
            let mirror = value
                .as_float()
                .ok()
                .map(|v| v as f32)
                .or_else(|| value.as_int().ok().map(|v| v as f32))
                .ok_or_else(|| {
                    Box::new(EvalAltResult::ErrorRuntime(
                        "set_harmonicity mirror must be a number".into(),
                        position,
                    ))
                })?;
            update.mirror = Some(mirror);
        }
        if let Some(value) = opts.get("limit") {
            let limit = value
                .as_int()
                .ok()
                .or_else(|| value.as_float().ok().map(|v| v as i64))
                .ok_or_else(|| {
                    Box::new(EvalAltResult::ErrorRuntime(
                        "set_harmonicity limit must be an integer".into(),
                        position,
                    ))
                })?;
            if limit < 0 {
                return Err(Box::new(EvalAltResult::ErrorRuntime(
                    "set_harmonicity limit must be non-negative".into(),
                    position,
                )));
            }
            update.limit = Some(limit as u32);
        }
        if update.mirror.is_none() && update.limit.is_none() {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "set_harmonicity opts requires mirror or limit".into(),
                position,
            )));
        }

        self.push_event(self.cursor, vec![Action::SetHarmonicity { update }]);
        Ok(())
    }

    pub fn set_global_coupling(
        &mut self,
        value: f32,
        position: Position,
    ) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        if value < 0.0 {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "set_global_coupling must be non-negative".into(),
                position,
            )));
        }
        self.push_event(self.cursor, vec![Action::SetGlobalCoupling { value }]);
        Ok(())
    }

    pub fn set_roughness_tolerance(
        &mut self,
        value: f32,
        position: Position,
    ) -> Result<(), Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        if value < 0.0 {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "set_roughness_tolerance must be non-negative".into(),
                position,
            )));
        }
        self.push_event(self.cursor, vec![Action::SetRoughnessTolerance { value }]);
        Ok(())
    }

    pub fn remove(&mut self, target: &str, position: Position) -> Result<i64, Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        self.push_event(
            self.cursor,
            vec![Action::Remove {
                target: target.to_string(),
            }],
        );
        Ok(self.estimate_match_count(target))
    }

    pub fn release(
        &mut self,
        target: &str,
        fade_sec: f32,
        position: Position,
    ) -> Result<i64, Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        if fade_sec < 0.0 {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "release fade_sec must be non-negative".into(),
                position,
            )));
        }
        self.push_event(
            self.cursor,
            vec![Action::Release {
                target: target.to_string(),
                fade_sec,
            }],
        );
        Ok(self.estimate_match_count(target))
    }

    pub fn unset(
        &mut self,
        target: &str,
        path: &str,
        position: Position,
    ) -> Result<i64, Box<EvalAltResult>> {
        self.ensure_not_ended(position)?;
        self.push_event(
            self.cursor,
            vec![Action::Unset {
                target: target.to_string(),
                path: path.to_string(),
            }],
        );
        Ok(self.estimate_match_count(target))
    }

    pub fn end(&mut self, position: Position) -> Result<(), Box<EvalAltResult>> {
        self.end_at(self.cursor, position)
    }

    pub fn end_at(&mut self, t_abs: f32, position: Position) -> Result<(), Box<EvalAltResult>> {
        if t_abs < 0.0 {
            return Err(Box::new(EvalAltResult::ErrorRuntime(
                "end_at time must be non-negative".into(),
                position,
            )));
        }
        self.ensure_not_ended(position)?;
        let end = t_abs.max(0.0);
        self.scenario.duration_sec = self.scenario.duration_sec.max(end);
        self.push_event(end, vec![Action::Finish]);
        self.ended = true;
        Ok(())
    }

    fn parse_agent_patch(
        patch: Map,
        position: Position,
    ) -> Result<(AgentPatch, serde_json::Value), Box<EvalAltResult>> {
        let raw_val = serde_json::to_value(&patch).map_err(|e| {
            Box::new(EvalAltResult::ErrorRuntime(
                format!("Error serializing AgentPatch: {e}").into(),
                position,
            ))
        })?;
        let patch_struct: AgentPatch = serde_json::from_value(raw_val).map_err(|e| {
            let debug_map = format!("{:?}", patch);
            Box::new(EvalAltResult::ErrorRuntime(
                format!("Error parsing AgentPatch: {e} (input: {debug_map})").into(),
                position,
            ))
        })?;
        let patch_json = serde_json::to_value(&patch_struct).map_err(|e| {
            Box::new(EvalAltResult::ErrorRuntime(
                format!("Error serializing AgentPatch: {e}").into(),
                position,
            ))
        })?;
        Ok((patch_struct, patch_json))
    }

    fn parse_spawn_opts(
        opts: Map,
        debug_map: &str,
        position: Position,
    ) -> Result<SpawnOpts, Box<EvalAltResult>> {
        let raw_val = serde_json::to_value(&opts).map_err(|e| {
            Box::new(EvalAltResult::ErrorRuntime(
                format!("Error serializing SpawnOpts: {e}").into(),
                position,
            ))
        })?;
        let opts_struct: SpawnOpts = serde_json::from_value(raw_val).map_err(|e| {
            Box::new(EvalAltResult::ErrorRuntime(
                format!("Error parsing SpawnOpts: {e} (input: {debug_map})").into(),
                position,
            ))
        })?;
        Ok(opts_struct)
    }

    fn estimate_match_count(&self, target: &str) -> i64 {
        let mut events: Vec<&TimedEvent> = self
            .scenario
            .events
            .iter()
            .filter(|ev| ev.time <= self.cursor + f32::EPSILON)
            .collect();
        events.sort_by(|a, b| {
            a.time
                .partial_cmp(&b.time)
                .unwrap_or(std::cmp::Ordering::Equal)
                .then_with(|| a.order.cmp(&b.order))
        });
        let mut tags: Vec<String> = Vec::new();
        for ev in events {
            for action in &ev.actions {
                match action {
                    Action::Spawn { tag, count, .. } => {
                        for _ in 0..*count {
                            tags.push(tag.clone());
                        }
                    }
                    Action::Remove { target } => {
                        tags.retain(|t| !matches_tag_pattern(target, t));
                    }
                    _ => {}
                }
            }
        }
        tags.into_iter()
            .filter(|t| matches_tag_pattern(target, t))
            .count()
            .try_into()
            .unwrap_or(0)
    }
}

pub struct ScriptHost;

impl ScriptHost {
    fn last_non_empty_line(full: &str) -> u16 {
        let mut last_non_empty = None;
        let mut count = 0usize;
        for (idx, line) in full.lines().enumerate() {
            count = idx + 1;
            if !line.trim().is_empty() {
                last_non_empty = Some(idx + 1);
            }
        }
        let line = last_non_empty.unwrap_or(count.max(1));
        line as u16
    }

    fn combined_script(src: &str) -> String {
        format!("{SCRIPT_PRELUDE}\n\n{src}")
    }

    fn create_engine(ctx: Arc<Mutex<ScriptContext>>) -> Engine {
        let mut engine = Engine::new();
        engine.on_print(|msg| println!("[rhai] {msg}"));
        engine.register_fn("__internal_debug", |msg: &str| {
            println!("[rhai][debug] {msg}");
        });
        let ctx_for_seed = ctx.clone();
        engine.register_fn("__internal_debug_seed", move || {
            let ctx = ctx_for_seed.lock().expect("lock script context");
            println!("[rhai][debug] seed={}", ctx.seed);
        });
        engine.register_custom_syntax_with_state_raw(
            "debug",
            |symbols, _look_ahead, _state| {
                let next = match symbols.len() {
                    0 => Some("debug"),
                    1 => Some("("),
                    2 => Some("$expr$"),
                    3 => Some(")"),
                    _ => None,
                };
                Ok(next.map(Into::into))
            },
            false,
            move |eval_ctx: &mut EvalContext, exprs: &[Expression], _state| {
                let pos = exprs[0].position();
                let msg_dyn = eval_ctx.eval_expression_tree(&exprs[0])?;
                let msg = msg_dyn.try_cast::<String>().ok_or_else(|| {
                    Box::new(EvalAltResult::ErrorRuntime(
                        "debug msg must be a string".into(),
                        pos,
                    ))
                })?;
                println!("[rhai][debug] {msg}");
                Ok(Dynamic::UNIT)
            },
        );

        let ctx_for_spawn_syntax = ctx.clone();
        engine.register_custom_syntax_with_state_raw(
            "spawn",
            |symbols, look_ahead, _state| {
                let next = match symbols.len() {
                    0 => Some("spawn"),
                    1 => Some("("),
                    2 => Some("$expr$"),
                    3 => Some(","),
                    4 => Some("$expr$"),
                    5 => match look_ahead {
                        "," => Some(","),
                        ")" => Some(")"),
                        _ => {
                            return Err(rhai::LexError::ImproperSymbol(
                                look_ahead.to_string(),
                                "Expected ',' or ')' for spawn".to_string(),
                            )
                            .into_err(Position::NONE));
                        }
                    },
                    6 => {
                        let last = symbols.last().map(|s| s.as_str()).unwrap_or("");
                        if last == ")" { None } else { Some("$expr$") }
                    }
                    7 => match look_ahead {
                        "," => Some(","),
                        ")" => Some(")"),
                        _ => {
                            return Err(rhai::LexError::ImproperSymbol(
                                look_ahead.to_string(),
                                "Expected ',' or ')' for spawn".to_string(),
                            )
                            .into_err(Position::NONE));
                        }
                    },
                    8 => {
                        let last = symbols.last().map(|s| s.as_str()).unwrap_or("");
                        if last == ")" { None } else { Some("$expr$") }
                    }
                    9 => Some(")"),
                    _ => None,
                };
                Ok(next.map(Into::into))
            },
            false,
            move |eval_ctx: &mut EvalContext, exprs: &[Expression], _state| {
                let pos_tag = exprs[0].position();
                let pos_count = exprs[1].position();
                let pos_third = exprs.get(2).map(|e| e.position()).unwrap_or(pos_tag);
                let pos_fourth = exprs.get(3).map(|e| e.position()).unwrap_or(pos_tag);
                let tag_dyn = eval_ctx.eval_expression_tree(&exprs[0])?;
                let count_dyn = eval_ctx.eval_expression_tree(&exprs[1])?;
                let tag = tag_dyn.try_cast::<String>().ok_or_else(|| {
                    Box::new(EvalAltResult::ErrorRuntime(
                        "spawn tag must be a string".into(),
                        pos_tag,
                    ))
                })?;
                let count = count_dyn.try_cast::<i64>().ok_or_else(|| {
                    Box::new(EvalAltResult::ErrorRuntime(
                        "spawn count must be an integer".into(),
                        pos_count,
                    ))
                })?;
                if count < 0 {
                    return Err(Box::new(EvalAltResult::ErrorRuntime(
                        "spawn count must be non-negative".into(),
                        pos_count,
                    )));
                }
                let mut ctx = ctx_for_spawn_syntax.lock().expect("lock script context");
                let spawned = if exprs.len() >= 4 {
                    let opts_dyn = eval_ctx.eval_expression_tree(&exprs[2])?;
                    let opts = opts_dyn.try_cast::<Map>().ok_or_else(|| {
                        Box::new(EvalAltResult::ErrorRuntime(
                            "spawn opts must be a map".into(),
                            pos_third,
                        ))
                    })?;
                    let patch_dyn = eval_ctx.eval_expression_tree(&exprs[3])?;
                    let patch = patch_dyn.try_cast::<Map>().ok_or_else(|| {
                        Box::new(EvalAltResult::ErrorRuntime(
                            "spawn patch must be a map".into(),
                            pos_fourth,
                        ))
                    })?;
                    spawn_with_opts_and_patch_at(&mut ctx, &tag, count, opts, patch, pos_third)?
                } else if exprs.len() >= 3 {
                    let third_dyn = eval_ctx.eval_expression_tree(&exprs[2])?;
                    let third = third_dyn.try_cast::<Map>().ok_or_else(|| {
                        Box::new(EvalAltResult::ErrorRuntime(
                            "spawn map must be a map".into(),
                            pos_third,
                        ))
                    })?;
                    spawn_with_third_at(&mut ctx, &tag, count, third, pos_third)?
                } else {
                    spawn_min_at(&mut ctx, &tag, count, pos_tag)?
                };
                Ok(Dynamic::from(spawned))
            },
        );

        let ctx_for_intent = ctx.clone();
        engine.register_fn(
            "intent",
            move |call_ctx: NativeCallContext,
                  freq_hz: FLOAT,
                  dt: FLOAT,
                  dur: FLOAT,
                  amp: FLOAT|
                  -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_intent.lock().expect("lock script context");
                ctx.intent(
                    freq_hz as f32,
                    dt as f32,
                    dur as f32,
                    amp as f32,
                    None,
                    call_ctx.call_position(),
                )
            },
        );
        let ctx_for_intent_opts = ctx.clone();
        engine.register_fn(
            "intent",
            move |call_ctx: NativeCallContext,
                  freq_hz: FLOAT,
                  dt: FLOAT,
                  dur: FLOAT,
                  amp: FLOAT,
                  opts: Map|
                  -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_intent_opts.lock().expect("lock script context");
                ctx.intent(
                    freq_hz as f32,
                    dt as f32,
                    dur as f32,
                    amp as f32,
                    Some(opts),
                    call_ctx.call_position(),
                )
            },
        );

        let ctx_for_scene = ctx.clone();
        engine.register_fn(
            "scene",
            move |call_ctx: NativeCallContext, name: &str| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_scene.lock().expect("lock script context");
                ctx.scene(name, call_ctx.call_position())
            },
        );

        let ctx_for_wait = ctx.clone();
        engine.register_fn(
            "wait",
            move |call_ctx: NativeCallContext, sec: FLOAT| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_wait.lock().expect("lock script context");
                ctx.wait(sec as f32, call_ctx.call_position())
            },
        );
        let ctx_for_wait_int = ctx.clone();
        engine.register_fn(
            "wait",
            move |call_ctx: NativeCallContext, sec: i64| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_wait_int.lock().expect("lock script context");
                ctx.wait(sec as f32, call_ctx.call_position())
            },
        );

        let ctx_for_push_time = ctx.clone();
        engine.register_fn(
            "__internal_push_time",
            move |call_ctx: NativeCallContext| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_push_time.lock().expect("lock script context");
                push_time(&mut ctx, call_ctx.call_position())
            },
        );

        let ctx_for_pop_time = ctx.clone();
        engine.register_fn(
            "__internal_pop_time",
            move |call_ctx: NativeCallContext| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_pop_time.lock().expect("lock script context");
                pop_time(&mut ctx, call_ctx.call_position())
            },
        );
        let ctx_for_set_time = ctx.clone();
        engine.register_fn(
            "__internal_set_time",
            move |call_ctx: NativeCallContext, sec: FLOAT| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_set_time.lock().expect("lock script context");
                set_time(&mut ctx, sec, call_ctx.call_position())
            },
        );

        let ctx_for_set_tag_str = ctx.clone();
        engine.register_fn(
            "set",
            move |call_ctx: NativeCallContext, tag: &str, patch: Map| {
                let mut ctx = ctx_for_set_tag_str.lock().expect("lock script context");
                ctx.set_patch(tag, patch, call_ctx.call_position())
            },
        );
        let ctx_for_set_harmonicity = ctx.clone();
        engine.register_fn(
            "set_harmonicity",
            move |call_ctx: NativeCallContext, opts: Map| {
                let mut ctx = ctx_for_set_harmonicity.lock().expect("lock script context");
                ctx.set_harmonicity(opts, call_ctx.call_position())
            },
        );
        let ctx_for_set_global_coupling = ctx.clone();
        engine.register_fn(
            "set_global_coupling",
            move |call_ctx: NativeCallContext, value: FLOAT| {
                let mut ctx = ctx_for_set_global_coupling
                    .lock()
                    .expect("lock script context");
                ctx.set_global_coupling(value as f32, call_ctx.call_position())
            },
        );
        let ctx_for_set_roughness_tolerance = ctx.clone();
        engine.register_fn(
            "set_roughness_tolerance",
            move |call_ctx: NativeCallContext, value: FLOAT| {
                let mut ctx = ctx_for_set_roughness_tolerance
                    .lock()
                    .expect("lock script context");
                ctx.set_roughness_tolerance(value as f32, call_ctx.call_position())
            },
        );
        let ctx_for_unset = ctx.clone();
        engine.register_fn(
            "unset",
            move |call_ctx: NativeCallContext, tag: &str, path: &str| {
                let mut ctx = ctx_for_unset.lock().expect("lock script context");
                ctx.unset(tag, path, call_ctx.call_position())
            },
        );

        let ctx_for_set_seed = ctx.clone();
        engine.register_fn(
            "set_seed",
            move |call_ctx: NativeCallContext, seed: INT| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_set_seed.lock().expect("lock script context");
                ctx.set_seed(seed, call_ctx.call_position())
            },
        );

        let ctx_for_remove_tag_str = ctx.clone();
        engine.register_fn("remove", move |call_ctx: NativeCallContext, tag: &str| {
            let mut ctx = ctx_for_remove_tag_str.lock().expect("lock script context");
            ctx.remove(tag, call_ctx.call_position())
        });
        let ctx_for_release_tag_str = ctx.clone();
        engine.register_fn(
            "release",
            move |call_ctx: NativeCallContext, tag: &str, sec: FLOAT| {
                let mut ctx = ctx_for_release_tag_str.lock().expect("lock script context");
                ctx.release(tag, sec as f32, call_ctx.call_position())
            },
        );
        let ctx_for_release_tag_int = ctx.clone();
        engine.register_fn(
            "release",
            move |call_ctx: NativeCallContext, tag: &str, sec: i64| {
                let mut ctx = ctx_for_release_tag_int.lock().expect("lock script context");
                ctx.release(tag, sec as f32, call_ctx.call_position())
            },
        );

        let ctx_for_end = ctx.clone();
        engine.register_fn(
            "end",
            move |call_ctx: NativeCallContext| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_end.lock().expect("lock script context");
                ctx.end(call_ctx.call_position())
            },
        );
        let ctx_for_end_at = ctx.clone();
        engine.register_fn(
            "end_at",
            move |call_ctx: NativeCallContext, sec: FLOAT| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_end_at.lock().expect("lock script context");
                ctx.end_at(sec as f32, call_ctx.call_position())
            },
        );
        let ctx_for_end_at_int = ctx.clone();
        engine.register_fn(
            "end_at",
            move |call_ctx: NativeCallContext, sec: i64| -> Result<(), Box<EvalAltResult>> {
                let mut ctx = ctx_for_end_at_int.lock().expect("lock script context");
                ctx.end_at(sec as f32, call_ctx.call_position())
            },
        );

        engine
    }

    pub fn load_script(path: &str) -> Result<Scenario, ScriptError> {
        let src = fs::read_to_string(path)
            .map_err(|err| ScriptError::new(format!("read script {path}: {err}"), None))?;
        let ctx = Arc::new(Mutex::new(ScriptContext::default()));
        let engine = ScriptHost::create_engine(ctx.clone());
        let script_src = ScriptHost::combined_script(&src);

        if let Err(e) = engine.eval::<()>(&script_src) {
            // Print structured error to help diagnose script issues (e.g., type mismatches).
            println!("Debug script error: {:?}", e);
            return Err(ScriptError::from_eval(
                e,
                Some(&format!("execute script {path}")),
            ));
        }

        let ctx_out = ctx.lock().expect("lock script context");
        if !ctx_out.ended {
            let line = ScriptHost::last_non_empty_line(&script_src);
            let pos = Position::new(line, 1);
            let msg = "script must call end() or end_at(t) to specify duration";
            return Err(
                ScriptError::new(msg, Some(pos)).with_context(format!("execute script {path}"))
            );
        }
        Ok(ctx_out.scenario.clone())
    }
}

#[derive(Debug, Clone)]
pub struct ScriptError {
    pub message: String,
    pub position: Option<Position>,
}

impl ScriptError {
    pub fn new(message: impl Into<String>, position: Option<Position>) -> Self {
        Self {
            message: message.into(),
            position,
        }
    }

    pub fn with_context(mut self, context: impl AsRef<str>) -> Self {
        let ctx = context.as_ref();
        self.message = format!("{ctx}: {}", self.message);
        self
    }

    pub fn from_eval(err: Box<EvalAltResult>, context: Option<&str>) -> Self {
        let pos = err.position();
        let position = if pos == Position::NONE {
            None
        } else {
            Some(pos)
        };
        let mut err = ScriptError::new(err.to_string(), position);
        if let Some(ctx) = context {
            err = err.with_context(ctx);
        }
        err
    }
}

impl std::fmt::Display for ScriptError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(pos) = self.position {
            let line = pos.line().unwrap_or(0);
            write!(f, "{} (line {line})", self.message)
        } else {
            write!(f, "{}", self.message)
        }
    }
}

impl std::error::Error for ScriptError {}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::landscape::LandscapeFrame;
    use crate::core::log2space::Log2Space;
    use crate::core::timebase::Timebase;
    use crate::life::control::PhonationType;
    use crate::life::population::Population;
    use rhai::Position;

    fn run_script(src: &str) -> Scenario {
        let ctx = Arc::new(Mutex::new(ScriptContext::default()));
        let engine = ScriptHost::create_engine(ctx.clone());
        let script_src = ScriptHost::combined_script(src);
        engine.eval::<()>(&script_src).expect("script runs");
        ctx.lock().expect("lock ctx").scenario.clone()
    }

    fn test_timebase() -> Timebase {
        Timebase {
            fs: 48_000.0,
            hop: 64,
        }
    }

    fn spawn_action_from_script(src: &str) -> Action {
        let scenario = run_script(src);
        scenario
            .events
            .iter()
            .flat_map(|ev| ev.actions.iter())
            .find_map(|action| match action {
                Action::Spawn { .. } => Some(action.clone()),
                _ => None,
            })
            .expect("spawn action exists")
    }

    fn apply_spawn_action(action: Action, landscape: &LandscapeFrame) -> Population {
        let mut pop = Population::new(test_timebase());
        pop.apply_action(action, landscape, None);
        pop
    }

    fn eval_script_error_position(src: &str) -> Position {
        let ctx = Arc::new(Mutex::new(ScriptContext::default()));
        let engine = ScriptHost::create_engine(ctx.clone());
        let script_src = ScriptHost::combined_script(src);
        match engine.eval::<()>(&script_src) {
            Ok(_) => {
                if !ctx.lock().expect("lock ctx").ended {
                    let line = ScriptHost::last_non_empty_line(&script_src);
                    Position::new(line, 1)
                } else {
                    panic!("script should error");
                }
            }
            Err(err) => err.position(),
        }
    }

    fn eval_script_error(src: &str) -> Box<EvalAltResult> {
        let ctx = Arc::new(Mutex::new(ScriptContext::default()));
        let engine = ScriptHost::create_engine(ctx.clone());
        let script_src = ScriptHost::combined_script(src);
        match engine.eval::<Dynamic>(&script_src) {
            Ok(_) => {
                if !ctx.lock().expect("lock ctx").ended {
                    let line = ScriptHost::last_non_empty_line(&script_src);
                    Box::new(EvalAltResult::ErrorRuntime(
                        "script must call end() or end_at(t) to specify duration".into(),
                        Position::new(line, 1),
                    ))
                } else {
                    panic!("script should error");
                }
            }
            Err(err) => err,
        }
    }

    fn expected_line(full: &str, needle: &str) -> usize {
        full.lines()
            .enumerate()
            .find_map(|(idx, line)| {
                if line.contains(needle) {
                    Some(idx + 1)
                } else {
                    None
                }
            })
            .unwrap_or_else(|| panic!("expected marker not found: {}", needle))
    }

    fn assert_time_close(actual: f32, expected: f32) {
        let diff = (actual - expected).abs();
        assert!(
            diff < 1e-5,
            "time mismatch: expected {expected}, got {actual}"
        );
    }

    #[test]
    fn scene_sets_start_and_relative_times() {
        let scenario = run_script(
            r#"
            scene("intro");
            spawn("lead", 1, #{ body: #{ amp: 0.2 }, pitch: #{ freq: 440.0 } });
            wait(1.0);
            scene("break");
            spawn("hit", 1, #{ body: #{ amp: 0.1 }, pitch: #{ freq: 880.0 } });
            wait(0.5);
            end();
        "#,
        );

        assert_eq!(scenario.scene_markers.len(), 2);
        assert_eq!(scenario.scene_markers[0].name, "intro");
        assert_time_close(scenario.scene_markers[0].time, 0.0);
        assert_eq!(scenario.scene_markers[1].name, "break");
        assert_time_close(scenario.scene_markers[1].time, 1.0);

        let mut has_hit = false;
        let mut has_finish = false;
        for ev in &scenario.events {
            for action in &ev.actions {
                match action {
                    Action::Spawn { tag, .. } => {
                        if tag == "hit" {
                            assert_time_close(ev.time, 1.0);
                            has_hit = true;
                        }
                    }
                    Action::Finish => {
                        assert_time_close(ev.time, 1.5);
                        has_finish = true;
                    }
                    _ => {}
                }
            }
        }
        assert!(has_hit, "expected spawn event for hit");
        assert!(has_finish, "expected finish event");
    }

    #[test]
    fn parallel_restores_time_after_block() {
        let scenario = run_script(
            r#"
            scene("intro");
            wait(0.1);
            parallel(|| {
                wait(0.5);
                spawn("pad", 1, #{ body: #{ amp: 0.1 }, pitch: #{ freq: 200.0 } });
            });
            wait(0.2);
            spawn("after", 1, #{ body: #{ amp: 0.1 }, pitch: #{ freq: 300.0 } });
            end();
        "#,
        );

        let mut pad_time = None;
        let mut after_time = None;
        let mut finish_time = None;
        for ev in &scenario.events {
            for action in &ev.actions {
                match action {
                    Action::Spawn { tag, .. } => match tag.as_str() {
                        "pad" => pad_time = Some(ev.time),
                        "after" => after_time = Some(ev.time),
                        _ => {}
                    },
                    Action::Finish => finish_time = Some(ev.time),
                    _ => {}
                }
            }
        }

        assert_time_close(pad_time.expect("pad time"), 0.6);
        assert_time_close(after_time.expect("after time"), 0.3);
        assert_time_close(finish_time.expect("finish time"), 0.3);
    }

    #[test]
    fn spawn_uses_relative_scene_time() {
        let scenario = run_script(
            r#"
            scene("alpha");
            wait(1.2);
            spawn("tag", 3, #{ body: #{ amp: 0.25 }, pitch: #{ freq: 150.0 } });
            end();
        "#,
        );

        assert_eq!(scenario.scene_markers.len(), 1);
        assert_eq!(scenario.scene_markers[0].name, "alpha");
        assert_time_close(scenario.scene_markers[0].time, 0.0);

        let ev = scenario
            .events
            .iter()
            .find(|ev| ev.actions.iter().any(|a| matches!(a, Action::Spawn { .. })))
            .expect("spawn event");
        assert_time_close(ev.time, 1.2);
        assert_eq!(ev.actions.len(), 1);
        match &ev.actions[0] {
            Action::Spawn { count, tag, .. } => {
                assert_eq!(*count, 3);
                assert_eq!(tag, "tag");
            }
            other => panic!("unexpected action: {:?}", other),
        }
    }

    #[test]
    fn scene_created_when_scene_absent() {
        let scenario = run_script(
            r#"
            spawn("init", 1, #{ body: #{ amp: 0.2 }, pitch: #{ freq: 330.0 } });
            wait(0.3);
            end();
        "#,
        );

        assert!(scenario.scene_markers.is_empty());
        assert_eq!(scenario.events.len(), 2);
        assert_time_close(scenario.events[0].time, 0.0);
        assert_time_close(scenario.events[1].time, 0.3);
    }

    #[test]
    fn sample_script_file_executes() {
        let scenario = ScriptHost::load_script("samples/01_fundamentals/spawn_basics.rhai")
            .expect("sample script should run");
        assert!(!scenario.events.is_empty());
    }

    #[test]
    fn minimal_spawn_run_executes() {
        let scenario = ScriptHost::load_script("tests/scripts/minimal_spawn_run.rhai")
            .expect("minimal script should run");
        let mut has_spawn = false;
        for ev in &scenario.events {
            for action in &ev.actions {
                if let Action::Spawn { count, .. } = action {
                    assert!(*count > 0);
                    has_spawn = true;
                }
            }
        }
        let has_finish = scenario
            .events
            .iter()
            .any(|ev| ev.actions.iter().any(|a| matches!(a, Action::Finish)));
        assert!(has_spawn, "expected spawn event");
        assert!(has_finish, "expected finish event");
    }

    #[test]
    fn spawn_two_args_creates_agent() {
        let action = spawn_action_from_script(
            r#"
            spawn("unit", 1);
            end();
        "#,
        );
        let landscape = LandscapeFrame::new(Log2Space::new(100.0, 400.0, 12));
        let pop = apply_spawn_action(action, &landscape);
        assert_eq!(pop.individuals.len(), 1);
    }

    #[test]
    fn spawn_three_args_patch_applies_amp() {
        let action = spawn_action_from_script(
            r#"
            spawn("unit", 1, #{ body: #{ amp: 0.42 } });
            end();
        "#,
        );
        let landscape = LandscapeFrame::new(Log2Space::new(100.0, 400.0, 12));
        let pop = apply_spawn_action(action, &landscape);
        let amp = pop.individuals[0].effective_control.body.amp;
        assert!((amp - 0.42).abs() <= 1e-6);
    }

    #[test]
    fn spawn_three_args_opts_samples_freq_in_range() {
        let space = Log2Space::new(100.0, 400.0, 12);
        let min_freq = space.freq_of_index(2);
        let max_freq = space.freq_of_index(6);
        let src = format!(
            r#"
            spawn("unit", 1, #{{
                method: #{{
                    mode: "harmonicity",
                    min_freq: {min_freq},
                    max_freq: {max_freq}
                }}
            }});
            end();
        "#
        );
        let action = spawn_action_from_script(&src);
        let landscape = LandscapeFrame::new(space.clone());
        let pop = apply_spawn_action(action, &landscape);
        let agent = pop.individuals.first().expect("agent exists");
        let sampled = agent.effective_control.pitch.freq;
        let idx = space.index_of_freq(sampled).expect("sampled idx");
        let center = space.freq_of_index(idx);
        assert!(center >= min_freq && center <= max_freq);
    }

    #[test]
    fn spawn_four_args_opts_and_patch_apply() {
        let space = Log2Space::new(100.0, 400.0, 12);
        let min_freq = space.freq_of_index(1);
        let max_freq = space.freq_of_index(5);
        let src = format!(
            r#"
            spawn("unit", 1,
                #{{
                    method: #{{
                        mode: "harmonicity",
                        min_freq: {min_freq},
                        max_freq: {max_freq}
                    }}
                }},
                #{{ phonation: #{{ type: "hold" }} }}
            );
            end();
        "#
        );
        let action = spawn_action_from_script(&src);
        let landscape = LandscapeFrame::new(space.clone());
        let pop = apply_spawn_action(action, &landscape);
        let agent = pop.individuals.first().expect("agent exists");
        assert_eq!(
            agent.effective_control.phonation.r#type,
            PhonationType::Hold
        );
        let sampled = agent.effective_control.pitch.freq;
        let idx = space.index_of_freq(sampled).expect("sampled idx");
        let center = space.freq_of_index(idx);
        assert!(center >= min_freq && center <= max_freq);
    }

    #[test]
    fn spawn_opts_unknown_key_errors() {
        let err = eval_script_error(
            r#"
            spawn("unit", 1, #{ bad: 1 }, #{});
            end();
        "#,
        );
        let msg = err.to_string();
        assert!(msg.contains("SpawnOpts") || msg.contains("unknown field"));
    }

    #[test]
    fn spawn_three_args_empty_opts_is_noop() {
        let scenario = run_script(
            r#"
            spawn("unit", 1, #{});
            end();
        "#,
        );
        let action = scenario
            .events
            .iter()
            .flat_map(|ev| ev.actions.iter())
            .find_map(|action| match action {
                Action::Spawn { .. } => Some(action.clone()),
                _ => None,
            })
            .expect("spawn action exists");
        match action {
            Action::Spawn { opts, patch, .. } => {
                assert!(opts.is_some());
                assert_eq!(patch, serde_json::json!({}));
            }
            _ => panic!("unexpected action"),
        }
    }

    #[test]
    fn end_at_sets_duration() {
        let scenario = run_script(
            r#"
            spawn("d", 1, #{ body: #{ amp: 0.2 }, pitch: #{ freq: 200.0 } });
            end_at(20);
        "#,
        );
        assert_time_close(scenario.duration_sec, 20.0);
        let has_finish = scenario
            .events
            .iter()
            .any(|ev| ev.time == 20.0 && ev.actions.iter().any(|a| matches!(a, Action::Finish)));
        assert!(has_finish, "expected finish at end_at time");
    }

    #[test]
    fn end_sets_duration_from_cursor() {
        let scenario = run_script(
            r#"
            wait(2);
            end();
        "#,
        );
        assert_time_close(scenario.duration_sec, 2.0);
    }

    #[test]
    fn end_at_negative_has_position() {
        let src = r#"
            end_at(-1);
        "#;
        let full = ScriptHost::combined_script(src);
        let pos = eval_script_error_position(src);
        let expected_line = expected_line(&full, "end_at(-1");
        assert_eq!(pos.line().unwrap(), expected_line);
    }

    #[test]
    fn end_is_terminal() {
        let src = r#"
            end_at(1);
            spawn("AFTER_END_123", 1);
        "#;
        let full = ScriptHost::combined_script(src);
        let pos = eval_script_error_position(src);
        let expected_line = expected_line(&full, "AFTER_END_123");
        assert_eq!(pos.line().unwrap(), expected_line);
    }

    #[test]
    fn end_is_required() {
        let src = r#"
            spawn("d", 1);
        "#;
        let err = eval_script_error(src);
        let msg = err.to_string();
        assert!(
            msg.contains("end()") || msg.contains("end_at"),
            "message: {msg}"
        );
        let pos = err.position();
        assert_ne!(pos, Position::NONE);
    }

    #[test]
    fn spawn_opts_unknown_key_has_position() {
        let pos = eval_script_error_position(
            r#"
            spawn("d", 1, #{ body: #{ ampp: 0.1 } });
        "#,
        );
        assert_ne!(pos, Position::NONE);
    }

    #[test]
    fn spawn_opts_bad_type_has_position() {
        let pos = eval_script_error_position(
            r#"
            spawn("d", 1, #{ body: #{ amp: "0.1" } });
        "#,
        );
        assert_ne!(pos, Position::NONE);
    }

    #[test]
    fn set_patch_unknown_key_has_position() {
        let pos = eval_script_error_position(
            r#"
            spawn("d", 1);
            set("d", #{ body: #{ amp: 0.1, ampp: 0.2 } });
        "#,
        );
        assert_ne!(pos, Position::NONE);
    }

    #[test]
    fn set_patch_bad_type_has_position() {
        let pos = eval_script_error_position(
            r#"
            spawn("d", 1);
            set("d", #{ body: #{ amp: "x" } });
        "#,
        );
        assert_ne!(pos, Position::NONE);
    }

    #[test]
    fn spawn_count_error_points_to_count_arg() {
        let src = r#"
            spawn(
                "d",
                "BAD_COUNT_123",
                #{}
            );
        "#;
        let full = ScriptHost::combined_script(src);
        let pos = eval_script_error_position(src);
        let expected_line = expected_line(&full, "BAD_COUNT_123");
        assert_eq!(pos.line().unwrap(), expected_line);
    }

    #[test]
    fn spawn_opts_error_points_to_opts_arg() {
        let src = r#"
            spawn(
                "d",
                1,
                "BAD_OPTS_123"
            );
        "#;
        let full = ScriptHost::combined_script(src);
        let pos = eval_script_error_position(src);
        let expected_line = expected_line(&full, "BAD_OPTS_123");
        assert_eq!(pos.line().unwrap(), expected_line);
    }

    #[test]
    fn spawn_opts_unknown_key_points_to_opts_arg() {
        let src = r#"
            spawn(
                "d",
                1,
                #{ body: #{ amm_BADKEY_123: 0.1 } }
            );
        "#;
        let full = ScriptHost::combined_script(src);
        let pos = eval_script_error_position(src);
        let expected_line = expected_line(&full, "amm_BADKEY_123");
        assert_eq!(pos.line().unwrap(), expected_line);
    }

    #[test]
    fn spawn_count_negative_points_to_count_arg() {
        let src = r#"
            spawn(
                "d",
                -123
            );
        "#;
        let full = ScriptHost::combined_script(src);
        let pos = eval_script_error_position(src);
        let expected_line = expected_line(&full, "-123");
        assert_eq!(pos.line().unwrap(), expected_line);
    }

    #[test]
    fn empty_life_map_executes() {
        let scenario = ScriptHost::load_script("tests/scripts/empty_life_map_ok.rhai")
            .expect("empty life map should run");
        let mut has_add = false;
        for ev in &scenario.events {
            for action in &ev.actions {
                if let Action::Spawn { count, .. } = action {
                    assert!(*count > 0);
                    has_add = true;
                }
            }
        }
        let has_finish = scenario
            .events
            .iter()
            .any(|ev| ev.actions.iter().any(|a| matches!(a, Action::Finish)));
        assert!(has_add, "expected spawn event");
        assert!(has_finish, "expected finish event");
    }

    #[test]
    fn handle_index_and_iter_executes() {
        let scenario = ScriptHost::load_script("tests/scripts/handle_index_and_iter.rhai")
            .expect("handle iteration script should run");
        assert!(!scenario.events.is_empty());
    }

    #[test]
    fn tag_selector_ops_executes() {
        let scenario = ScriptHost::load_script("tests/scripts/tag_selector_ops.rhai")
            .expect("tag selector script should run");
        assert!(!scenario.events.is_empty());
    }

    #[test]
    fn stable_order_same_time_is_monotonic() {
        let scenario = ScriptHost::load_script("tests/scripts/stable_order_same_time.rhai")
            .expect("stable order script should run");
        let mut last_order = 0;
        let mut freqs = Vec::new();
        for ev in &scenario.events {
            assert!(ev.order > last_order);
            last_order = ev.order;
            for action in &ev.actions {
                if let Action::Set { patch, .. } = action {
                    let freq = patch
                        .as_object()
                        .and_then(|m| m.get("pitch"))
                        .and_then(|p| p.as_object())
                        .and_then(|m| m.get("freq"))
                        .and_then(|v| v.as_f64())
                        .map(|v| v as f32);
                    if let Some(freq) = freq {
                        freqs.push(freq);
                    }
                }
            }
        }
        assert_eq!(freqs, vec![200.0, 300.0]);
    }

    #[test]
    fn all_sample_scripts_parse() {
        let mut stack = vec![std::path::PathBuf::from("samples")];
        while let Some(dir) = stack.pop() {
            for entry in std::fs::read_dir(&dir).expect("samples dir exists") {
                let path = entry.expect("dir entry").path();
                let name = path
                    .file_name()
                    .and_then(|s| s.to_str())
                    .unwrap_or_default()
                    .to_string();
                if name.starts_with('#') || name.starts_with('.') || name.ends_with('~') {
                    continue;
                }
                if path.is_dir() {
                    stack.push(path);
                    continue;
                }
                if path.extension().and_then(|s| s.to_str()) != Some("rhai") {
                    continue;
                }
                ScriptHost::load_script(path.to_str().expect("path str"))
                    .unwrap_or_else(|e| panic!("script {name} should parse: {e}"));
            }
        }
    }
}
</file>

<file path="src/life/tests_organic.rs">
use crate::core::landscape::{Landscape, LandscapeFrame};
use crate::core::log2space::Log2Space;
use crate::core::modulation::NeuralRhythms;
use crate::core::timebase::Timebase;
use crate::life::control::AgentControl;
use crate::life::individual::{
    AgentMetadata, AnyArticulationCore, ArticulationCore, Individual, SoundBody,
};
use crate::life::lifecycle::LifecycleConfig;
use crate::life::population::Population;
use crate::life::scenario::{Action, ArticulationCoreConfig, IndividualConfig};
use rand::SeedableRng;

fn mix_signature(mut acc: u64, value: u32) -> u64 {
    acc ^= value as u64;
    acc = acc.wrapping_mul(0x9E37_79B9_7F4A_7C15);
    acc
}

fn make_landscape() -> Landscape {
    let space = Log2Space::new(55.0, 4000.0, 48);
    Landscape::new(space)
}

fn control_with_pitch(freq: f32) -> AgentControl {
    let mut control = AgentControl::default();
    control.pitch.freq = freq.max(1.0);
    control
}

fn spawn_agent(freq: f32, id: u64) -> Individual {
    let control = control_with_pitch(freq);
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    cfg.spawn(id, 0, meta, 48_000.0, 0)
}

#[test]
fn test_inertia_calculation() {
    let landscape = make_landscape();
    let mut low = spawn_agent(60.0, 1);
    let mut high = spawn_agent(1000.0, 2);
    let rhythms = NeuralRhythms::default();

    low.update_pitch_target(&rhythms, 0.01, &landscape);
    high.update_pitch_target(&rhythms, 0.01, &landscape);

    assert!(
        low.integration_window() > high.integration_window(),
        "expected heavier (low) pitch to integrate longer than high pitch"
    );
}

#[test]
fn test_scan_logic() {
    let mut landscape = make_landscape();
    let mut agent = spawn_agent(220.0, 3);
    let n = landscape.consonance01.len();
    landscape.subjective_intensity = vec![1.0; n];
    landscape.consonance01.fill(0.0);
    let idx_cur = landscape
        .space
        .index_of_freq(agent.body.base_freq_hz())
        .unwrap_or(0);
    landscape.consonance01[idx_cur] = 0.0;
    let target_alt = agent.body.base_freq_hz() * 1.5;
    if let Some(idx_alt) = landscape.space.index_of_freq(target_alt) {
        if let Some(c) = landscape.consonance01.get_mut(idx_alt) {
            *c = 1.0;
        }
    }

    agent.set_accumulated_time_for_test(5.0);
    agent.set_theta_phase_state_for_test(6.0, true);
    let mut rhythms = NeuralRhythms::default();
    rhythms.theta.mag = 1.0;
    rhythms.theta.phase = 0.25;

    let before = agent.target_pitch_log2();
    agent.update_pitch_target(&rhythms, 0.01, &landscape);
    assert!(
        agent.target_pitch_log2() > before,
        "agent should move toward higher-scoring neighbor"
    );
}

#[test]
fn lock_mode_prevents_snapback() {
    let landscape = make_landscape();
    let mut pop = Population::new(Timebase {
        fs: 48_000.0,
        hop: 64,
    });
    pop.apply_action(
        Action::Spawn {
            tag: "setfreq_test".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 220.0 }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );

    let old_target = pop
        .individuals
        .first()
        .expect("agent exists")
        .target_pitch_log2();

    let new_freq: f32 = 440.0;
    let new_log = new_freq.log2();
    pop.apply_action(
        Action::Set {
            target: "setfreq_test".to_string(),
            patch: serde_json::json!({
                "pitch": { "mode": "lock", "freq": new_freq }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );

    let mut rhythms = NeuralRhythms::default();
    rhythms.theta.mag = 0.0;
    rhythms.theta.phase = 0.0;
    let dt_sec = 0.02;
    let steps = 50;
    let agent = pop.individuals.first_mut().expect("agent exists");
    for _ in 0..steps {
        agent.update_pitch_target(&rhythms, dt_sec, &landscape);
    }
    assert!(
        (agent.target_pitch_log2() - new_log).abs() < 1e-6,
        "target should remain locked to mode"
    );
    assert!(
        (agent.target_pitch_log2() - old_target).abs() > 0.5,
        "target should move away from old target"
    );
}

#[test]
fn articulation_snapshot_kuramoto_decay_signature() {
    let fs = 48_000.0;
    let mut rng = rand::rngs::StdRng::seed_from_u64(11);
    let core = ArticulationCoreConfig::Entrain {
        lifecycle: LifecycleConfig::Decay {
            initial_energy: 1.0,
            half_life_sec: 0.2,
            attack_sec: 0.1,
        },
        rhythm_freq: Some(6.0),
        rhythm_sensitivity: None,
        breath_gain_init: None,
    };
    let mut articulation = AnyArticulationCore::from_config(&core, fs, 7, &mut rng);
    let mut rhythms = NeuralRhythms {
        theta: crate::core::modulation::RhythmBand {
            phase: 0.0,
            freq_hz: 6.0,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.2,
        },
        delta: crate::core::modulation::RhythmBand {
            phase: 0.0,
            freq_hz: 0.5,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.0,
        },
        env_level: 1.0,
        env_open: 1.0,
    };
    let dt = 1.0 / fs;
    let consonance = 0.7;
    let steps = 48_000;
    let mut signature = 0u64;
    let mut early_active = false;

    for i in 0..steps {
        let signal = articulation.process(consonance, &rhythms, dt, 1.0);
        if i < 10 && (signal.is_active || signal.amplitude > 0.0) {
            early_active = true;
        }
        signature = mix_signature(signature, signal.is_active as u32);
        signature = mix_signature(signature, signal.amplitude.to_bits());
        signature = mix_signature(signature, signal.relaxation.to_bits());
        signature = mix_signature(signature, signal.tension.to_bits());
        rhythms.advance_in_place(dt);
    }

    assert!(early_active, "expected early attack during decay lifecycle");
    println!("articulation decay signature: {signature:016x}");
    assert_eq!(signature, 0xc1be_e9d9_3e85_ee96);
}
</file>

<file path="src/life/sound_voice.rs">
use crate::core::modulation::NeuralRhythms;
use crate::core::timebase::{Tick, Timebase};
use crate::life::individual::{AnySoundBody, ArticulationSignal, ArticulationWrapper, SoundBody};
use crate::life::intent::{BodySnapshot, Intent};
use crate::life::lifecycle::default_decay_attack;
use crate::life::phonation_engine::{PhonationKick, PhonationUpdate};
use crate::life::scenario::{SoundBodyConfig, TimbreGenotype};
use rand::SeedableRng;
use rand::rngs::SmallRng;
use std::collections::VecDeque;

#[derive(Debug, Clone, Copy)]
struct PendingUpdate {
    at_tick: Tick,
    update: PhonationUpdate,
}

pub struct SoundVoice {
    body: AnySoundBody,
    articulation: Option<ArticulationWrapper>,
    onset: Tick,
    hold_end: Tick,
    release_end: Tick,
    attack_ticks: Tick,
    release_ticks: Tick,
    planned_kick_pending: Option<PhonationKick>,
    pending_updates: VecDeque<PendingUpdate>,
    current_amp: f32,
    target_amp: f32,
    current_freq_hz: f32,
    target_freq_hz: f32,
    amp_tau_sec: f32,
    freq_tau_sec: f32,
    amp_alpha: f32,
    freq_alpha: f32,
    sample_dt: f32,
}

impl SoundVoice {
    pub fn from_intent(time: Timebase, mut intent: Intent) -> Option<Self> {
        if intent.duration == 0 || intent.freq_hz <= 0.0 {
            return None;
        }
        if !intent.freq_hz.is_finite() || !intent.amp.is_finite() {
            return None;
        }
        if intent.amp == 0.0 {
            return None;
        }

        let (config, amp_scale) = match intent.body.as_ref() {
            Some(snapshot) => (
                sound_body_config_from_snapshot(snapshot),
                snapshot.amp_scale,
            ),
            None => (SoundBodyConfig::Sine { phase: None }, 1.0),
        };
        let amp = intent.amp * amp_scale.clamp(0.0, 1.0);
        if !amp.is_finite() {
            return None;
        }
        if amp <= 0.0 {
            return None;
        }

        let seed = intent
            .intent_id
            .wrapping_add(intent.source_id.rotate_left(17))
            .wrapping_add(intent.onset);
        let mut rng = SmallRng::seed_from_u64(seed);
        let body = AnySoundBody::from_config(&config, intent.freq_hz, amp, &mut rng);
        let articulation = intent.articulation.take();

        let attack_ticks = default_attack_ticks(time);
        let release_ticks = default_release_ticks(time);
        let (hold_end, release_end) = if intent.duration == Tick::MAX {
            (Tick::MAX, Tick::MAX)
        } else {
            let hold_end = intent.onset.saturating_add(intent.duration);
            let release_end = hold_end.saturating_add(release_ticks);
            (hold_end, release_end)
        };

        let sample_dt = if time.fs.is_finite() && time.fs > 0.0 {
            1.0 / time.fs
        } else {
            0.0
        };
        let current_amp = amp.max(0.0);
        let target_amp = current_amp;
        let current_freq_hz = intent.freq_hz;
        let target_freq_hz = current_freq_hz;
        let amp_tau_sec = 0.0;
        let freq_tau_sec = 0.0;
        let amp_alpha = smoothing_alpha(sample_dt, amp_tau_sec);
        let freq_alpha = smoothing_alpha(sample_dt, freq_tau_sec);

        Some(Self {
            body,
            articulation,
            onset: intent.onset,
            hold_end,
            release_end,
            attack_ticks,
            release_ticks,
            planned_kick_pending: None,
            pending_updates: VecDeque::new(),
            current_amp,
            target_amp,
            current_freq_hz,
            target_freq_hz,
            amp_tau_sec,
            freq_tau_sec,
            amp_alpha,
            freq_alpha,
            sample_dt,
        })
    }

    pub fn note_off(&mut self, tick: Tick) {
        if tick < self.hold_end {
            self.hold_end = tick;
            self.release_end = self.hold_end.saturating_add(self.release_ticks);
        }
    }

    pub fn note_on(&mut self, tick: Tick) {
        if tick > self.onset {
            self.onset = tick;
            if self.hold_end < self.onset {
                self.hold_end = self.onset;
                self.release_end = self.hold_end.saturating_add(self.release_ticks);
            }
        }
    }

    pub fn kick_planned(&mut self, kick: PhonationKick, rhythms: &NeuralRhythms, dt: f32) -> bool {
        if let Some(articulation) = self.articulation.as_mut() {
            articulation.kick_planned(kick, rhythms, dt);
            return true;
        }
        false
    }

    pub fn schedule_planned_kick(&mut self, kick: PhonationKick) {
        self.planned_kick_pending = Some(kick);
    }

    pub fn schedule_update(&mut self, at_tick: Tick, update: PhonationUpdate) {
        if update.is_empty() {
            return;
        }
        let insert_at = self
            .pending_updates
            .iter()
            .position(|pending| pending.at_tick > at_tick)
            .unwrap_or(self.pending_updates.len());
        self.pending_updates
            .insert(insert_at, PendingUpdate { at_tick, update });
    }

    pub fn apply_updates_if_due(&mut self, tick: Tick) {
        if tick >= self.hold_end {
            self.pending_updates.clear();
            return;
        }
        while let Some(pending) = self.pending_updates.front().copied() {
            if pending.at_tick > tick {
                break;
            }
            let pending = self.pending_updates.pop_front().expect("pending update");
            self.apply_update(&pending.update);
        }
    }

    pub fn kick_planned_if_due(&mut self, tick: Tick, rhythms: &NeuralRhythms, dt: f32) -> bool {
        let Some(kick) = self.planned_kick_pending else {
            return false;
        };
        if tick >= self.onset {
            self.planned_kick_pending = None;
            return self.kick_planned(kick, rhythms, dt);
        }
        false
    }

    pub fn apply_update(&mut self, update: &PhonationUpdate) {
        if let Some(freq_hz) = update.target_freq_hz
            && freq_hz.is_finite()
            && freq_hz > 0.0
        {
            self.target_freq_hz = freq_hz;
            if self.freq_alpha >= 1.0 {
                self.current_freq_hz = freq_hz;
                self.body.set_freq(freq_hz);
            }
        }
        if let Some(amp) = update.target_amp
            && amp.is_finite()
        {
            let amp = amp.max(0.0);
            self.target_amp = amp;
            if self.amp_alpha >= 1.0 {
                self.current_amp = amp;
                self.body.set_amp(amp);
            }
        }
    }

    pub fn set_smoothing_tau_sec(&mut self, tau_sec: f32) {
        let tau = if tau_sec.is_finite() {
            tau_sec.max(0.0)
        } else {
            0.0
        };
        self.amp_tau_sec = tau;
        self.freq_tau_sec = tau;
        self.amp_alpha = smoothing_alpha(self.sample_dt, self.amp_tau_sec);
        self.freq_alpha = smoothing_alpha(self.sample_dt, self.freq_tau_sec);
        if self.amp_alpha >= 1.0 {
            self.current_amp = self.target_amp;
            self.body.set_amp(self.current_amp);
        }
        if self.freq_alpha >= 1.0 {
            self.current_freq_hz = self.target_freq_hz;
            self.body.set_freq(self.current_freq_hz);
        }
    }

    #[cfg(test)]
    pub(crate) fn debug_body_freq_hz(&self) -> f32 {
        self.body.base_freq_hz()
    }

    #[cfg(test)]
    pub(crate) fn debug_body_amp(&self) -> f32 {
        self.body.amp()
    }

    #[cfg(test)]
    pub(crate) fn debug_target_amp(&self) -> f32 {
        self.target_amp
    }

    #[cfg(test)]
    pub(crate) fn debug_current_amp(&self) -> f32 {
        self.current_amp
    }

    #[cfg(test)]
    pub(crate) fn debug_target_freq_hz(&self) -> f32 {
        self.target_freq_hz
    }

    #[cfg(test)]
    pub(crate) fn debug_current_freq_hz(&self) -> f32 {
        self.current_freq_hz
    }

    pub fn end_tick(&self) -> Tick {
        self.release_end
    }

    pub fn onset(&self) -> Tick {
        self.onset
    }

    pub fn is_done(&self, now: Tick) -> bool {
        now >= self.release_end
    }

    pub fn render_tick(&mut self, tick: Tick, fs: f32, dt: f32, rhythms: &NeuralRhythms) -> f32 {
        self.advance_smoothing();
        let gain = self.gain_at(tick);
        if gain <= 0.0 {
            return 0.0;
        }
        let mut signal = if let Some(articulation) = self.articulation.as_mut() {
            let mut signal = articulation.process(1.0, rhythms, dt, 1.0);
            signal.amplitude *= articulation.gate();
            signal
        } else {
            ArticulationSignal {
                amplitude: 1.0,
                is_active: true,
                relaxation: rhythms.theta.alpha,
                tension: rhythms.theta.beta,
            }
        };
        signal.amplitude *= gain;
        signal.is_active = signal.is_active && signal.amplitude > 0.0;
        let mut sample = 0.0f32;
        self.body.articulate_wave(&mut sample, fs, dt, &signal);
        sample
    }

    fn advance_smoothing(&mut self) {
        self.current_amp = smooth_step(self.current_amp, self.target_amp, self.amp_alpha);
        if !self.current_amp.is_finite() {
            self.current_amp = self.target_amp;
        }
        self.current_amp = self.current_amp.max(0.0);

        self.current_freq_hz =
            smooth_step(self.current_freq_hz, self.target_freq_hz, self.freq_alpha);
        if !self.current_freq_hz.is_finite() || self.current_freq_hz <= 0.0 {
            self.current_freq_hz = self.target_freq_hz;
        }

        if self.current_amp.is_finite() {
            self.body.set_amp(self.current_amp);
        }
        if self.current_freq_hz.is_finite() && self.current_freq_hz > 0.0 {
            self.body.set_freq(self.current_freq_hz);
        }
    }

    fn gain_at(&self, tick: Tick) -> f32 {
        if tick < self.onset || tick >= self.release_end {
            return 0.0;
        }

        let duration_ticks = self.hold_end.saturating_sub(self.onset).max(1);
        let pos = tick.saturating_sub(self.onset);
        let attack_len = self.attack_ticks.min(duration_ticks);
        let attack = if attack_len > 0 && pos < attack_len {
            (pos.saturating_add(1) as f32 / attack_len as f32).clamp(0.0, 1.0)
        } else {
            1.0
        };

        let release = if tick >= self.hold_end {
            if self.release_ticks == 0 {
                0.0
            } else {
                let remain = self.release_end.saturating_sub(tick);
                (remain as f32 / self.release_ticks as f32).clamp(0.0, 1.0)
            }
        } else {
            1.0
        };

        (attack * release).clamp(0.0, 1.0)
    }
}

fn smooth_step(current: f32, target: f32, alpha: f32) -> f32 {
    if !current.is_finite() {
        return target;
    }
    if !target.is_finite() {
        return current;
    }
    current + alpha * (target - current)
}

fn smoothing_alpha(dt: f32, tau_sec: f32) -> f32 {
    if !dt.is_finite() || dt <= 0.0 {
        return 1.0;
    }
    if !tau_sec.is_finite() || tau_sec <= 0.0 {
        return 1.0;
    }
    let alpha = 1.0 - (-dt / tau_sec).exp();
    if alpha.is_finite() {
        alpha.clamp(0.0, 1.0)
    } else {
        1.0
    }
}

pub fn default_release_ticks(time: Timebase) -> Tick {
    let release_sec = default_decay_attack();
    sec_to_tick_at_least_one(time, release_sec)
}

fn default_attack_ticks(time: Timebase) -> Tick {
    let attack_sec = default_decay_attack();
    sec_to_tick_at_least_one(time, attack_sec)
}

fn sec_to_tick_at_least_one(time: Timebase, sec: f32) -> Tick {
    if !sec.is_finite() || sec <= 0.0 {
        return 1;
    }
    let ticks = time.sec_to_tick(sec);
    if ticks < 1 { 1 } else { ticks }
}

fn sound_body_config_from_snapshot(snapshot: &BodySnapshot) -> SoundBodyConfig {
    match snapshot.kind.as_str() {
        "harmonic" => SoundBodyConfig::Harmonic {
            genotype: TimbreGenotype {
                brightness: snapshot.brightness.clamp(0.0, 1.0),
                jitter: snapshot.noise_mix.clamp(0.0, 1.0),
                ..TimbreGenotype::default()
            },
            partials: None,
        },
        _ => SoundBodyConfig::Sine { phase: None },
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::life::individual::{AnyArticulationCore, ArticulationWrapper, SequencedCore};

    #[test]
    fn planned_kick_waits_for_onset() {
        let tb = Timebase {
            fs: 48_000.0,
            hop: 64,
        };
        let articulation = ArticulationWrapper::new(
            AnyArticulationCore::Seq(SequencedCore {
                timer: 0.0,
                duration: 0.1,
                env_level: 0.0,
            }),
            1.0,
        );
        let intent = Intent {
            source_id: 1,
            intent_id: 0,
            onset: 10,
            duration: 20,
            freq_hz: 440.0,
            amp: 0.5,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: Some(articulation),
        };
        let mut voice = SoundVoice::from_intent(tb, intent).expect("voice");
        let rhythms = NeuralRhythms::default();
        let dt = 1.0 / tb.fs;
        voice.schedule_planned_kick(PhonationKick::Planned { strength: 1.0 });
        assert!(!voice.kick_planned_if_due(9, &rhythms, dt));
        assert!(voice.kick_planned_if_due(10, &rhythms, dt));
        assert!(!voice.kick_planned_if_due(11, &rhythms, dt));
    }

    #[test]
    fn max_duration_note_off_releases() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let intent = Intent {
            source_id: 1,
            intent_id: 1,
            onset: 0,
            duration: Tick::MAX,
            freq_hz: 220.0,
            amp: 0.5,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        };
        let mut voice = SoundVoice::from_intent(tb, intent).expect("voice");
        let off_tick = 4;
        voice.note_off(off_tick);
        let done_tick = off_tick
            .saturating_add(default_release_ticks(tb))
            .saturating_add(1);
        assert!(voice.is_done(done_tick));
    }

    #[test]
    fn update_applies_pitch_and_orders_updates() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let intent = Intent {
            source_id: 1,
            intent_id: 1,
            onset: 0,
            duration: 10,
            freq_hz: 220.0,
            amp: 0.5,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        };
        let mut voice = SoundVoice::from_intent(tb, intent).expect("voice");
        voice.schedule_update(
            0,
            PhonationUpdate {
                target_freq_hz: Some(330.0),
                target_amp: None,
            },
        );
        voice.schedule_update(
            0,
            PhonationUpdate {
                target_freq_hz: Some(440.0),
                target_amp: None,
            },
        );
        voice.apply_updates_if_due(0);
        assert!((voice.debug_target_freq_hz() - 440.0).abs() < 1e-6);
        assert!((voice.debug_current_freq_hz() - 440.0).abs() < 1e-6);
    }

    #[test]
    fn note_off_wins_over_same_tick_update() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let intent = Intent {
            source_id: 1,
            intent_id: 1,
            onset: 0,
            duration: 10,
            freq_hz: 220.0,
            amp: 0.5,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        };
        let mut voice = SoundVoice::from_intent(tb, intent).expect("voice");
        voice.note_off(0);
        voice.schedule_update(
            0,
            PhonationUpdate {
                target_freq_hz: Some(440.0),
                target_amp: None,
            },
        );
        voice.apply_updates_if_due(0);
        assert!((voice.body.base_freq_hz() - 220.0).abs() < 1e-6);
    }

    #[test]
    fn note_off_discards_past_update_after_release() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let intent = Intent {
            source_id: 1,
            intent_id: 1,
            onset: 0,
            duration: 10,
            freq_hz: 220.0,
            amp: 0.5,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        };
        let mut voice = SoundVoice::from_intent(tb, intent).expect("voice");
        voice.note_off(1);
        voice.schedule_update(
            0,
            PhonationUpdate {
                target_freq_hz: Some(440.0),
                target_amp: None,
            },
        );
        voice.apply_updates_if_due(2);
        assert!((voice.body.base_freq_hz() - 220.0).abs() < 1e-6);
    }

    #[test]
    fn smoothing_tau_zero_updates_immediately() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let intent = Intent {
            source_id: 1,
            intent_id: 1,
            onset: 0,
            duration: 10,
            freq_hz: 220.0,
            amp: 0.1,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        };
        let mut voice = SoundVoice::from_intent(tb, intent).expect("voice");
        voice.set_smoothing_tau_sec(0.0);
        voice.schedule_update(
            0,
            PhonationUpdate {
                target_freq_hz: Some(440.0),
                target_amp: Some(0.5),
            },
        );
        voice.apply_updates_if_due(0);
        assert!((voice.debug_current_freq_hz() - 440.0).abs() < 1e-6);
        assert!((voice.debug_current_amp() - 0.5).abs() < 1e-6);
        assert!((voice.debug_target_freq_hz() - 440.0).abs() < 1e-6);
        assert!((voice.debug_target_amp() - 0.5).abs() < 1e-6);
    }

    #[test]
    fn smoothing_tau_positive_moves_toward_target() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let intent = Intent {
            source_id: 1,
            intent_id: 1,
            onset: 0,
            duration: 10,
            freq_hz: 220.0,
            amp: 0.1,
            tag: None,
            confidence: 1.0,
            body: None,
            articulation: None,
        };
        let mut voice = SoundVoice::from_intent(tb, intent).expect("voice");
        voice.set_smoothing_tau_sec(0.1);
        voice.schedule_update(
            0,
            PhonationUpdate {
                target_freq_hz: Some(440.0),
                target_amp: Some(1.0),
            },
        );
        voice.apply_updates_if_due(0);

        let amp_before = voice.debug_current_amp();
        let freq_before = voice.debug_current_freq_hz();
        let rhythms = NeuralRhythms::default();
        let dt = 1.0 / tb.fs;
        let _ = voice.render_tick(0, tb.fs, dt, &rhythms);

        let amp_after = voice.debug_current_amp();
        let freq_after = voice.debug_current_freq_hz();
        assert!(amp_after > amp_before && amp_after < voice.debug_target_amp());
        assert!(freq_after > freq_before && freq_after < voice.debug_target_freq_hz());
    }
}
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- Source lives in `src/` with focused modules:
  - `core/` (Psychoacoustic DSP primitives):
    - `log2space.rs`: Log-frequency coordinate system (octave-based).
    - `nsgt*.rs`: Non-Stationary Gabor Transform implementations (RT, FFT, and Kernel variants).
    - `harmonicity_kernel.rs`: Virtual pitch/root detection via harmonic templates.
    - `roughness_kernel.rs`: Sensory dissonance calculation via interference kernels.
    - `phase.rs`: Phase wrap/diff utilities (shared across rhythm + kernels).
    - `landscape.rs`: Real-time integration of Roughness and Harmonicity.
    - `fft.rs`: FFT wrappers and Hilbert transform logic.
    - `erb.rs`: Equivalent Rectangular Bandwidth scales.
  - `audio/` (Real-time I/O):
    - `output.rs`: cpal stream management (ringbuffer producer).
    - `buffer.rs`: Interleaved audio buffer types.
    - `writer.rs`: Disk recording (WAV).
  - `synth/` (Synthesis engine):
    - Phase-vocoder/additive synthesis based on NSGT bins.
  - `ui/` (UI and visualization):
    - Egui views, plots, and visualization logic.
  - `life/` (Agents and behaviors):
    - Individual/Population models, temporal cores, fields, and scenario scripting.
  - `web/` (Project website):
    - Zola site sources.
- Entrypoints: `src/main.rs` (binary) and `src/app.rs` (GUI/Thread wiring).
- Samples: execution-test scripts live under `tests/scripts/`. Compile-only samples stay under `samples/`.

## Build, Test, and Development Commands
- Build (debug): `cargo build`
- Run (release): `cargo run --release` (Recommended for real-time DSP performance)
- Tests: `cargo test`.  Run tests always after modifying code.
- Format: `cargo fmt --all`
- Lint: `cargo clippy -- -D warnings`


## Mandatory End-of-Task Procedure

At the end of EVERY task that modifies code under src/, the agent MUST:

### 1. Run cargo tests
Run tests with full output and backtraces enabled.

```bash
set -o pipefail
( RUST_BACKTRACE=1 cargo test -- --nocapture ) 2>&1 | tee test_report.txt

```

### 2. Record test status

Always write the exit code and timestamp, even if tests fail.

```bash
echo "cargo test exit=$? @ $(date -Iseconds)" > test_status.txt
```

- test_report.txt must contain stdout + stderr of cargo test
- test_status.txt must always exist after a task
- Do NOT skip this step under any circumstances


## Air-Gap Protocol
- In release builds, audio file export is forbidden. Do not add or restore any functionality that writes audio to disk (e.g., WAV export).

## Coding Style & Naming Conventions
- **Comments**:  All comments must be in concise English.  Do not use Japanese in code comments.
- **DSP Efficiency**: Prefer `f32`. Avoid allocations in the audio thread (`worker_loop`). Use `Vec::with_capacity` or pre-allocated ringbuffers.
- **Naming**: `snake_case` for modules/functions, `CamelCase` for structs/traits.

## Testing Policy
- **Inline tests** (`#[cfg(test)] mod tests` in the same source file) are for module-internal logic and private APIs.
- **Integration tests** (`tests/` directory) are for public API and cross-module behavior; treat them as black-box specs.

## Architecture Notes for Agents
- The core perception model is **Landscape**. It ingests audio, transforms it to Log2-frequency space via NSGT, and computes two potentials:
  1. **Roughness (R)**: Amplitude fluctuations within critical bands (dissonance).
  2. **Harmonicity (H)**: Periodicity/Template matching (consonance/fusion).



## Terminology: predictive/perceptual vs potential/state (R/H)

We use two orthogonal axes. Do not mix them.

### Axis A: WorldModel layer (origin)
- **predictive** (`pred_*`): hypothesis derived from IntentBoard / internal model (zero-latency).
- **perceptual** (`perc_*`): evidence derived from actual audio analysis (NSGT/filterbank; delayed).
- **error** (`err_*`): `err_* = perc_* - pred_*`.

`perceptual` is reserved for this axis only.

### Axis B: representation (kernel output vs normalized state)
- **potential** (`*_pot_*`): raw kernel output / physical-ish quantity (unnormalized; references not applied yet).
- **state** (`*_state_*`): normalized / referenced / composed quantities used for decision making or logging
  (e.g. 0..1, and `C = clamp(H01 - wR*R01, -1..1)`).

Potential/state is orthogonal to pred/perc:
- `pred_h_pot_scan`, `pred_h_state01_scan`
- `perc_r_pot_scan`, `perc_c_state_scan`
- `err_c_state_scan = perc_c_state_scan - pred_c_state_scan`

### Suffix convention (avoid ambiguity)
Use explicit suffixes when needed:
- `_scan`: frequency-indexed arrays (Log2Space bins)
- `_scalar`: summary values (total/max/p95 etc.)

Example:
- `perc_r_state01_scalar`
- `pred_c_state_scan`

## Frequency Space: Log2Space invariants

We represent frequency-direction terrains as **Log2Space-aligned scans**.

### Rules
- **F1**: Any vector suffixed with `_scan` MUST be aligned to Log2Space bins:
  `scan.len() == space.n_bins()`.
- **F2**: Any function that accepts/returns a `_scan` MUST assert the invariant at boundaries
  (debug_assert is acceptable; tests must cover it).
- **F3**: Hz / ERB (or other psychoacoustic coordinates) are allowed as internal representations
  (e.g. oscillators, intents, intermediate grids), but any exposed terrain field is converted to
  Log2Space bins.
- **F4**: Candidate evaluation against terrains MUST use log2->bin mapping (interpolation allowed).
  Never index `_scan` with linear-Hz indices.

### Naming
- `_scan`: Log2Space bins terrain vector
- `_hz`: linear frequency array in Hz
- `_erb`: ERB-domain array (psychoacoustic helper)
- `_log2`: log2-frequency coordinate
- `_idx` / `_bin`: bin index into Log2Space scans


## Scenario Script Authoring
**Keep simple things simple, and complex things possible.**

Scenarios should be approachable for newcomers while remaining expressive for advanced use cases:

- A minimal scenario should require only essential parameters
- Complex behaviors emerge from composition, not configuration bloat
- The full parameter space remains accessible for those who need it


## Other
- Don't touch `web/` when editing sourcecode. Don't touch `src/` when editing `web/`, unless otherwise specified.
- `docs/generated`, `docs/schemas`, `docs/rhai-book` are auto-generated by scripts. Don't touch them directly.
</file>

<file path="src/life/world_model.rs">
use std::sync::Arc;

use crate::core::landscape::{LandscapeFrame, LandscapeParams};
use crate::core::log2space::Log2Space;
use crate::core::modulation::NeuralRhythms;
use crate::core::stream::dorsal::DorsalMetrics;
use crate::core::timebase::{Tick, Timebase};
use crate::life::gate_clock::next_gate_tick;
use crate::life::intent::{Intent, IntentBoard};
use crate::life::predictive_spectrum::{
    PredKernelInputs, PredTerrain, build_pred_kernel_inputs_from_intents,
    build_pred_terrain_from_intents,
};
use tracing::debug;

#[derive(Clone, Debug)]
pub struct IntentView {
    pub onset_tick: Tick,
    pub dur_tick: Tick,
    pub freq_hz: f32,
    pub amp: f32,
    pub source_id: u64,
    pub tag: Option<String>,
}

impl From<&Intent> for IntentView {
    fn from(intent: &Intent) -> Self {
        Self {
            onset_tick: intent.onset,
            dur_tick: intent.duration,
            freq_hz: intent.freq_hz,
            amp: intent.amp,
            source_id: intent.source_id,
            tag: intent.tag.clone(),
        }
    }
}

#[derive(Clone, Debug)]
pub struct WorldView {
    pub now_tick: Tick,
    pub fs: f32,
    pub past_ticks: Tick,
    pub future_ticks: Tick,
    pub intents: Vec<IntentView>,
    pub next_gate_tick_est: Option<Tick>,
    pub next_gate_sec_est: Option<f64>,
    pub planned_next_live: Vec<PlannedIntentView>,
    pub planned_last_committed: Vec<PlannedIntentView>,
    pub planned_last_gate_tick: Option<Tick>,
}

impl Default for WorldView {
    fn default() -> Self {
        Self {
            now_tick: 0,
            fs: 0.0,
            past_ticks: 0,
            future_ticks: 0,
            intents: Vec::new(),
            next_gate_tick_est: None,
            next_gate_sec_est: None,
            planned_next_live: Vec::new(),
            planned_last_committed: Vec::new(),
            planned_last_gate_tick: None,
        }
    }
}

#[derive(Clone, Debug)]
pub struct PlannedIntentView {
    pub source_id: u64,
    pub freq_hz: f32,
    pub amp: f32,
    pub confidence: f32,
    pub tag: Option<String>,
}

pub struct WorldModel {
    pub time: Timebase,
    pub space: Log2Space,
    pub now: Tick,
    pub board: IntentBoard,
    pub next_intent_id: u64,
    pub percept_landscape: Option<LandscapeFrame>,
    pub dorsal_metrics: Option<DorsalMetrics>,
    pub pred_params: Option<LandscapeParams>,
    pub next_gate_tick_est: Option<Tick>,
}

impl WorldModel {
    pub fn new(time: Timebase, space: Log2Space) -> Self {
        let retention_past = time.sec_to_tick(2.0);
        let horizon_future = time.sec_to_tick(8.0);
        Self {
            time,
            space,
            now: 0,
            board: IntentBoard::new(retention_past, horizon_future),
            next_intent_id: 0,
            percept_landscape: None,
            dorsal_metrics: None,
            pred_params: None,
            next_gate_tick_est: None,
        }
    }

    pub fn advance_to(&mut self, now_tick: Tick) {
        self.now = now_tick;
        self.board.prune(now_tick);
    }

    pub fn set_pred_params(&mut self, params: LandscapeParams) {
        self.pred_params = Some(params);
    }

    pub fn set_space(&mut self, space: Log2Space) {
        self.space = space;
    }

    pub fn ui_view(&self) -> WorldView {
        let past = self.board.retention_past;
        let future = self.board.horizon_future;
        let intents = self
            .board
            .snapshot(self.now, past, future)
            .iter()
            .map(IntentView::from)
            .collect();
        let next_gate_sec_est = self.next_gate_tick_est.and_then(|tick| {
            if self.time.fs.is_finite() && self.time.fs > 0.0 {
                Some(tick as f64 / self.time.fs as f64)
            } else {
                None
            }
        });
        WorldView {
            now_tick: self.now,
            fs: self.time.fs,
            past_ticks: past,
            future_ticks: future,
            intents,
            next_gate_tick_est: self.next_gate_tick_est,
            next_gate_sec_est,
            planned_next_live: Vec::new(),
            planned_last_committed: Vec::new(),
            planned_last_gate_tick: None,
        }
    }

    pub fn update_gate_from_rhythm(&mut self, now_tick: Tick, rhythm: &NeuralRhythms) {
        self.next_gate_tick_est = next_gate_tick(now_tick, self.time.fs, rhythm.theta, 0.0);
        if self.next_gate_tick_est.is_none() && cfg!(debug_assertions) {
            debug!(
                target: "gate",
                "next_gate_tick_est None: now_tick={} fs={:.3} theta_hz={:.3} theta_phase={:.3}",
                now_tick,
                self.time.fs,
                rhythm.theta.freq_hz,
                rhythm.theta.phase
            );
        }
    }

    pub fn pred_c_next_gate(&self, params: &LandscapeParams) -> Option<Arc<[f32]>> {
        let eval_tick = self.next_gate_tick_est?;
        let intents = self.board.snapshot(
            eval_tick,
            self.board.retention_past,
            self.board.horizon_future,
        );
        let terrain = build_pred_terrain_from_intents(&self.space, params, &intents, eval_tick);
        if terrain.pred_c_statepm1_scan.is_empty() {
            if cfg!(debug_assertions) {
                debug!(target: "pred_c", "pred_c_next_gate empty scan");
            }
            return None;
        }
        Some(Arc::from(terrain.pred_c_statepm1_scan))
    }

    pub fn pred_kernel_inputs_at(&self, eval_tick: Tick) -> PredKernelInputs {
        let intents = self.board.snapshot(
            eval_tick,
            self.board.retention_past,
            self.board.horizon_future,
        );
        build_pred_kernel_inputs_from_intents(&self.space, &intents, eval_tick)
    }

    pub fn pred_terrain_at(&self, eval_tick: Tick) -> Option<PredTerrain> {
        let params = match self.pred_params.as_ref() {
            Some(params) => params,
            None => {
                if cfg!(debug_assertions) {
                    debug!(target: "pred_c", "pred_terrain missing pred_params");
                }
                return None;
            }
        };
        let intents = self.board.snapshot(
            eval_tick,
            self.board.retention_past,
            self.board.horizon_future,
        );
        let terrain = build_pred_terrain_from_intents(&self.space, params, &intents, eval_tick);
        if cfg!(debug_assertions) && terrain.pred_c_statepm1_scan.is_empty() {
            debug!(target: "pred_c", "pred_terrain empty scan");
        }
        Some(terrain)
    }

    pub fn pred_c_statepm1_scan_at(&self, eval_tick: Tick) -> Vec<f32> {
        let scan = self
            .pred_terrain_at(eval_tick)
            .map(|terrain| terrain.pred_c_statepm1_scan)
            .unwrap_or_default();
        if cfg!(debug_assertions) {
            let non_finite = scan.iter().filter(|v| !v.is_finite()).count();
            if non_finite > 0 {
                debug!(
                    target: "pred_c",
                    "pred_c_scan non_finite={} len={} eval_tick={}",
                    non_finite,
                    scan.len(),
                    eval_tick
                );
            }
        }
        scan
    }

    pub fn apply_action(&mut self, action: &crate::life::scenario::Action) {
        if let crate::life::scenario::Action::PostIntent {
            source_id,
            onset_sec,
            duration_sec,
            freq_hz,
            amp,
            tag,
            confidence,
        } = action
        {
            let onset_tick = self.time.sec_to_tick(onset_sec.max(0.0));
            let mut dur_tick = self.time.sec_to_tick(duration_sec.max(0.0));
            if dur_tick == 0 && *duration_sec > 0.0 {
                dur_tick = 1;
            }
            let intent = Intent {
                source_id: *source_id,
                intent_id: self.next_intent_id,
                onset: onset_tick,
                duration: dur_tick,
                freq_hz: *freq_hz,
                amp: *amp,
                tag: tag.clone(),
                confidence: *confidence,
                body: None,
                articulation: None,
            };
            self.next_intent_id = self.next_intent_id.wrapping_add(1);
            self.board.publish(intent);
        }
    }
}
</file>

<file path="src/life/mod.rs">
pub mod api;
pub mod conductor;
pub mod control;
pub mod gate_clock;
pub mod individual;
pub mod intent;
pub mod lifecycle;
pub mod meta;
pub mod perceptual;
pub mod phonation_engine;
pub mod population;
pub mod predictive_spectrum;
pub mod scenario;
pub mod schedule_renderer;
pub mod scripting;
pub mod social_density;
pub mod world_model;

pub mod sound;
#[cfg(test)]
mod tests;
#[cfg(test)]
mod tests_organic;
</file>

<file path="tests/agent_intents.rs">
use conchordal::core::landscape::Landscape;
use conchordal::core::log2space::Log2Space;
use conchordal::core::timebase::{Tick, Timebase};
use conchordal::life::control::AgentControl;
use conchordal::life::individual::AgentMetadata;
use conchordal::life::population::Population;
use conchordal::life::scenario::IndividualConfig;
use conchordal::life::schedule_renderer::ScheduleRenderer;
use conchordal::life::world_model::WorldModel;

#[test]
fn agents_publish_intents_and_render_audio() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let space = Log2Space::new(55.0, 8000.0, 96);
    let mut world = WorldModel::new(tb, space.clone());
    let mut pop = Population::new(tb);
    let mut control = AgentControl::default();
    control.pitch.freq = 440.0;
    control.body.amp = 0.4;
    control.phonation.density = 0.8;
    let agent_cfg = IndividualConfig { control, tag: None };
    let metadata = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let agent = agent_cfg.spawn(1, 0, metadata.clone(), tb.fs, 0);
    pop.add_individual(agent);

    let mut landscape = Landscape::new(space.clone());
    landscape.rhythm.theta.freq_hz = 6.0;
    landscape.rhythm.theta.phase = -0.01;
    landscape.rhythm.env_open = 1.0;
    landscape.rhythm.env_level = 1.0;

    let hop = tb.hop as Tick;
    let mut phonation_batches = Vec::new();
    let mut render_now: Tick = 0;
    let mut now: Tick = 0;
    for _ in 0..300 {
        let batches = pop.publish_intents(&mut world, &landscape, now);
        if !batches.is_empty() {
            phonation_batches = batches;
            render_now = now;
            break;
        }
        now = now.saturating_add(hop);
    }
    assert!(!phonation_batches.is_empty());
    let mut renderer = ScheduleRenderer::new(tb);
    let rhythms = landscape.rhythm;
    let out = renderer.render(
        &world.board,
        &phonation_batches,
        render_now,
        &rhythms,
        &[],
        &[],
    );
    assert!(out.iter().any(|s| s.abs() > 1e-6));
}

#[test]
fn publish_intents_runs_when_gate_in_hop_window() {
    let tb = Timebase {
        fs: 48_000.0,
        hop: 64,
    };
    let space = Log2Space::new(55.0, 8000.0, 96);
    let mut world = WorldModel::new(tb, space.clone());
    let mut pop = Population::new(tb);
    let mut control = AgentControl::default();
    control.pitch.freq = 440.0;
    control.body.amp = 0.4;
    control.phonation.density = 0.8;
    let agent_cfg = IndividualConfig { control, tag: None };
    let metadata = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let agent = agent_cfg.spawn(1, 0, metadata.clone(), tb.fs, 0);
    pop.add_individual(agent);

    let space = Log2Space::new(20.0, 20_000.0, 24);
    let mut landscape = Landscape::new(space.clone());
    landscape.rhythm.theta.freq_hz = 6.0;
    landscape.rhythm.theta.phase = -0.01;
    landscape.rhythm.env_open = 1.0;
    landscape.rhythm.env_level = 1.0;

    let hop = tb.hop as Tick;
    let mut now: Tick = 0;
    let mut batches = Vec::new();
    for _ in 0..300 {
        let next = pop.publish_intents(&mut world, &landscape, now);
        if !next.is_empty() {
            batches = next;
            break;
        }
        now = now.saturating_add(hop);
    }
    assert!(!batches.is_empty());

    let mut landscape_off = Landscape::new(space);
    landscape_off.rhythm.theta.freq_hz = 1.0;
    landscape_off.rhythm.theta.phase = 0.0;
    landscape_off.rhythm.env_open = 1.0;
    landscape_off.rhythm.env_level = 1.0;
    let mut world_off = WorldModel::new(tb, Log2Space::new(20.0, 20_000.0, 24));
    let mut pop_off = Population::new(tb);
    let agent = agent_cfg.spawn(1, 0, metadata, tb.fs, 0);
    pop_off.add_individual(agent);
    let batches_off = pop_off.publish_intents(&mut world_off, &landscape_off, now);
    assert!(batches_off.is_empty());
}
</file>

<file path="src/life/schedule_renderer.rs">
use crate::core::modulation::NeuralRhythms;
use crate::core::timebase::{Tick, Timebase};
use crate::life::individual::PhonationBatch;
use crate::life::intent::{Intent, IntentBoard};
use crate::life::phonation_engine::PhonationCmd;
use crate::life::sound::{AudioCommand, Voice, VoiceTarget, default_release_ticks};
use std::collections::{HashMap, HashSet};
use tracing::debug;

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
enum VoiceKind {
    Intent,
    Phonation,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
struct VoiceKey {
    source_id: u64,
    note_id: u64,
    kind: VoiceKind,
}

pub struct ScheduleRenderer {
    time: Timebase,
    buf: Vec<f32>,
    voices: HashMap<VoiceKey, Voice>,
    agent_voices: HashMap<u64, Voice>,
    add_future_ticks: Tick,
    add_past_ticks: Tick,
    did_full_resync: bool,
    cutoff_tick: Option<Tick>,
    agent_ids_scratch: HashSet<u64>,
}

pub type SoundRenderer = ScheduleRenderer;

impl ScheduleRenderer {
    pub fn new(time: Timebase) -> Self {
        let add_future_ticks = (time.hop as Tick).saturating_mul(4).max(1);
        let add_past_ticks = schedule_add_past_ticks(time);
        Self {
            time,
            buf: vec![0.0; time.hop],
            voices: HashMap::new(),
            agent_voices: HashMap::new(),
            add_future_ticks,
            add_past_ticks,
            did_full_resync: false,
            cutoff_tick: None,
            agent_ids_scratch: HashSet::new(),
        }
    }

    pub fn render(
        &mut self,
        board: &IntentBoard,
        phonation_batches: &[PhonationBatch],
        now: Tick,
        rhythms: &NeuralRhythms,
        voice_targets: &[VoiceTarget],
        audio_cmds: &[AudioCommand],
    ) -> &[f32] {
        let hop = self.time.hop;
        if self.buf.len() != hop {
            self.buf.resize(hop, 0.0);
        }
        self.buf.fill(0.0);

        let fs = self.time.fs;
        if fs <= 0.0 {
            return &self.buf;
        }

        self.agent_ids_scratch.clear();
        self.agent_ids_scratch.reserve(voice_targets.len());
        for state in voice_targets {
            self.agent_ids_scratch.insert(state.id);
        }
        for (id, voice) in self.agent_voices.iter_mut() {
            if !self.agent_ids_scratch.contains(id) {
                voice.note_off(now);
            }
        }
        self.agent_voices
            .retain(|id, voice| self.agent_ids_scratch.contains(id) || !voice.is_done(now));
        self.voices.retain(|_, voice| !voice.is_done(now));

        let past = if self.did_full_resync {
            board.retention_past.min(self.add_past_ticks)
        } else {
            self.did_full_resync = true;
            board.retention_past
        };
        let future = board.horizon_future.min(self.add_future_ticks);
        // Order is intentional: enqueue new voices first, then kick+render for this tick.
        // This assumes add_voice_if_needed accepts onset<=now so same-tick onsets are available.
        for intent in board.snapshot(now, past, future) {
            if let Some(cutoff) = self.cutoff_tick
                && intent.onset >= cutoff
            {
                continue;
            }
            self.add_voice_if_needed(intent, now);
        }
        for cmd in audio_cmds {
            if let AudioCommand::EnsureVoice {
                id,
                body,
                pitch_hz,
                amp,
            } = cmd
            {
                if !self.agent_ids_scratch.contains(id) {
                    continue;
                }
                if self.agent_voices.contains_key(id) {
                    continue;
                }
                let intent = Intent {
                    source_id: *id,
                    intent_id: 0,
                    onset: now,
                    duration: Tick::MAX,
                    freq_hz: *pitch_hz,
                    amp: *amp,
                    tag: None,
                    confidence: 1.0,
                    body: Some(body.clone()),
                    articulation: None,
                };
                if let Some(voice) = Voice::from_intent(self.time, intent) {
                    self.agent_voices.insert(*id, voice);
                }
            }
        }
        for state in voice_targets {
            if let Some(voice) = self.agent_voices.get_mut(&state.id) {
                voice.set_target(state.pitch_hz, state.amp, 0.0);
            }
        }
        for cmd in audio_cmds {
            if let AudioCommand::Impulse { id, energy } = cmd {
                if !self.agent_ids_scratch.contains(id) {
                    continue;
                }
                if let Some(voice) = self.agent_voices.get_mut(id) {
                    voice.trigger_impulse(*energy);
                }
            }
        }

        let end = now.saturating_add(hop as Tick);
        let dt = 1.0 / fs;
        let mut rhythms = *rhythms;
        self.apply_phonation_batches(phonation_batches, now, &rhythms, dt);
        // For each tick: apply due updates, then render the sample.
        for tick in now..end {
            let idx = (tick - now) as usize;
            let mut acc = 0.0f32;
            for (_key, voice) in self.voices.iter_mut() {
                voice.apply_updates_if_due(tick);
                voice.kick_planned_if_due(tick, &rhythms, dt);
                acc += voice.render_tick(tick, fs, dt, &rhythms);
            }
            for voice in self.agent_voices.values_mut() {
                voice.apply_updates_if_due(tick);
                voice.kick_planned_if_due(tick, &rhythms, dt);
                acc += voice.render_tick(tick, fs, dt, &rhythms);
            }
            self.buf[idx] = acc;
            rhythms.advance_in_place(dt);
        }

        self.apply_limiter();
        &self.buf
    }

    pub fn is_idle(&self) -> bool {
        self.voices.is_empty() && self.agent_voices.is_empty()
    }

    pub fn set_cutoff_tick(&mut self, cutoff: Option<Tick>) {
        self.cutoff_tick = cutoff;
    }

    pub fn shutdown_at(&mut self, tick: Tick) {
        self.cutoff_tick = Some(tick);
        self.voices.retain(|_, voice| voice.onset() <= tick);
        for voice in self.voices.values_mut() {
            voice.note_off(tick);
        }
        self.agent_voices.retain(|_, voice| voice.onset() <= tick);
        for voice in self.agent_voices.values_mut() {
            voice.note_off(tick);
        }
    }

    fn add_voice_if_needed(&mut self, intent: Intent, now: Tick) {
        if intent.duration == 0 || intent.freq_hz <= 0.0 {
            return;
        }
        if intent.amp == 0.0 {
            return;
        }
        let end_tick = intent
            .onset
            .saturating_add(intent.duration)
            .saturating_add(default_release_ticks(self.time));
        if end_tick <= now {
            return;
        }
        let key = VoiceKey {
            source_id: intent.source_id,
            note_id: intent.intent_id,
            kind: VoiceKind::Intent,
        };
        if self.voices.contains_key(&key) {
            return;
        }
        let onset = intent.onset;
        if let Some(mut voice) = Voice::from_intent(self.time, intent) {
            voice.note_on(onset);
            voice.arm_onset_trigger(1.0);
            self.voices.insert(key, voice);
        }
    }

    fn apply_phonation_batches(
        &mut self,
        phonation_batches: &[PhonationBatch],
        now: Tick,
        _rhythms: &NeuralRhythms,
        _dt: f32,
    ) {
        let default_hold_ticks = max_phonation_hold_ticks(self.time);
        for batch in phonation_batches {
            for cmd in &batch.cmds {
                match *cmd {
                    PhonationCmd::NoteOn { note_id, kick } => {
                        let key = VoiceKey {
                            source_id: batch.source_id,
                            note_id,
                            kind: VoiceKind::Phonation,
                        };
                        if self.voices.contains_key(&key) {
                            continue;
                        }
                        let spec = batch.notes.iter().find(|note| note.note_id == note_id);
                        let Some(spec) = spec else { continue };
                        if let Some(cutoff) = self.cutoff_tick
                            && spec.onset >= cutoff
                        {
                            continue;
                        }
                        let hold_ticks = spec.hold_ticks.unwrap_or(default_hold_ticks);
                        let intent = Intent {
                            source_id: batch.source_id,
                            intent_id: note_id,
                            onset: spec.onset,
                            duration: hold_ticks,
                            freq_hz: spec.freq_hz,
                            amp: spec.amp,
                            tag: None,
                            confidence: 1.0,
                            body: Some(spec.body.clone()),
                            articulation: Some(spec.articulation.clone()),
                        };
                        if let Some(mut voice) = Voice::from_intent(self.time, intent) {
                            voice.set_smoothing_tau_sec(spec.smoothing_tau_sec);
                            voice.note_on(spec.onset);
                            voice.schedule_planned_kick(kick);
                            voice.arm_onset_trigger(kick.strength().max(0.0));
                            debug!(
                                target: "phonation::note_on",
                                source_id = batch.source_id,
                                note_id,
                                onset = spec.onset,
                                freq_hz = spec.freq_hz,
                                amp = spec.amp
                            );
                            self.voices.insert(key, voice);
                        }
                    }
                    PhonationCmd::NoteOff { note_id, off_tick } => {
                        let key = VoiceKey {
                            source_id: batch.source_id,
                            note_id,
                            kind: VoiceKind::Phonation,
                        };
                        if let Some(voice) = self.voices.get_mut(&key) {
                            voice.note_off(off_tick);
                        }
                    }
                    PhonationCmd::Update { .. } => {}
                }
            }
            for cmd in &batch.cmds {
                let PhonationCmd::Update {
                    note_id,
                    at_tick,
                    update,
                } = *cmd
                else {
                    continue;
                };
                let key = VoiceKey {
                    source_id: batch.source_id,
                    note_id,
                    kind: VoiceKind::Phonation,
                };
                let Some(voice) = self.voices.get_mut(&key) else {
                    continue;
                };
                let tick = at_tick.unwrap_or(now);
                voice.schedule_update(tick, update);
            }
        }
    }

    fn apply_limiter(&mut self) {
        let mut peak = 0.0f32;
        for &s in &self.buf {
            if s.is_finite() {
                peak = peak.max(s.abs());
            }
        }
        let target = 0.98f32;
        if peak > target && peak > 0.0 {
            let g = target / peak;
            if g.is_finite() {
                for s in &mut self.buf {
                    *s *= g;
                }
            }
        }
    }
}

fn schedule_add_past_ticks(time: Timebase) -> Tick {
    let hop_window = (time.hop as Tick).saturating_mul(2);
    default_release_ticks(time).max(hop_window).max(1)
}

fn max_phonation_hold_ticks(time: Timebase) -> Tick {
    let max_sec = 60.0;
    let ticks = time.sec_to_tick(max_sec);
    ticks.max(1)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::life::individual::{
        AnyArticulationCore, ArticulationWrapper, PhonationBatch, PhonationNoteSpec, SequencedCore,
    };
    use crate::life::intent::BodySnapshot;
    use crate::life::phonation_engine::{PhonationKick, PhonationUpdate};
    use crate::life::sound::{AudioCommand, VoiceTarget, default_release_ticks};

    #[test]
    fn update_command_applies_to_voice() {
        let tb = Timebase { fs: 1000.0, hop: 4 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let board = IntentBoard::new(1, 1);
        let articulation = ArticulationWrapper::new(
            AnyArticulationCore::Seq(SequencedCore {
                timer: 0.0,
                duration: 0.1,
                env_level: 0.0,
            }),
            0.0,
        );
        let note_id = 1;
        let batch = PhonationBatch {
            source_id: 2,
            cmds: vec![
                PhonationCmd::Update {
                    note_id,
                    at_tick: Some(0),
                    update: PhonationUpdate {
                        target_freq_hz: Some(440.0),
                        target_amp: Some(0.25),
                    },
                },
                PhonationCmd::NoteOn {
                    note_id,
                    kick: PhonationKick::Planned { strength: 1.0 },
                },
            ],
            notes: vec![PhonationNoteSpec {
                note_id,
                onset: 0,
                hold_ticks: Some(8),
                freq_hz: 220.0,
                amp: 0.5,
                smoothing_tau_sec: 0.0,
                body: BodySnapshot {
                    kind: "sine".to_string(),
                    amp_scale: 1.0,
                    brightness: 0.0,
                    noise_mix: 0.0,
                },
                articulation,
            }],
            onsets: Vec::new(),
        };
        renderer.render(&board, &[batch], 0, &rhythms, &[], &[]);

        let key = VoiceKey {
            source_id: 2,
            note_id,
            kind: VoiceKind::Phonation,
        };
        let voice = renderer.voices.get(&key).expect("voice");
        assert!((voice.debug_current_freq_hz() - 440.0).abs() < 1e-6);
        assert!((voice.debug_current_amp() - 0.25).abs() < 1e-6);
    }

    #[test]
    fn update_commands_same_tick_last_wins() {
        let tb = Timebase { fs: 1000.0, hop: 4 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let board = IntentBoard::new(1, 1);
        let articulation = ArticulationWrapper::new(
            AnyArticulationCore::Seq(SequencedCore {
                timer: 0.0,
                duration: 0.1,
                env_level: 0.0,
            }),
            0.0,
        );
        let note_id = 1;
        let batch = PhonationBatch {
            source_id: 2,
            cmds: vec![
                PhonationCmd::Update {
                    note_id,
                    at_tick: Some(0),
                    update: PhonationUpdate {
                        target_freq_hz: Some(330.0),
                        target_amp: None,
                    },
                },
                // Same-tick updates are applied in command order; later update wins.
                PhonationCmd::Update {
                    note_id,
                    at_tick: Some(0),
                    update: PhonationUpdate {
                        target_freq_hz: Some(440.0),
                        target_amp: None,
                    },
                },
                PhonationCmd::NoteOn {
                    note_id,
                    kick: PhonationKick::Planned { strength: 1.0 },
                },
            ],
            notes: vec![PhonationNoteSpec {
                note_id,
                onset: 0,
                hold_ticks: Some(8),
                freq_hz: 220.0,
                amp: 0.5,
                smoothing_tau_sec: 0.0,
                body: BodySnapshot {
                    kind: "sine".to_string(),
                    amp_scale: 1.0,
                    brightness: 0.0,
                    noise_mix: 0.0,
                },
                articulation,
            }],
            onsets: Vec::new(),
        };
        renderer.render(&board, &[batch], 0, &rhythms, &[], &[]);

        let key = VoiceKey {
            source_id: 2,
            note_id,
            kind: VoiceKind::Phonation,
        };
        let voice = renderer.voices.get(&key).expect("voice");
        assert!((voice.debug_target_freq_hz() - 440.0).abs() < 1e-6);
    }

    #[test]
    fn ensure_voice_without_impulse_is_silent() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "sine".to_string(),
            amp_scale: 1.0,
            brightness: 0.0,
            noise_mix: 0.0,
        };
        let voice_targets = [VoiceTarget {
            id: 11,
            pitch_hz: 220.0,
            amp: 0.4,
        }];
        let cmds = [AudioCommand::EnsureVoice {
            id: 11,
            body,
            pitch_hz: 220.0,
            amp: 0.4,
        }];
        let out = renderer.render(
            &IntentBoard::new(0, 0),
            &[],
            0,
            &rhythms,
            &voice_targets,
            &cmds,
        );
        assert!(out.iter().all(|s| s.abs() <= 1e-6));
    }

    #[test]
    fn ensure_voice_then_impulse_emits_audio() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "harmonic".to_string(),
            amp_scale: 1.0,
            brightness: 0.6,
            noise_mix: 0.2,
        };
        let voice_targets = [VoiceTarget {
            id: 12,
            pitch_hz: 220.0,
            amp: 0.4,
        }];
        let cmds = [
            AudioCommand::EnsureVoice {
                id: 12,
                body,
                pitch_hz: 220.0,
                amp: 0.4,
            },
            AudioCommand::Impulse {
                id: 12,
                energy: 1.0,
            },
        ];
        let out = renderer.render(
            &IntentBoard::new(0, 0),
            &[],
            0,
            &rhythms,
            &voice_targets,
            &cmds,
        );
        assert!(out.iter().any(|s| s.abs() > 1e-6));
    }

    #[test]
    fn impulse_unknown_id_is_silent() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let cmds = [AudioCommand::Impulse {
            id: 99,
            energy: 1.0,
        }];
        let out = renderer.render(&IntentBoard::new(0, 0), &[], 0, &rhythms, &[], &cmds);
        assert!(out.iter().all(|s| s.abs() <= 1e-6));
    }

    #[test]
    fn ensure_voice_for_unknown_id_is_silent_and_not_created() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "sine".to_string(),
            amp_scale: 1.0,
            brightness: 0.0,
            noise_mix: 0.0,
        };
        let cmds = [
            AudioCommand::EnsureVoice {
                id: 21,
                body,
                pitch_hz: 220.0,
                amp: 0.4,
            },
            AudioCommand::Impulse {
                id: 21,
                energy: 1.0,
            },
        ];
        let out = renderer.render(&IntentBoard::new(0, 0), &[], 0, &rhythms, &[], &cmds);
        assert!(out.iter().all(|s| s.abs() <= 1e-6));
        assert!(renderer.agent_voices.is_empty());
    }

    #[test]
    fn impulse_before_ensure_voice_still_emits_audio() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "sine".to_string(),
            amp_scale: 1.0,
            brightness: 0.0,
            noise_mix: 0.0,
        };
        let voice_targets = [VoiceTarget {
            id: 13,
            pitch_hz: 220.0,
            amp: 0.4,
        }];
        let cmds = [
            AudioCommand::Impulse {
                id: 13,
                energy: 1.0,
            },
            AudioCommand::EnsureVoice {
                id: 13,
                body,
                pitch_hz: 220.0,
                amp: 0.4,
            },
        ];
        let out = renderer.render(
            &IntentBoard::new(0, 0),
            &[],
            0,
            &rhythms,
            &voice_targets,
            &cmds,
        );
        assert!(out.iter().any(|s| s.abs() > 1e-6));
    }

    #[test]
    fn ensure_voice_is_idempotent() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "harmonic".to_string(),
            amp_scale: 1.0,
            brightness: 0.7,
            noise_mix: 0.2,
        };
        let voice_targets = [VoiceTarget {
            id: 14,
            pitch_hz: 220.0,
            amp: 0.4,
        }];
        let cmds = [
            AudioCommand::EnsureVoice {
                id: 14,
                body: body.clone(),
                pitch_hz: 220.0,
                amp: 0.4,
            },
            AudioCommand::EnsureVoice {
                id: 14,
                body,
                pitch_hz: 220.0,
                amp: 0.4,
            },
            AudioCommand::Impulse {
                id: 14,
                energy: 1.0,
            },
        ];
        let out = renderer
            .render(
                &IntentBoard::new(0, 0),
                &[],
                0,
                &rhythms,
                &voice_targets,
                &cmds,
            )
            .to_vec();
        assert_eq!(renderer.agent_voices.len(), 1);
        assert!(out.iter().any(|s| s.abs() > 1e-6));
    }

    #[test]
    fn ensure_voice_created_in_same_render_receives_target_update() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "sine".to_string(),
            amp_scale: 1.0,
            brightness: 0.0,
            noise_mix: 0.0,
        };
        let voice_targets = [VoiceTarget {
            id: 16,
            pitch_hz: 440.0,
            amp: 0.8,
        }];
        let cmds = [AudioCommand::EnsureVoice {
            id: 16,
            body,
            pitch_hz: 110.0,
            amp: 0.1,
        }];
        let _ = renderer
            .render(
                &IntentBoard::new(0, 0),
                &[],
                0,
                &rhythms,
                &voice_targets,
                &cmds,
            )
            .to_vec();
        let voice = renderer.agent_voices.get(&16).expect("voice");
        assert!((voice.debug_target_freq_hz() - 440.0).abs() < 1e-6);
        assert!((voice.debug_target_amp() - 0.8).abs() < 1e-6);
    }

    #[test]
    fn shutdown_releases_agent_voice_and_becomes_idle() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "sine".to_string(),
            amp_scale: 1.0,
            brightness: 0.0,
            noise_mix: 0.0,
        };
        let voice_targets = [VoiceTarget {
            id: 15,
            pitch_hz: 220.0,
            amp: 0.4,
        }];
        let cmds = [
            AudioCommand::EnsureVoice {
                id: 15,
                body,
                pitch_hz: 220.0,
                amp: 0.4,
            },
            AudioCommand::Impulse {
                id: 15,
                energy: 1.0,
            },
        ];
        renderer.render(
            &IntentBoard::new(0, 0),
            &[],
            0,
            &rhythms,
            &voice_targets,
            &cmds,
        );
        renderer.shutdown_at(0);
        let now = default_release_ticks(tb) + 2;
        renderer.render(&IntentBoard::new(0, 0), &[], now, &rhythms, &[], &[]);
        assert!(renderer.is_idle());
    }

    #[test]
    fn agent_voice_releases_after_agent_disappears() {
        let tb = Timebase { fs: 1000.0, hop: 8 };
        let mut renderer = ScheduleRenderer::new(tb);
        let rhythms = NeuralRhythms::default();
        let body = BodySnapshot {
            kind: "sine".to_string(),
            amp_scale: 1.0,
            brightness: 0.0,
            noise_mix: 0.0,
        };
        let voice_targets = [VoiceTarget {
            id: 22,
            pitch_hz: 220.0,
            amp: 0.4,
        }];
        let cmds = [
            AudioCommand::EnsureVoice {
                id: 22,
                body,
                pitch_hz: 220.0,
                amp: 0.4,
            },
            AudioCommand::Impulse {
                id: 22,
                energy: 1.0,
            },
        ];
        renderer.render(
            &IntentBoard::new(0, 0),
            &[],
            0,
            &rhythms,
            &voice_targets,
            &cmds,
        );
        let now = tb.hop as Tick;
        renderer.render(&IntentBoard::new(0, 0), &[], now, &rhythms, &[], &[]);
        assert_eq!(renderer.agent_voices.len(), 1);
        let done_at = now.saturating_add(default_release_ticks(tb) + 2);
        renderer.render(&IntentBoard::new(0, 0), &[], done_at, &rhythms, &[], &[]);
        assert!(renderer.is_idle());
    }
}
</file>

<file path="src/life/tests.rs">
use super::conductor::Conductor;
use super::individual::{
    AgentMetadata, ArticulationCore, ArticulationSignal, ArticulationState, KuramotoCore,
    PhonationBatch, PinkNoise, PitchCore, Sensitivity, SequencedCore, SoundBody,
};
use super::population::Population;
use super::scenario::{
    Action, ArticulationCoreConfig, EnvelopeConfig, IndividualConfig, PhonationConnectConfig,
    PitchCoreConfig, Scenario, SceneMarker, SpawnMethod, SpawnOpts, TimedEvent,
};
use crate::core::landscape::Landscape;
use crate::core::landscape::LandscapeFrame;
use crate::core::log2space::Log2Space;
use crate::core::modulation::{NeuralRhythms, RhythmBand};
use crate::core::timebase::{Tick, Timebase};
use crate::life::control::{AgentControl, BodyMethod, PhonationType, PitchMode};
use crate::life::lifecycle::LifecycleConfig;
use crate::life::perceptual::{FeaturesNow, PerceptualConfig, PerceptualContext};
use crate::life::phonation_engine::PhonationCmd;
use rand::SeedableRng;
use serde_json;

fn mix_signature(mut acc: u64, value: u32) -> u64 {
    acc ^= value as u64;
    acc = acc.wrapping_mul(0x9E37_79B9_7F4A_7C15);
    acc
}

fn control_with_pitch(freq: f32) -> AgentControl {
    let mut control = AgentControl::default();
    control.pitch.freq = freq.max(1.0);
    control
}

fn test_timebase() -> Timebase {
    Timebase {
        fs: 48_000.0,
        hop: 64,
    }
}

fn collect_hold_events(control: AgentControl, steps: usize) -> Vec<(usize, usize)> {
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    let tb = test_timebase();
    let mut rhythms = NeuralRhythms::default();
    let mut batch = PhonationBatch::default();
    let mut now: Tick = 0;
    let mut events = Vec::with_capacity(steps);
    for _ in 0..steps {
        agent.tick_phonation_into(&tb, now, &rhythms, None, 0.0, &mut batch);
        let note_on = batch
            .cmds
            .iter()
            .filter(|cmd| matches!(cmd, PhonationCmd::NoteOn { .. }))
            .count();
        let note_off = batch
            .cmds
            .iter()
            .filter(|cmd| matches!(cmd, PhonationCmd::NoteOff { .. }))
            .count();
        events.push((note_on, note_off));
        now = now.saturating_add(tb.hop as Tick);
        rhythms.advance_in_place(tb.hop as f32 / tb.fs);
    }
    events
}

#[test]
fn test_population_add_remove_agent() {
    // 1. Setup
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();

    assert_eq!(pop.individuals.len(), 0, "Population should start empty");

    // 2. Add Agent
    pop.apply_action(
        Action::Spawn {
            tag: "test_agent".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 440.0 }
            }),
        },
        &landscape,
        None,
    );
    assert_eq!(pop.individuals.len(), 1, "Agent should be added");

    // 3. Remove Agent
    pop.apply_action(
        Action::Remove {
            target: "test_agent".to_string(),
        },
        &landscape,
        None,
    );
    let fs = test_timebase().fs;
    let dt = 0.1;
    let samples_per_hop = (fs * dt) as usize;
    let landscape_rt = make_test_landscape(fs);
    pop.advance(samples_per_hop, fs, 0, dt, &landscape_rt);
    pop.process_frame(0, &landscape_rt.space, dt, false);
    assert_eq!(pop.individuals.len(), 0, "Agent should be removed");
}

#[test]
fn tag_selector_removes_matching_agents() {
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();

    pop.apply_action(
        Action::Spawn {
            tag: "test_group".to_string(),
            count: 2,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 330.0 }
            }),
        },
        &landscape,
        None,
    );
    assert_eq!(pop.individuals.len(), 2);

    pop.apply_action(
        Action::Remove {
            target: "test_group".to_string(),
        },
        &landscape,
        None,
    );
    let fs = test_timebase().fs;
    let dt = 0.1;
    let samples_per_hop = (fs * dt) as usize;
    let landscape_rt = make_test_landscape(fs);
    pop.advance(samples_per_hop, fs, 0, dt, &landscape_rt);
    pop.process_frame(0, &landscape_rt.space, dt, false);
    assert_eq!(
        pop.individuals.len(),
        0,
        "Tag selector should remove both agents"
    );
}

#[test]
fn test_conductor_timing() {
    // 1. Create a Scenario with an event at T=1.0s
    let action = Action::Finish; // Simple marker action
    let event = TimedEvent {
        time: 1.0,
        order: 1,
        actions: vec![action],
    };
    let scenario = Scenario {
        seed: 0,
        scene_markers: vec![SceneMarker {
            name: "test".into(),
            time: 0.0,
            order: 0,
        }],
        events: vec![event],
        duration_sec: 2.0,
    };

    let mut conductor = Conductor::from_scenario(scenario);
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();
    let space = Log2Space::new(1.0, 2.0, 1);
    let mut world = crate::life::world_model::WorldModel::new(
        crate::core::timebase::Timebase {
            fs: 48_000.0,
            hop: 512,
        },
        space,
    );

    // 2. Dispatch at T=0.5 (Should NOT fire)
    conductor.dispatch_until(
        0.5,
        0,
        &landscape,
        None::<&mut crate::core::stream::roughness::RoughnessStream>,
        &mut pop,
        &mut world,
    );
    assert!(
        !pop.abort_requested,
        "Finish action should not fire yet at T=0.5"
    );

    // 3. Dispatch at T=1.1 (Should fire)
    conductor.dispatch_until(
        1.1,
        100,
        &landscape,
        None::<&mut crate::core::stream::roughness::RoughnessStream>,
        &mut pop,
        &mut world,
    );
    assert!(pop.abort_requested, "Finish action should fire at T=1.1");
}

fn make_test_landscape(_fs: f32) -> Landscape {
    let space = Log2Space::new(55.0, 4000.0, 64);
    Landscape::new(space)
}

#[test]
fn test_agent_lifecycle_decay_death() {
    // 1. Setup Population with 1 agent that has a very short half-life
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default(); // Dummy landscape

    let fs = 48_000.0;
    pop.apply_action(
        Action::Spawn {
            tag: "decay".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 440.0 }
            }),
        },
        &landscape,
        None,
    );
    let fs = 48_000.0;
    {
        let agent = pop.individuals.first_mut().expect("agent exists");
        let core_cfg = ArticulationCoreConfig::Entrain {
            lifecycle: LifecycleConfig::Decay {
                initial_energy: 1.0,
                half_life_sec: 0.05,
                attack_sec: 0.001,
            },
            rhythm_freq: None,
            rhythm_sensitivity: None,
            breath_gain_init: None,
        };
        let mut rng = rand::rngs::StdRng::seed_from_u64(7);
        let core = super::individual::AnyArticulationCore::from_config(&core_cfg, fs, 1, &mut rng);
        agent.articulation = super::individual::ArticulationWrapper::new(core, 1.0);
    }

    assert_eq!(pop.individuals.len(), 1, "Agent added");

    // 2. Simulate time passing via process_frame
    // We need to run enough frames for energy to drop below threshold (1e-4)
    // Energy starts at 1.0.
    // After 0.05s -> 0.5
    // After 0.10s -> 0.25
    // ...
    // After 1.0s -> ~0.0
    let dt = 0.01; // 10ms steps
    let samples_per_hop = (fs * dt) as usize;
    let landscape_rt = make_test_landscape(fs);
    let mut time = 0.0;

    // Run for 1.0 second (should be plenty for 0.05s half-life to die)
    for i in 0..100 {
        pop.advance(samples_per_hop, fs, i, dt, &landscape_rt);
        pop.process_frame(i, &landscape_rt.space, dt, false);
        time += dt;
    }

    // 3. Verify agent is cleaned up
    assert_eq!(
        pop.individuals.len(),
        0,
        "Agent should have died due to energy decay after {:.2}s",
        time
    );
}

#[test]
fn lock_mode_still_advances_release_gain() {
    let fs = 48_000.0;
    let mut pop = Population::new(test_timebase());
    pop.apply_action(
        Action::Spawn {
            tag: "silent".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": {
                    "freq": 440.0,
                    "range_oct": 0.0,
                    "mode": "lock"
                }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );
    let agent = pop.individuals.first_mut().expect("agent exists");
    agent.start_remove_fade(0.05);
    let gain_before = agent.release_gain();

    let dt = 0.01;
    let samples_per_hop = (fs * dt) as usize;
    let landscape = make_test_landscape(fs);
    pop.advance(samples_per_hop, fs, 0, dt, &landscape);

    let gain_after = pop.individuals[0].release_gain();
    assert!(gain_after < gain_before);
}

#[test]
fn lock_mode_keeps_pitch_and_target() {
    let fs = 48_000.0;
    let mut pop = Population::new(test_timebase());
    pop.apply_action(
        Action::Spawn {
            tag: "silent".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": {
                    "freq": 440.0,
                    "range_oct": 0.0,
                    "mode": "lock"
                }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );

    let (freq_before, target_before) = {
        let agent = pop.individuals.first().expect("agent exists");
        (agent.body.base_freq_hz(), agent.target_pitch_log2())
    };

    let dt = 0.01;
    let samples_per_hop = (fs * dt) as usize;
    let landscape = make_test_landscape(fs);
    for i in 0..50 {
        pop.advance(samples_per_hop, fs, i, dt, &landscape);
    }

    let agent = pop.individuals.first().expect("agent exists");
    assert!(
        (agent.body.base_freq_hz() - freq_before).abs() <= 1e-6,
        "lock mode should keep base frequency stable"
    );
    assert!(
        (agent.target_pitch_log2() - target_before).abs() <= 1e-6,
        "lock mode should keep target pitch stable"
    );
}

#[test]
fn perceptual_disabled_still_applies_lock_mode() {
    let fs = 48_000.0;
    let dt = 0.01;
    let samples_per_hop = (fs * dt) as usize;
    let mut pop = Population::new(test_timebase());
    pop.apply_action(
        Action::Spawn {
            tag: "locked".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 220.0 },
                "perceptual": { "enabled": false }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );
    pop.apply_action(
        Action::Set {
            target: "locked".to_string(),
            patch: serde_json::json!({
                "pitch": { "mode": "lock", "freq": 440.0 }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );
    let landscape = make_test_landscape(fs);
    pop.advance(samples_per_hop, fs, 0, dt, &landscape);
    let agent = pop.individuals.first().expect("agent exists");
    let expected = 440.0_f32.log2();
    assert!(
        (agent.target_pitch_log2() - expected).abs() <= 1e-6,
        "lock mode should apply even when perceptual is disabled"
    );
}

#[test]
fn free_mode_uses_freq_center_when_range_zero() {
    let mut control = AgentControl::default();
    control.pitch.mode = PitchMode::Free;
    control.pitch.freq = 220.0;
    control.pitch.range_oct = 0.0;
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id: 4,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    let mut rhythms = NeuralRhythms::default();
    rhythms.theta.phase = 0.1;
    rhythms.theta.mag = 1.0;
    let integration_window = agent.integration_window();
    agent.set_theta_phase_state_for_test(0.9, true);
    agent.set_accumulated_time_for_test(integration_window);
    let landscape = make_test_landscape(48_000.0);
    agent.update_pitch_target(&rhythms, 0.01, &landscape);
    let expected = 220.0_f32.log2();
    assert!((agent.target_pitch_log2() - expected).abs() <= 1e-6);
}

#[test]
fn remove_pending_still_emits_note_offs() {
    let mut control = AgentControl::default();
    control.pitch.freq = 220.0;
    control.phonation.r#type = PhonationType::Interval;
    control.phonation.density = 1.0;
    control.phonation.legato = 0.0;
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    let tb = Timebase {
        fs: 48_000.0,
        hop: 12_001,
    };
    let mut rhythms = NeuralRhythms::default();
    rhythms.theta.freq_hz = 4.0;
    rhythms.theta.phase = 0.0;
    rhythms.env_open = 1.0;
    rhythms.env_level = 1.0;
    let mut batch = PhonationBatch::default();
    let mut now: Tick = 0;
    let mut saw_note_on = false;
    for _ in 0..20 {
        agent.tick_phonation_into(&tb, now, &rhythms, None, 0.0, &mut batch);
        if batch
            .cmds
            .iter()
            .any(|cmd| matches!(cmd, PhonationCmd::NoteOn { .. }))
        {
            saw_note_on = true;
            break;
        }
        now = now.saturating_add(tb.hop as Tick);
        rhythms.advance_in_place(tb.hop as f32 / tb.fs);
    }
    assert!(saw_note_on, "expected at least one note-on before remove");

    agent.start_remove_fade(0.05);
    let mut saw_note_off = false;
    for _ in 0..40 {
        agent.tick_phonation_into(&tb, now, &rhythms, None, 0.0, &mut batch);
        if batch
            .cmds
            .iter()
            .any(|cmd| matches!(cmd, PhonationCmd::NoteOff { .. }))
        {
            saw_note_off = true;
            break;
        }
        now = now.saturating_add(tb.hop as Tick);
        rhythms.advance_in_place(tb.hop as f32 / tb.fs);
    }
    assert!(saw_note_off, "expected note-off during remove fade");
}

#[test]
fn hold_emits_single_note_on() {
    let mut control = control_with_pitch(220.0);
    control.phonation.r#type = PhonationType::Hold;
    let events = collect_hold_events(control, 8);
    let total_on: usize = events.iter().map(|(on, _)| *on).sum();
    assert_eq!(total_on, 1);
    assert_eq!(events[0].0, 1, "expected NoteOn on first tick");
}

#[test]
fn hold_does_not_retrigger() {
    let mut control = control_with_pitch(220.0);
    control.phonation.r#type = PhonationType::Hold;
    let events = collect_hold_events(control, 24);
    let retriggers: usize = events.iter().skip(1).map(|(on, _)| *on).sum();
    assert_eq!(retriggers, 0, "hold should not retrigger after onset");
}

#[test]
fn hold_emits_note_off_on_remove() {
    let mut control = control_with_pitch(220.0);
    control.phonation.r#type = PhonationType::Hold;
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id: 2,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    let tb = test_timebase();
    let mut rhythms = NeuralRhythms::default();
    let mut batch = PhonationBatch::default();
    let mut now: Tick = 0;
    agent.tick_phonation_into(&tb, now, &rhythms, None, 0.0, &mut batch);
    let note_on = batch
        .cmds
        .iter()
        .filter(|cmd| matches!(cmd, PhonationCmd::NoteOn { .. }))
        .count();
    assert_eq!(note_on, 1, "expected NoteOn before remove");

    agent.start_remove_fade(0.01);
    let mut note_off_total = 0;
    for _ in 0..10 {
        now = now.saturating_add(tb.hop as Tick);
        rhythms.advance_in_place(tb.hop as f32 / tb.fs);
        agent.tick_phonation_into(&tb, now, &rhythms, None, 0.0, &mut batch);
        note_off_total += batch
            .cmds
            .iter()
            .filter(|cmd| matches!(cmd, PhonationCmd::NoteOff { .. }))
            .count();
    }
    assert_eq!(note_off_total, 1, "expected single NoteOff on remove");
}

#[test]
fn hold_ignores_density_legato() {
    let mut low = control_with_pitch(220.0);
    low.phonation.r#type = PhonationType::Hold;
    low.phonation.density = 0.0;
    low.phonation.legato = 0.0;
    let mut high = control_with_pitch(220.0);
    high.phonation.r#type = PhonationType::Hold;
    high.phonation.density = 1.0;
    high.phonation.legato = 1.0;
    let low_events = collect_hold_events(low, 6);
    let high_events = collect_hold_events(high, 6);
    assert_eq!(low_events, high_events);
}

#[test]
fn drone_is_rejected() {
    let err = AgentControl::from_json(serde_json::json!({
        "phonation": { "type": "drone" }
    }));
    assert!(err.is_err());
}

#[test]
fn harmonic_render_spectrum_hits_expected_bins() {
    let mut control = control_with_pitch(55.0);
    control.body.method = BodyMethod::Harmonic;
    control.body.amp = 0.8;
    control.body.timbre.brightness = 1.0;
    control.body.timbre.inharmonic = 0.0;
    control.body.timbre.width = 0.1;
    control.body.timbre.motion = 0.5;
    let cfg = IndividualConfig { control, tag: None };
    let metadata = AgentMetadata {
        id: 99,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(metadata.id, 0, metadata, 48_000.0, 0);
    let space = Log2Space::new(55.0, 1760.0, 12);
    let mut amps = vec![0.0f32; space.n_bins()];

    agent.last_signal = ArticulationSignal {
        amplitude: 1.0,
        is_active: true,
        relaxation: 0.0,
        tension: 0.0,
    };
    agent.render_spectrum(&mut amps, &space);

    let base_bin = space.index_of_freq(55.0).expect("base bin");
    let even_bin = space.index_of_freq(110.0).expect("even bin");
    assert!(
        amps[base_bin] > 0.0,
        "fundamental bin should receive energy"
    );
    assert!(
        amps[even_bin] > 0.0,
        "second harmonic bin should receive energy"
    );
    assert!(
        amps[base_bin] > amps[even_bin],
        "brightness should attenuate even harmonic"
    );
}

#[test]
fn lock_mode_sets_target_pitch_log2() {
    let space = Log2Space::new(55.0, 880.0, 12);
    let landscape = LandscapeFrame::new(space.clone());
    let mut pop = Population::new(test_timebase());
    pop.apply_action(
        Action::Spawn {
            tag: "test_agent".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 220.0 }
            }),
        },
        &landscape,
        None,
    );

    pop.apply_action(
        Action::Set {
            target: "test_agent".to_string(),
            patch: serde_json::json!({
                "pitch": {
                    "mode": "lock",
                    "freq": 440.0
                }
            }),
        },
        &landscape,
        None,
    );

    let log_target = 440.0f32.log2();
    let agent = pop.individuals.first_mut().expect("agent exists");
    let rhythms = NeuralRhythms::default();
    agent.update_pitch_target(&rhythms, 0.01, &Landscape::new(space));
    assert!((agent.target_pitch_log2() - log_target).abs() < 1e-6);
}

#[test]
fn population_spectrum_uses_log2_space() {
    let space = Log2Space::new(55.0, 880.0, 12);
    let mut pop = Population::new(test_timebase());
    pop.apply_action(
        Action::Spawn {
            tag: "spec".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 55.0 }
            }),
        },
        &LandscapeFrame::new(space.clone()),
        None,
    );
    let agent = pop.individuals.first_mut().expect("agent exists");
    agent.last_signal = ArticulationSignal {
        amplitude: 1.0,
        is_active: true,
        relaxation: 0.0,
        tension: 0.0,
    };

    let amps = pop.process_frame(0, &space, 0.01, false);
    assert_eq!(amps.len(), space.n_bins());
    let idx = space.index_of_freq(55.0).expect("base bin");
    assert!(amps[idx] > 0.0);
}

#[test]
fn agent_patch_rejects_unknown_fields() {
    let good = serde_json::json!({
        "body": { "amp": 0.25 },
        "pitch": { "freq": 220.0 },
        "perceptual": { "enabled": true }
    });
    let patch: crate::life::control::AgentPatch =
        serde_json::from_value(good).expect("agent patch parses");
    assert_eq!(patch.body.unwrap().amp, Some(0.25));

    let bad = serde_json::json!({
        "body": { "amp": 0.25, "unknown": 1.0 }
    });
    let err = serde_json::from_value::<crate::life::control::AgentPatch>(bad)
        .expect_err("unknown key should be rejected");
    assert!(err.to_string().contains("unknown"));
}

#[test]
fn phonation_connect_rejects_unknown_keys() {
    let err = serde_json::from_value::<PhonationConnectConfig>(serde_json::json!({
        "type": "fixed_gate",
        "mystery": 1
    }))
    .expect_err("unknown key should be rejected");
    assert!(err.to_string().contains("mystery"));
}

#[test]
fn agent_patch_clamps_and_coerces_numbers() {
    let patch: crate::life::control::AgentPatch = serde_json::from_value(serde_json::json!({
        "body": { "amp": 2 },
        "pitch": { "range_oct": 99.0 },
        "phonation": { "density": -1 }
    }))
    .expect("patch parses");
    let body = patch.body.expect("body patch");
    assert_eq!(body.amp, Some(1.0));
    let pitch = patch.pitch.expect("pitch patch");
    assert_eq!(pitch.range_oct, Some(6.0));
    let phonation = patch.phonation.expect("phonation patch");
    assert_eq!(phonation.density, Some(0.0));
}

#[test]
fn unset_restores_base_control() {
    let mut control = AgentControl::default();
    control.body.amp = 0.3;
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id: 1,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    agent
        .apply_control_patch(serde_json::json!({ "body": { "amp": 0.8 } }))
        .expect("patch applies");
    assert!((agent.effective_control.body.amp - 0.8).abs() < 1e-6);
    agent.apply_unset_path("body.amp").expect("unset applies");
    assert!((agent.effective_control.body.amp - 0.3).abs() < 1e-6);
}

#[test]
fn unset_restores_base_pitch_freq() {
    let mut control = AgentControl::default();
    control.pitch.freq = 220.0;
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id: 5,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    agent
        .apply_control_patch(serde_json::json!({ "pitch": { "freq": 440.0 } }))
        .expect("patch applies");
    assert!((agent.effective_control.pitch.freq - 440.0).abs() < 1e-6);
    agent.apply_unset_path("pitch.freq").expect("unset applies");
    assert!((agent.effective_control.pitch.freq - 220.0).abs() < 1e-6);
}

#[test]
fn reject_legacy_pitch_keys() {
    let cfg = IndividualConfig {
        control: control_with_pitch(220.0),
        tag: None,
    };
    let meta = AgentMetadata {
        id: 2,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    let center_key = ["center", "_hz"].concat();
    let mut pitch_map = serde_json::Map::new();
    pitch_map.insert(center_key, serde_json::Value::from(123.0));
    let mut patch_map = serde_json::Map::new();
    patch_map.insert("pitch".to_string(), serde_json::Value::Object(pitch_map));
    let err_center = agent.apply_control_patch(serde_json::Value::Object(patch_map));
    assert!(err_center.is_err());
    let legacy_key = ["freq", "_hz"].concat();
    let mut pitch_map = serde_json::Map::new();
    pitch_map.insert(legacy_key, serde_json::Value::from(123.0));
    let mut patch_map = serde_json::Map::new();
    patch_map.insert("pitch".to_string(), serde_json::Value::Object(pitch_map));
    let err_legacy_freq = agent.apply_control_patch(serde_json::Value::Object(patch_map));
    assert!(err_legacy_freq.is_err());
    let legacy_home_key = ["home", "_hz"].concat();
    let mut pitch_map = serde_json::Map::new();
    pitch_map.insert(legacy_home_key, serde_json::Value::from(123.0));
    let mut patch_map = serde_json::Map::new();
    patch_map.insert("pitch".to_string(), serde_json::Value::Object(pitch_map));
    let err_legacy_home = agent.apply_control_patch(serde_json::Value::Object(patch_map));
    assert!(err_legacy_home.is_err());
    let constraint_key = ["con", "straint"].concat();
    let mut constraint_map = serde_json::Map::new();
    constraint_map.insert("mode".to_string(), serde_json::Value::from("lock"));
    constraint_map.insert("freq".to_string(), serde_json::Value::from(123.0));
    let mut pitch_map = serde_json::Map::new();
    pitch_map.insert(constraint_key, serde_json::Value::Object(constraint_map));
    let mut patch_map = serde_json::Map::new();
    patch_map.insert("pitch".to_string(), serde_json::Value::Object(pitch_map));
    let err_constraint = agent.apply_control_patch(serde_json::Value::Object(patch_map));
    assert!(err_constraint.is_err());
    let legacy_mode_value = ["att", "ractor"].concat();
    let mut pitch_map = serde_json::Map::new();
    pitch_map.insert(
        "mode".to_string(),
        serde_json::Value::from(legacy_mode_value),
    );
    let mut patch_map = serde_json::Map::new();
    patch_map.insert("pitch".to_string(), serde_json::Value::Object(pitch_map));
    let err_legacy_mode = agent.apply_control_patch(serde_json::Value::Object(patch_map));
    assert!(err_legacy_mode.is_err());
}

#[test]
fn patch_rejects_type_switches() {
    let cfg = IndividualConfig {
        control: control_with_pitch(220.0),
        tag: None,
    };
    let meta = AgentMetadata {
        id: 3,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut agent = cfg.spawn(meta.id, 0, meta, 48_000.0, 0);
    let err_body = agent.apply_control_patch(serde_json::json!({
        "body": { "method": "harmonic" }
    }));
    assert!(err_body.is_err());
    let err_phonation = agent.apply_control_patch(serde_json::json!({
        "phonation": { "type": "hold" }
    }));
    assert!(err_phonation.is_err());
}

#[test]
fn spawn_opts_respects_patch_mode_free() {
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();
    let opts = SpawnOpts {
        method: Some(SpawnMethod::RandomLogUniform {
            min_freq: 220.0,
            max_freq: 220.0,
            min_dist_erb: Some(0.0),
        }),
    };
    pop.apply_action(
        Action::Spawn {
            tag: "free_mode".to_string(),
            count: 1,
            opts: Some(opts),
            patch: serde_json::json!({
                "pitch": { "mode": "free" }
            }),
        },
        &landscape,
        None,
    );
    let agent = pop.individuals.first().expect("agent exists");
    assert_eq!(agent.effective_control.pitch.mode, PitchMode::Free);
}

#[test]
fn spawn_opts_respects_patch_mode_lock() {
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();
    let opts = SpawnOpts {
        method: Some(SpawnMethod::RandomLogUniform {
            min_freq: 440.0,
            max_freq: 440.0,
            min_dist_erb: Some(0.0),
        }),
    };
    pop.apply_action(
        Action::Spawn {
            tag: "lock_mode".to_string(),
            count: 1,
            opts: Some(opts),
            patch: serde_json::json!({
                "pitch": { "mode": "lock" }
            }),
        },
        &landscape,
        None,
    );
    let agent = pop.individuals.first().expect("agent exists");
    assert_eq!(agent.effective_control.pitch.mode, PitchMode::Lock);
}

#[test]
fn spawn_opts_respects_patch_freq() {
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();
    let opts = SpawnOpts {
        method: Some(SpawnMethod::RandomLogUniform {
            min_freq: 440.0,
            max_freq: 440.0,
            min_dist_erb: Some(0.0),
        }),
    };
    pop.apply_action(
        Action::Spawn {
            tag: "freq_override".to_string(),
            count: 1,
            opts: Some(opts),
            patch: serde_json::json!({
                "pitch": { "freq": 330.0 }
            }),
        },
        &landscape,
        None,
    );
    let agent = pop.individuals.first().expect("agent exists");
    assert!((agent.effective_control.pitch.freq - 330.0).abs() < 1e-6);
}

#[test]
fn spawn_opts_samples_when_patch_freq_null() {
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::new(Log2Space::new(100.0, 1000.0, 12));
    let opts = SpawnOpts {
        method: Some(SpawnMethod::RandomLogUniform {
            min_freq: 330.0,
            max_freq: 330.0,
            min_dist_erb: Some(0.0),
        }),
    };
    pop.apply_action(
        Action::Spawn {
            tag: "freq_null".to_string(),
            count: 1,
            opts: Some(opts),
            patch: serde_json::json!({
                "pitch": { "mode": "lock", "freq": null }
            }),
        },
        &landscape,
        None,
    );
    let agent = pop.individuals.first().expect("agent exists");
    assert_eq!(agent.effective_control.pitch.mode, PitchMode::Lock);
    assert!((agent.effective_control.pitch.freq - 330.0).abs() < 1e-6);
}

#[test]
fn spawn_lock_samples_freq_from_method() {
    let mut pop = Population::new(test_timebase());
    let space = Log2Space::new(200.0, 800.0, 12);
    let mut landscape = LandscapeFrame::new(space.clone());
    landscape.consonance01.fill(0.0);
    let idx_high = space.index_of_freq(400.0).expect("idx");
    landscape.consonance01[idx_high] = 1.0;
    let opts = SpawnOpts {
        method: Some(SpawnMethod::Harmonicity {
            min_freq: 300.0,
            max_freq: 500.0,
            min_dist_erb: Some(0.0),
        }),
    };
    pop.apply_action(
        Action::Spawn {
            tag: "lock_sampled".to_string(),
            count: 1,
            opts: Some(opts),
            patch: serde_json::json!({
                "pitch": { "mode": "lock" }
            }),
        },
        &landscape,
        None,
    );
    let agent = pop.individuals.first().expect("agent exists");
    let freq = agent.effective_control.pitch.freq;
    assert_eq!(agent.effective_control.pitch.mode, PitchMode::Lock);
    assert!(freq >= 300.0 && freq <= 500.0);
    let picked_idx = space.index_of_freq(freq).expect("picked idx");
    assert_eq!(picked_idx, idx_high);
    assert!((agent.target_pitch_log2() - freq.log2()).abs() <= 1e-6);
}

#[test]
fn spawn_lock_sets_freq() {
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();
    pop.apply_action(
        Action::Spawn {
            tag: "lock".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "mode": "lock", "freq": 440.0 }
            }),
        },
        &landscape,
        None,
    );
    let agent = pop.individuals.first().expect("agent exists");
    assert_eq!(agent.effective_control.pitch.mode, PitchMode::Lock);
    assert!((agent.effective_control.pitch.freq - 440.0).abs() < 1e-6);
    let expected = 440.0_f32.log2();
    assert!((agent.target_pitch_log2() - expected).abs() <= 1e-6);
}

#[test]
fn lock_mode_ignores_range_clamp() {
    let fs = 48_000.0;
    let dt = 0.01;
    let samples_per_hop = (fs * dt) as usize;
    let mut pop = Population::new(test_timebase());
    pop.apply_action(
        Action::Spawn {
            tag: "lock_range".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 220.0, "range_oct": 0.0 }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );
    pop.apply_action(
        Action::Set {
            target: "lock_range".to_string(),
            patch: serde_json::json!({
                "pitch": { "mode": "lock", "freq": 440.0 }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );
    let landscape = make_test_landscape(fs);
    pop.advance(samples_per_hop, fs, 0, dt, &landscape);
    let agent = pop.individuals.first().expect("agent exists");
    let expected = 440.0_f32.log2();
    assert!(
        (agent.target_pitch_log2() - expected).abs() <= 1e-6,
        "lock mode should override range clamp"
    );
}

#[test]
fn remove_fade_reduces_gain_and_culls() {
    let fs = test_timebase().fs;
    let mut pop = Population::new(test_timebase());
    let landscape = LandscapeFrame::default();
    pop.apply_action(
        Action::Spawn {
            tag: "fade".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({ "pitch": { "freq": 220.0 } }),
        },
        &landscape,
        None,
    );
    pop.apply_action(
        Action::Remove {
            target: "fade".to_string(),
        },
        &landscape,
        None,
    );
    let gain_before = pop.individuals[0].release_gain();
    let dt = 0.01;
    let samples_per_hop = (fs * dt) as usize;
    let landscape_rt = make_test_landscape(fs);
    pop.advance(samples_per_hop, fs, 0, dt, &landscape_rt);
    let gain_after = pop.individuals[0].release_gain();
    assert!(gain_after < gain_before);

    let dt_finish = 0.1;
    let samples_per_hop_finish = (fs * dt_finish) as usize;
    pop.advance(samples_per_hop_finish, fs, 1, dt_finish, &landscape_rt);
    pop.process_frame(1, &landscape_rt.space, dt_finish, false);
    assert!(pop.individuals.is_empty());
}

#[test]
fn pitch_core_proposes_target_within_bounds() {
    let space = Log2Space::new(55.0, 880.0, 12);
    let landscape = Landscape::new(space.clone());
    let mut rng = rand::rngs::StdRng::seed_from_u64(4);
    let mut pitch = super::individual::AnyPitchCore::from_config(
        &PitchCoreConfig::PitchHillClimb {
            neighbor_step_cents: None,
            tessitura_gravity: None,
            improvement_threshold: None,
            exploration: None,
            persistence: None,
        },
        220.0f32.log2(),
        &mut rng,
    );
    let proposal = pitch.propose_target(
        220.0f32.log2(),
        220.0f32.log2(),
        220.0,
        2.0,
        &landscape,
        &crate::life::perceptual::PerceptualContext::from_config(
            &PerceptualConfig {
                tau_fast: Some(0.5),
                tau_slow: Some(4.0),
                w_boredom: Some(0.8),
                w_familiarity: Some(0.2),
                rho_self: Some(0.0),
                boredom_gamma: Some(0.5),
                self_smoothing_radius: Some(0),
                silence_mass_epsilon: Some(1e-6),
            },
            space.n_bins(),
        ),
        &crate::life::perceptual::FeaturesNow::from_subjective_intensity(&vec![
            0.0;
            space.n_bins()
        ]),
        &mut rng,
    );
    let (fmin, fmax) = landscape.freq_bounds_log2();
    assert!(proposal.target_pitch_log2 >= fmin && proposal.target_pitch_log2 <= fmax);
    assert!((0.0..=1.0).contains(&proposal.salience));
}

#[test]
fn deterministic_rng_produces_same_targets() {
    let mut control = control_with_pitch(220.0);
    control.pitch.exploration = 0.2;
    control.pitch.persistence = 0.5;
    control.perceptual.adaptation = 0.5;
    control.perceptual.novelty_bias = 0.8;
    control.perceptual.self_focus = 0.15;
    let cfg = IndividualConfig { control, tag: None };
    let meta = AgentMetadata {
        id: 10,
        tag: None,
        group_idx: 0,
        member_idx: 0,
    };
    let mut a = cfg.spawn(10, 4, meta.clone(), 48_000.0, 0);
    let mut b = cfg.spawn(10, 4, meta, 48_000.0, 0);
    let landscape = make_test_landscape(48_000.0);
    let mut rhythms = crate::core::modulation::NeuralRhythms::default();
    let dt = 0.5;
    let mut seq_a = Vec::new();
    let mut seq_b = Vec::new();
    for i in 0..16 {
        rhythms.theta.mag = 1.0;
        rhythms.theta.phase = if i % 2 == 0 {
            -std::f32::consts::FRAC_PI_2
        } else {
            std::f32::consts::FRAC_PI_2
        };
        a.update_pitch_target(&rhythms, dt, &landscape);
        b.update_pitch_target(&rhythms, dt, &landscape);
        seq_a.push(a.target_pitch_log2());
        seq_b.push(b.target_pitch_log2());
    }
    assert_eq!(seq_a, seq_b);
}

#[test]
fn theta_wrap_triggers_pitch_update_with_large_dt() {
    let mut pop = Population::new(test_timebase());
    let landscape = make_test_landscape(48_000.0);
    pop.apply_action(
        Action::Spawn {
            tag: "theta".to_string(),
            count: 1,
            opts: None,
            patch: serde_json::json!({
                "pitch": { "freq": 440.0 }
            }),
        },
        &LandscapeFrame::default(),
        None,
    );
    let agent = pop.individuals.first_mut().expect("agent exists");
    let integration_window = agent.integration_window();
    agent.set_accumulated_time_for_test(integration_window + 1.0);
    agent.set_theta_phase_state_for_test(6.0, true);

    let rhythms = NeuralRhythms {
        theta: RhythmBand {
            phase: 0.1,
            freq_hz: 12.0,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.0,
        },
        delta: RhythmBand {
            phase: 0.0,
            freq_hz: 1.0,
            mag: 0.0,
            alpha: 0.0,
            beta: 0.0,
        },
        env_open: 1.0,
        env_level: 1.0,
    };
    agent.update_pitch_target(&rhythms, 0.5, &landscape);
    assert_eq!(
        agent.accumulated_time_for_test(),
        0.0,
        "theta wrap should trigger a pitch update even for large dt"
    );
}

#[test]
fn kuramoto_locks_to_theta_phase() {
    let mut core = KuramotoCore {
        energy: 1.0,
        energy_cap: 1.0,
        vitality_exponent: 0.5,
        vitality_level: 1.0,
        basal_cost: 0.0,
        action_cost: 0.0,
        recharge_rate: 0.0,
        sensitivity: Sensitivity {
            delta: 1.0,
            theta: 1.0,
            alpha: 1.0,
            beta: 1.0,
        },
        rhythm_phase: 1.7,
        rhythm_freq: 5.0,
        omega_rad: std::f32::consts::TAU * 5.0,
        phase_offset: 0.4,
        debug_id: 0,
        env_level: 0.05,
        state: ArticulationState::Idle,
        attack_step: 0.1,
        decay_rate: 0.9,
        retrigger: true,
        noise_1f: PinkNoise::new(9, 1.0),
        base_sigma: 0.05,
        beta_gain: 0.5,
        k_omega: 3.0,
        bootstrap_timer: 0.0,
        env_open_threshold: 0.55,
        env_level_min: 0.02,
        mag_threshold: 0.2,
        alpha_threshold: 0.2,
        beta_threshold: 0.8,
        dbg_accum_time: 0.0,
        dbg_wraps: 0,
        dbg_attacks: 0,
        dbg_boot_attacks: 0,
        dbg_attack_logs_left: 0,
        dbg_attack_count_normal: 0,
        dbg_attack_sum_abs_diff: 0.0,
        dbg_attack_sum_cos: 0.0,
        dbg_attack_sum_sin: 0.0,
        dbg_fail_env: 0,
        dbg_fail_env_level: 0,
        dbg_fail_mag: 0,
        dbg_fail_alpha: 0,
        dbg_fail_beta: 0,
        dbg_last_env_open: 0.0,
        dbg_last_env_level: 0.0,
        dbg_last_theta_mag: 0.0,
        dbg_last_theta_alpha: 0.0,
        dbg_last_theta_beta: 0.0,
        dbg_last_k_eff: 0.0,
    };
    let mut theta_phase = 0.0;
    let dt = 0.01;
    for _ in 0..3000 {
        theta_phase =
            (theta_phase + std::f32::consts::TAU * 6.0 * dt).rem_euclid(std::f32::consts::TAU);
        let rhythms = NeuralRhythms {
            theta: RhythmBand {
                phase: theta_phase,
                freq_hz: 6.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            delta: RhythmBand {
                phase: 0.0,
                freq_hz: 1.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            env_open: 1.0,
            env_level: 1.0,
        };
        core.process(0.5, &rhythms, dt, 1.0);
    }

    let target = (theta_phase + core.phase_offset).rem_euclid(std::f32::consts::TAU);
    let mut diff = target - core.rhythm_phase.rem_euclid(std::f32::consts::TAU);
    while diff > std::f32::consts::PI {
        diff -= std::f32::consts::TAU;
    }
    while diff < -std::f32::consts::PI {
        diff += std::f32::consts::TAU;
    }
    assert!(
        diff.abs() < 0.5,
        "phase should lock near theta target, got diff={diff}"
    );
}

#[test]
fn kuramoto_bootstrap_triggers_attack() {
    let mut core = KuramotoCore {
        energy: 1.0,
        energy_cap: 1.0,
        vitality_exponent: 0.5,
        vitality_level: 1.0,
        basal_cost: 0.0,
        action_cost: 0.0,
        recharge_rate: 0.0,
        sensitivity: Sensitivity {
            delta: 1.0,
            theta: 1.0,
            alpha: 1.0,
            beta: 1.0,
        },
        rhythm_phase: std::f32::consts::TAU + 0.1,
        rhythm_freq: 6.0,
        omega_rad: 0.0,
        phase_offset: 0.0,
        debug_id: 1,
        env_level: 0.05,
        state: ArticulationState::Idle,
        attack_step: 0.1,
        decay_rate: 0.9,
        retrigger: true,
        noise_1f: PinkNoise::new(7, 0.0),
        base_sigma: 0.0,
        beta_gain: 0.0,
        k_omega: 0.0,
        bootstrap_timer: 1.0,
        env_open_threshold: 0.55,
        env_level_min: 0.02,
        mag_threshold: 0.2,
        alpha_threshold: 0.2,
        beta_threshold: 0.9,
        dbg_accum_time: 0.0,
        dbg_wraps: 0,
        dbg_attacks: 0,
        dbg_boot_attacks: 0,
        dbg_attack_logs_left: 0,
        dbg_attack_count_normal: 0,
        dbg_attack_sum_abs_diff: 0.0,
        dbg_attack_sum_cos: 0.0,
        dbg_attack_sum_sin: 0.0,
        dbg_fail_env: 0,
        dbg_fail_env_level: 0,
        dbg_fail_mag: 0,
        dbg_fail_alpha: 0,
        dbg_fail_beta: 0,
        dbg_last_env_open: 0.0,
        dbg_last_env_level: 0.0,
        dbg_last_theta_mag: 0.0,
        dbg_last_theta_alpha: 0.0,
        dbg_last_theta_beta: 0.0,
        dbg_last_k_eff: 0.0,
    };

    let rhythms = NeuralRhythms {
        theta: RhythmBand {
            phase: 0.0,
            freq_hz: 6.0,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.0,
        },
        delta: RhythmBand {
            phase: 0.0,
            freq_hz: 1.0,
            mag: 0.0,
            alpha: 0.0,
            beta: 0.0,
        },
        env_open: 1.0,
        env_level: 0.05,
    };

    core.process(0.0, &rhythms, 0.01, 1.0);
    assert_eq!(
        core.state,
        ArticulationState::Attack,
        "bootstrap should allow an attack during early onset"
    );
}

#[test]
fn kuramoto_normal_attacks_fire_and_lock() {
    let dt = 0.01;
    // Convert per-step envelope tuning to per-second rates for k-rate updates.
    let attack_step = 0.1 / dt;
    let decay_rate = -0.9f32.ln() / dt;
    let mut core = KuramotoCore {
        energy: 1.0,
        energy_cap: 1.0,
        vitality_exponent: 0.5,
        vitality_level: 1.0,
        basal_cost: 0.0,
        action_cost: 0.0,
        recharge_rate: 0.0,
        sensitivity: Sensitivity {
            delta: 1.0,
            theta: 1.0,
            alpha: 1.0,
            beta: 1.0,
        },
        rhythm_phase: 0.1,
        rhythm_freq: 6.0,
        omega_rad: std::f32::consts::TAU * 6.0,
        phase_offset: 0.0,
        debug_id: 2,
        env_level: 0.0,
        state: ArticulationState::Idle,
        attack_step,
        decay_rate,
        retrigger: true,
        noise_1f: PinkNoise::new(11, 0.0),
        base_sigma: 0.0,
        beta_gain: 0.0,
        k_omega: 0.0,
        bootstrap_timer: 0.0,
        env_open_threshold: 0.55,
        env_level_min: 0.02,
        mag_threshold: 0.03,
        alpha_threshold: 0.2,
        beta_threshold: 0.9,
        dbg_accum_time: -100.0,
        dbg_wraps: 0,
        dbg_attacks: 0,
        dbg_boot_attacks: 0,
        dbg_attack_logs_left: 0,
        dbg_attack_count_normal: 0,
        dbg_attack_sum_abs_diff: 0.0,
        dbg_attack_sum_cos: 0.0,
        dbg_attack_sum_sin: 0.0,
        dbg_fail_env: 0,
        dbg_fail_env_level: 0,
        dbg_fail_mag: 0,
        dbg_fail_alpha: 0,
        dbg_fail_beta: 0,
        dbg_last_env_open: 0.0,
        dbg_last_env_level: 0.0,
        dbg_last_theta_mag: 0.0,
        dbg_last_theta_alpha: 0.0,
        dbg_last_theta_beta: 0.0,
        dbg_last_k_eff: 0.0,
    };

    let mut t = 0.0;
    for _ in 0..1500 {
        let theta_phase = (t * 6.0 * std::f32::consts::TAU).rem_euclid(std::f32::consts::TAU);
        let rhythms = NeuralRhythms {
            theta: RhythmBand {
                phase: theta_phase,
                freq_hz: 6.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            delta: RhythmBand {
                phase: 0.0,
                freq_hz: 1.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            env_open: 1.0,
            env_level: 1.0,
        };
        core.process(0.5, &rhythms, dt, 1.0);
        t += dt;
    }

    assert!(
        core.dbg_attack_count_normal >= 5,
        "expected normal attacks to fire"
    );
    let count = core.dbg_attack_count_normal as f32;
    let mean_abs_diff = core.dbg_attack_sum_abs_diff / count;
    let plv = (core.dbg_attack_sum_cos * core.dbg_attack_sum_cos
        + core.dbg_attack_sum_sin * core.dbg_attack_sum_sin)
        .sqrt()
        / count;
    assert!(
        mean_abs_diff < 0.5,
        "mean abs diff too large: {mean_abs_diff}"
    );
    assert!(plv > 0.9, "attack PLV too low: {plv}");
}

#[test]
fn kuramoto_attack_count_invariant_to_chunking() {
    fn run_with_chunk(chunk: usize) -> u32 {
        let mut core = KuramotoCore {
            energy: 1.0,
            energy_cap: 1.0,
            vitality_exponent: 0.5,
            vitality_level: 1.0,
            basal_cost: 0.0,
            action_cost: 0.0,
            recharge_rate: 0.0,
            sensitivity: Sensitivity {
                delta: 1.0,
                theta: 1.0,
                alpha: 1.0,
                beta: 1.0,
            },
            rhythm_phase: std::f32::consts::TAU - 0.01,
            rhythm_freq: 2.0,
            omega_rad: std::f32::consts::TAU * 2.0,
            phase_offset: 0.0,
            debug_id: 3,
            env_level: 1.0,
            state: ArticulationState::Idle,
            attack_step: 1.0,
            decay_rate: 0.2,
            retrigger: true,
            noise_1f: PinkNoise::new(11, 0.0),
            base_sigma: 0.0,
            beta_gain: 0.0,
            k_omega: 0.0,
            bootstrap_timer: 0.0,
            env_open_threshold: 0.55,
            env_level_min: 0.02,
            mag_threshold: 0.01,
            alpha_threshold: 0.01,
            beta_threshold: 0.9,
            dbg_accum_time: -1000.0,
            dbg_wraps: 0,
            dbg_attacks: 0,
            dbg_boot_attacks: 0,
            dbg_attack_logs_left: 0,
            dbg_attack_count_normal: 0,
            dbg_attack_sum_abs_diff: 0.0,
            dbg_attack_sum_cos: 0.0,
            dbg_attack_sum_sin: 0.0,
            dbg_fail_env: 0,
            dbg_fail_env_level: 0,
            dbg_fail_mag: 0,
            dbg_fail_alpha: 0,
            dbg_fail_beta: 0,
            dbg_last_env_open: 0.0,
            dbg_last_env_level: 0.0,
            dbg_last_theta_mag: 0.0,
            dbg_last_theta_alpha: 0.0,
            dbg_last_theta_beta: 0.0,
            dbg_last_k_eff: 0.0,
        };

        let mut rhythms = NeuralRhythms {
            theta: RhythmBand {
                phase: 0.0,
                freq_hz: 2.0,
                mag: 1.0,
                alpha: 1.0,
                beta: 0.0,
            },
            delta: RhythmBand {
                phase: 0.0,
                freq_hz: 0.0,
                mag: 0.0,
                alpha: 0.0,
                beta: 0.0,
            },
            env_open: 1.0,
            env_level: 1.0,
        };

        let fs = 1000.0;
        let dt = 1.0 / fs;
        let total_samples = (fs * 2.0) as usize;
        let mut idx = 0;
        while idx < total_samples {
            let end = (idx + chunk).min(total_samples);
            for _ in idx..end {
                core.process(0.0, &rhythms, dt, 1.0);
                rhythms.advance_in_place(dt);
            }
            idx = end;
        }
        core.dbg_attack_count_normal
    }

    let a = run_with_chunk(1);
    let b = run_with_chunk(64);
    assert_eq!(a, b, "attack count should be chunk-size invariant");
    assert!(a > 0, "expected at least one attack");
}

#[test]
fn kuramoto_process_dt_invariance() {
    let base = KuramotoCore {
        energy: 1.0,
        energy_cap: 1.0,
        vitality_exponent: 0.5,
        vitality_level: 1.0,
        basal_cost: 0.1,
        action_cost: 0.0,
        recharge_rate: 0.0,
        sensitivity: Sensitivity {
            delta: 0.0,
            theta: 0.0,
            alpha: 0.0,
            beta: 0.0,
        },
        rhythm_phase: 1.0,
        rhythm_freq: 4.0,
        omega_rad: std::f32::consts::TAU * 4.0,
        phase_offset: 0.0,
        debug_id: 42,
        env_level: 1.0,
        state: ArticulationState::Decay,
        attack_step: 0.0,
        decay_rate: 1.0,
        retrigger: false,
        noise_1f: PinkNoise::new(5, 0.0),
        base_sigma: 0.0,
        beta_gain: 0.0,
        k_omega: 0.0,
        bootstrap_timer: 0.0,
        env_open_threshold: 1.0,
        env_level_min: 0.0,
        mag_threshold: 1.0,
        alpha_threshold: 1.0,
        beta_threshold: -1.0,
        dbg_accum_time: 0.0,
        dbg_wraps: 0,
        dbg_attacks: 0,
        dbg_boot_attacks: 0,
        dbg_attack_logs_left: 0,
        dbg_attack_count_normal: 0,
        dbg_attack_sum_abs_diff: 0.0,
        dbg_attack_sum_cos: 0.0,
        dbg_attack_sum_sin: 0.0,
        dbg_fail_env: 0,
        dbg_fail_env_level: 0,
        dbg_fail_mag: 0,
        dbg_fail_alpha: 0,
        dbg_fail_beta: 0,
        dbg_last_env_open: 0.0,
        dbg_last_env_level: 0.0,
        dbg_last_theta_mag: 0.0,
        dbg_last_theta_alpha: 0.0,
        dbg_last_theta_beta: 0.0,
        dbg_last_k_eff: 0.0,
    };
    let rhythms = NeuralRhythms {
        theta: RhythmBand {
            phase: 0.0,
            freq_hz: 4.0,
            mag: 0.0,
            alpha: 0.0,
            beta: 0.0,
        },
        delta: RhythmBand {
            phase: 0.0,
            freq_hz: 1.0,
            mag: 0.0,
            alpha: 0.0,
            beta: 0.0,
        },
        env_open: 0.0,
        env_level: 0.0,
    };

    let total_sec = 0.2;
    let steps = 20;
    let dt = total_sec / steps as f32;

    let mut fine = base.clone();
    for _ in 0..steps {
        fine.process(0.0, &rhythms, dt, 1.0);
    }

    let mut coarse = base;
    coarse.process(0.0, &rhythms, total_sec, 1.0);

    let tol = 1e-3;
    assert_eq!(fine.state, coarse.state);
    assert!((fine.env_level - coarse.env_level).abs() < tol);
    assert!((fine.energy - coarse.energy).abs() < tol);
    assert!((fine.rhythm_phase - coarse.rhythm_phase).abs() < tol);
}

#[test]
fn sequenced_core_stops_after_duration() {
    let mut core = SequencedCore {
        timer: 0.0,
        duration: 0.1,
        env_level: 0.0,
    };
    let rhythms = crate::core::modulation::NeuralRhythms::default();
    let active = core.process(0.0, &rhythms, 0.05, 1.0);
    assert!(active.is_active, "core should be active before duration");
    let finished = core.process(0.0, &rhythms, 0.1, 1.0);
    assert!(
        !finished.is_active && !core.is_alive(),
        "core should stop after duration"
    );
}

#[test]
fn perceptual_boredom_increases_with_repetition() {
    let config = PerceptualConfig {
        tau_fast: Some(0.5),
        tau_slow: Some(20.0),
        w_boredom: Some(1.0),
        w_familiarity: Some(0.2),
        rho_self: Some(0.2),
        boredom_gamma: Some(0.5),
        self_smoothing_radius: Some(0),
        silence_mass_epsilon: Some(1e-6),
    };
    let mut ctx = PerceptualContext::from_config(&config, 8);
    let features = FeaturesNow::from_subjective_intensity(&vec![0.0f32; 8]);
    let idx = 3;
    let adj0 = ctx.score_adjustment(idx);
    ctx.update(idx, &features, 0.2);
    let adj1 = ctx.score_adjustment(idx);
    ctx.update(idx, &features, 0.2);
    let adj2 = ctx.score_adjustment(idx);
    assert!(adj1 < adj0, "expected adjustment to drop after repetition");
    assert!(adj2 < adj1, "expected adjustment to keep dropping");
}

#[test]
fn perceptual_fast_trace_recovers_over_time() {
    let config = PerceptualConfig {
        tau_fast: Some(0.5),
        tau_slow: Some(20.0),
        w_boredom: Some(1.0),
        w_familiarity: Some(0.2),
        rho_self: Some(0.2),
        boredom_gamma: Some(0.5),
        self_smoothing_radius: Some(0),
        silence_mass_epsilon: Some(1e-6),
    };
    let mut ctx = PerceptualContext::from_config(&config, 8);
    let mut raw = vec![0.0f32; 8];
    raw[2] = 1.0;
    let features = FeaturesNow::from_subjective_intensity(&raw);
    let idx = 2;
    ctx.update(idx, &features, 0.2);
    let adj1 = ctx.score_adjustment(idx);
    let silence = FeaturesNow::from_subjective_intensity(&vec![0.0f32; 8]);
    ctx.update(99, &silence, 2.0);
    let adj2 = ctx.score_adjustment(idx);
    assert!(adj2 > adj1, "expected boredom penalty to relax over time");
}

#[test]
fn perceptual_rho_self_zero_ignores_self_history() {
    let config = PerceptualConfig {
        tau_fast: Some(0.5),
        tau_slow: Some(20.0),
        w_boredom: Some(1.0),
        w_familiarity: Some(0.2),
        rho_self: Some(0.0),
        boredom_gamma: Some(0.5),
        self_smoothing_radius: Some(0),
        silence_mass_epsilon: Some(1e-6),
    };
    let mut ctx = PerceptualContext::from_config(&config, 8);
    let raw = vec![1.0f32; 8];
    let features = FeaturesNow::from_subjective_intensity(&raw);
    ctx.update(1, &features, 0.2);
    let adj_a = ctx.score_adjustment(1);
    let adj_b = ctx.score_adjustment(5);
    assert!(
        (adj_a - adj_b).abs() < 1e-6,
        "expected uniform adjustment when rho_self is zero"
    );
}

#[test]
fn perceptual_silence_still_updates_self_history() {
    let config = PerceptualConfig {
        tau_fast: Some(0.5),
        tau_slow: Some(20.0),
        w_boredom: Some(1.0),
        w_familiarity: Some(0.2),
        rho_self: Some(0.0),
        boredom_gamma: Some(0.5),
        self_smoothing_radius: Some(0),
        silence_mass_epsilon: Some(1e-6),
    };
    let mut ctx = PerceptualContext::from_config(&config, 8);
    let silence = FeaturesNow::from_subjective_intensity(&vec![0.0f32; 8]);
    let idx = 4;
    let adj0 = ctx.score_adjustment(idx);
    ctx.update(idx, &silence, 0.2);
    let adj1 = ctx.score_adjustment(idx);
    assert!(adj1 < adj0, "expected boredom to increase in silence");
}

#[test]
fn perceptual_silence_threshold_ignores_tiny_mass() {
    let config = PerceptualConfig {
        tau_fast: Some(0.5),
        tau_slow: Some(20.0),
        w_boredom: Some(1.0),
        w_familiarity: Some(0.2),
        rho_self: Some(0.15),
        boredom_gamma: Some(0.5),
        self_smoothing_radius: Some(0),
        silence_mass_epsilon: Some(1e-3),
    };
    let mut ctx = PerceptualContext::from_config(&config, 4);
    let features = FeaturesNow {
        distribution: vec![0.25, 0.25, 0.25, 0.25],
        mass: 1e-4,
    };
    let idx = 1;
    let adj0 = ctx.score_adjustment(idx);
    ctx.update(idx, &features, 0.2);
    let adj1 = ctx.score_adjustment(idx);
    assert!(
        adj1 < adj0,
        "expected self-update when mass is below epsilon"
    );
}

#[test]
fn articulation_snapshot_kuramoto_signature() {
    let fs = 48_000.0;
    let mut rng = rand::rngs::StdRng::seed_from_u64(11);
    let core = ArticulationCoreConfig::Entrain {
        lifecycle: LifecycleConfig::Sustain {
            initial_energy: 1.0,
            metabolism_rate: 0.0,
            recharge_rate: Some(0.5),
            action_cost: Some(0.02),
            envelope: EnvelopeConfig {
                attack_sec: 0.01,
                decay_sec: 0.1,
                sustain_level: 0.8,
            },
        },
        rhythm_freq: Some(6.0),
        rhythm_sensitivity: None,
        breath_gain_init: None,
    };
    let mut articulation =
        super::individual::AnyArticulationCore::from_config(&core, fs, 7, &mut rng);
    let mut rhythms = NeuralRhythms {
        theta: RhythmBand {
            phase: 0.0,
            freq_hz: 6.0,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.2,
        },
        delta: RhythmBand {
            phase: 0.0,
            freq_hz: 0.5,
            mag: 1.0,
            alpha: 1.0,
            beta: 0.0,
        },
        env_level: 1.0,
        env_open: 1.0,
    };
    let dt = 1.0 / fs;
    let consonance = 0.7;
    let mut signature = 0u64;

    for _ in 0..20_000 {
        let signal = articulation.process(consonance, &rhythms, dt, 1.0);
        signature = mix_signature(signature, signal.is_active as u32);
        signature = mix_signature(signature, signal.amplitude.to_bits());
        signature = mix_signature(signature, signal.relaxation.to_bits());
        signature = mix_signature(signature, signal.tension.to_bits());
        rhythms.advance_in_place(dt);
    }

    println!("articulation signature: {signature:016x}");
    assert_eq!(signature, 0x377c_d318_ee77_c649);
}
</file>

<file path="src/life/phonation_engine.rs">
use rand::{Rng, SeedableRng, rngs::SmallRng};
use std::cmp::{Ordering, Reverse};
use std::collections::BinaryHeap;
use std::f32::consts::TAU;
use std::fmt;

use crate::core::modulation::NeuralRhythms;
use crate::core::timebase::Tick;
use crate::life::gate_clock::next_gate_tick;
use crate::life::scenario::{
    PhonationClockConfig, PhonationConfig, PhonationConnectConfig, PhonationIntervalConfig,
    PhonationMode, SubThetaModConfig,
};
use crate::life::social_density::SocialDensityTrace;

pub type NoteId = u64;

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum PhonationKick {
    Planned { strength: f32 },
}

impl PhonationKick {
    pub fn strength(self) -> f32 {
        match self {
            PhonationKick::Planned { strength } => strength,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Default)]
pub struct PhonationUpdate {
    pub target_freq_hz: Option<f32>,
    /// Final output target amp (linear).
    pub target_amp: Option<f32>,
}

impl PhonationUpdate {
    pub fn is_empty(&self) -> bool {
        self.target_freq_hz.is_none() && self.target_amp.is_none()
    }
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum PhonationCmd {
    NoteOn {
        note_id: NoteId,
        kick: PhonationKick,
    },
    NoteOff {
        note_id: NoteId,
        off_tick: Tick,
    },
    Update {
        note_id: NoteId,
        at_tick: Option<Tick>,
        update: PhonationUpdate,
    },
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ClockSource {
    GateBoundary,
    Subdivision { n: u32 },
    InternalPhase,
}

#[derive(Debug, Clone)]
pub struct CandidatePoint {
    pub tick: Tick,
    pub gate: u64,
    pub theta_pos: f64,
    pub phase_in_gate: f32,
    pub sources: Vec<ClockSource>,
}

#[derive(Debug, Clone, Copy)]
pub struct IntervalInput {
    pub gate: u64,
    pub tick: Tick,
    pub dt_theta: f32,
    pub dt_sec: f32,
    pub weight: f32,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct GateBoundary {
    pub gate: u64,
    pub tick: Tick,
}

#[derive(Debug, Clone, Default, PartialEq)]
pub struct ThetaGrid {
    pub boundaries: Vec<GateBoundary>,
}

impl ThetaGrid {
    /// Input candidates must be sorted by tick ascending.
    pub fn from_candidates(candidates: &[CandidatePoint]) -> Self {
        debug_assert!(
            candidates.windows(2).all(|p| p[0].tick <= p[1].tick),
            "candidates must be sorted by tick"
        );
        let mut boundaries = Vec::with_capacity(candidates.len());
        let mut last_gate = None;
        let mut last_tick = None;
        for candidate in candidates {
            if candidate.phase_in_gate != 0.0 {
                continue;
            }
            if let Some(prev_gate) = last_gate {
                if candidate.gate < prev_gate {
                    panic!("candidate gates must be non-decreasing");
                }
                if candidate.gate == prev_gate {
                    continue;
                }
                debug_assert!(
                    candidate.gate == prev_gate.saturating_add(1),
                    "theta grid gates must be contiguous"
                );
                if candidate.gate != prev_gate.saturating_add(1) {
                    continue;
                }
                if let Some(prev_tick) = last_tick {
                    debug_assert!(
                        candidate.tick >= prev_tick,
                        "theta grid ticks must be non-decreasing"
                    );
                    if candidate.tick < prev_tick {
                        continue;
                    }
                }
            }
            boundaries.push(GateBoundary {
                gate: candidate.gate,
                tick: candidate.tick,
            });
            last_gate = Some(candidate.gate);
            last_tick = Some(candidate.tick);
        }
        Self { boundaries }
    }

    fn boundaries_for_gate(&self, gate: u64) -> Option<(GateBoundary, GateBoundary)> {
        if self.boundaries.is_empty() {
            return None;
        }
        let start_gate = self.boundaries[0].gate;
        let idx = gate.checked_sub(start_gate)? as usize;
        let next_idx = idx.checked_add(1)?;
        let b0 = *self.boundaries.get(idx)?;
        let b1 = *self.boundaries.get(next_idx)?;
        if b0.gate != gate || b1.gate != gate.saturating_add(1) {
            return None;
        }
        Some((b0, b1))
    }

    /// Returns a tick by rounding the interpolated position, clamping interior phases away from
    /// gate boundary ticks.
    pub fn tick_at(&self, gate: u64, phase_in_gate: f32) -> Option<Tick> {
        let (b0, b1) = self.boundaries_for_gate(gate)?;
        let phase = phase_in_gate.clamp(0.0, 1.0);
        if phase > 0.0 && phase < 1.0 && b1.tick <= b0.tick.saturating_add(1) {
            return None;
        }
        let dt = b1.tick.saturating_sub(b0.tick) as f64;
        let tick_f = b0.tick as f64 + dt * phase as f64;
        let tick = tick_f.round() as Tick;
        if phase > 0.0 && phase < 1.0 {
            let lo = b0.tick.saturating_add(1);
            let hi = b1.tick.saturating_sub(1);
            if lo > hi {
                return None;
            }
            return Some(tick.clamp(lo, hi));
        }
        Some(tick)
    }

    pub fn ensure_boundaries_until(&mut self, ctx: &CoreTickCtx, target_gate_plus_1: u64) {
        const MAX_EXTRA_GATES: u64 = 4096;
        let Some(mut last) = self.boundaries.last().copied() else {
            return;
        };
        if last.gate >= target_gate_plus_1 {
            return;
        }
        let mut cursor_tick = last.tick;
        let mut next_gate = last.gate.saturating_add(1);
        let mut added = 0u64;
        while last.gate < target_gate_plus_1 && added < MAX_EXTRA_GATES {
            let search_tick = cursor_tick.saturating_add(1);
            let Some(mut next_tick) = next_gate_tick(search_tick, ctx.fs, ctx.rhythms.theta, 0.0)
            else {
                break;
            };
            // Failsafe: if the clock still returns a non-advancing tick, force monotonic progress.
            if next_tick <= cursor_tick {
                next_tick = cursor_tick.saturating_add(1);
            }
            if next_tick <= cursor_tick {
                break;
            }
            let boundary = GateBoundary {
                gate: next_gate,
                tick: next_tick,
            };
            self.boundaries.push(boundary);
            last = boundary;
            cursor_tick = next_tick;
            next_gate = next_gate.saturating_add(1);
            added += 1;
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct TimingField {
    pub start_gate: u64,
    pub e_gate: Vec<f32>,
}

impl TimingField {
    pub fn from_values(start_gate: u64, e_gate: Vec<f32>) -> Self {
        Self { start_gate, e_gate }
    }

    pub fn build_from(
        ctx: &CoreTickCtx,
        grid: &ThetaGrid,
        social: Option<(&SocialDensityTrace, f32)>,
    ) -> Self {
        const MAX_GATES_PER_HOP: u64 = 4096;
        if grid.boundaries.is_empty() {
            return Self {
                start_gate: 0,
                e_gate: Vec::new(),
            };
        }
        debug_assert!(
            grid.boundaries
                .windows(2)
                .all(|pair| pair[0].tick <= pair[1].tick)
        );
        debug_assert!(
            grid.boundaries
                .windows(2)
                .all(|pair| pair[0].gate < pair[1].gate)
        );
        let mut rhythms = ctx.rhythms;
        let mut cursor_tick = ctx.now_tick;
        let mut e_gate = Vec::with_capacity(grid.boundaries.len());
        let mut expected_gate = grid.boundaries[0].gate;
        let mut last_weight = None;
        for boundary in &grid.boundaries {
            if boundary.tick > cursor_tick {
                let dt_sec = (boundary.tick - cursor_tick) as f32 / ctx.fs;
                rhythms.advance_in_place(dt_sec);
                cursor_tick = boundary.tick;
            }
            let mut weight = rhythms.env_open.clamp(0.0, 1.0);
            match social {
                Some((trace, coupling)) if coupling != 0.0 => {
                    let density = trace.density_at(boundary.tick);
                    if density.is_finite() {
                        let arg = (coupling * density).clamp(-10.0, 10.0);
                        weight = (weight * arg.exp()).max(0.0);
                        if !weight.is_finite() {
                            weight = 0.0;
                        }
                    }
                }
                _ => {}
            }
            if boundary.gate > expected_gate {
                let fill_weight = last_weight.unwrap_or(1.0);
                let missing = boundary.gate - expected_gate;
                if missing > MAX_GATES_PER_HOP {
                    panic!("timing field gap too large: missing={missing}");
                }
                // Fill gaps to keep gate-indexed lookups contiguous.
                e_gate.extend(std::iter::repeat_n(fill_weight, missing as usize));
            }
            e_gate.push(weight);
            last_weight = Some(weight);
            expected_gate = boundary.gate.saturating_add(1);
        }
        Self {
            start_gate: grid.boundaries[0].gate,
            e_gate,
        }
    }

    pub fn e(&self, gate: u64) -> f32 {
        if gate < self.start_gate {
            return 1.0;
        }
        let idx = gate - self.start_gate;
        self.e_gate.get(idx as usize).copied().unwrap_or(1.0)
    }
}

#[derive(Debug, Clone, Copy)]
pub struct CoreTickCtx {
    pub now_tick: Tick,
    pub frame_end: Tick,
    pub fs: f32,
    pub rhythms: NeuralRhythms,
}

#[derive(Debug, Clone, Copy)]
pub struct CoreState {
    pub is_alive: bool,
}

pub trait PhonationClock: Send {
    fn gather_candidates(&mut self, ctx: &CoreTickCtx, out: &mut Vec<CandidatePoint>);
}

#[derive(Debug, Default)]
pub struct ThetaGateClock {
    last_gate_tick: Option<Tick>,
    gate_index: u64,
    has_gate: bool,
}

impl ThetaGateClock {
    pub fn gate_index_hint(&self) -> u64 {
        if self.has_gate {
            self.gate_index + 1
        } else {
            0
        }
    }

    fn gather_candidates_with<F>(
        &mut self,
        ctx: &CoreTickCtx,
        out: &mut Vec<CandidatePoint>,
        mut next_gate_tick: F,
    ) where
        F: FnMut(Tick, &CoreTickCtx) -> Option<Tick>,
    {
        let mut cursor = ctx.now_tick;
        while cursor < ctx.frame_end {
            let gate_tick = match next_gate_tick(cursor, ctx) {
                Some(tick) => tick,
                None => return,
            };
            if gate_tick < cursor {
                cursor = cursor.saturating_add(1);
                continue;
            }
            if gate_tick < ctx.now_tick || gate_tick >= ctx.frame_end {
                return;
            }
            if self.last_gate_tick == Some(gate_tick) {
                cursor = gate_tick.saturating_add(1);
                continue;
            }
            if self.has_gate {
                self.gate_index = self.gate_index.saturating_add(1);
            } else {
                self.gate_index = 0;
                self.has_gate = true;
            }
            self.last_gate_tick = Some(gate_tick);
            out.push(CandidatePoint {
                tick: gate_tick,
                gate: self.gate_index,
                theta_pos: self.gate_index as f64,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            });
            cursor = gate_tick.saturating_add(1);
        }
    }
}

impl PhonationClock for ThetaGateClock {
    fn gather_candidates(&mut self, ctx: &CoreTickCtx, out: &mut Vec<CandidatePoint>) {
        self.gather_candidates_with(ctx, out, |cursor, ctx| {
            next_gate_tick(cursor, ctx.fs, ctx.rhythms.theta, 0.0)
        });
    }
}

#[derive(Debug)]
pub struct SubdivisionClock {
    pub divisions: Vec<u32>,
}

impl SubdivisionClock {
    pub fn new(divisions: Vec<u32>) -> Self {
        Self { divisions }
    }

    fn gather_candidates(&self, grid: &ThetaGrid, out: &mut Vec<CandidatePoint>) {
        if grid.boundaries.len() < 2 {
            return;
        }
        for pair in grid.boundaries.windows(2) {
            let b0 = pair[0];
            let b1 = pair[1];
            if b1.gate != b0.gate.saturating_add(1) {
                continue;
            }
            if b1.tick <= b0.tick.saturating_add(1) {
                continue;
            }
            let gate = b0.gate;
            for &n in &self.divisions {
                if n < 2 {
                    continue;
                }
                for k in 1..n {
                    let phase = k as f32 / n as f32;
                    if phase <= 0.0 || phase >= 1.0 {
                        continue;
                    }
                    let tick = match grid.tick_at(gate, phase) {
                        Some(tick) => tick,
                        None => continue,
                    };
                    if tick == b0.tick || tick == b1.tick {
                        continue;
                    }
                    debug_assert!((gate as f64 + phase as f64).is_finite());
                    out.push(CandidatePoint {
                        tick,
                        gate,
                        theta_pos: gate as f64 + phase as f64,
                        phase_in_gate: phase,
                        sources: vec![ClockSource::Subdivision { n }],
                    });
                }
            }
        }
    }
}

#[derive(Debug)]
pub struct InternalPhaseClock {
    pub ratio: f32,
    pub phase: f32,
}

impl InternalPhaseClock {
    pub fn new(ratio: f32, phase: f32) -> Self {
        Self {
            ratio,
            phase: phase.rem_euclid(1.0),
        }
    }

    fn gather_candidates(&mut self, grid: &ThetaGrid, out: &mut Vec<CandidatePoint>) {
        if !self.ratio.is_finite() || self.ratio <= 0.0 {
            return;
        }
        if grid.boundaries.len() < 2 {
            return;
        }
        for pair in grid.boundaries.windows(2) {
            let b0 = pair[0];
            let b1 = pair[1];
            if b1.gate != b0.gate.saturating_add(1) {
                continue;
            }
            if b1.tick <= b0.tick.saturating_add(1) {
                continue;
            }
            let gate = b0.gate;
            let start_phase = self.phase;
            let end_phase = start_phase + self.ratio;
            let wraps = end_phase.floor() as i32;
            for m in 1..=wraps {
                let phase_in_gate = (m as f32 - start_phase) / self.ratio;
                if phase_in_gate <= 0.0 || phase_in_gate >= 1.0 {
                    continue;
                }
                let tick = match grid.tick_at(gate, phase_in_gate) {
                    Some(tick) => tick,
                    None => continue,
                };
                if tick == b0.tick || tick == b1.tick {
                    continue;
                }
                debug_assert!((gate as f64 + phase_in_gate as f64).is_finite());
                out.push(CandidatePoint {
                    tick,
                    gate,
                    theta_pos: gate as f64 + phase_in_gate as f64,
                    phase_in_gate,
                    sources: vec![ClockSource::InternalPhase],
                });
            }
            self.phase = end_phase.rem_euclid(1.0);
        }
    }
}

#[derive(Debug)]
pub struct CompositeClock {
    gate_clock: ThetaGateClock,
    subdivision: Option<SubdivisionClock>,
    internal_phase: Option<InternalPhaseClock>,
}

impl CompositeClock {
    pub fn new(
        gate_clock: ThetaGateClock,
        subdivision: Option<SubdivisionClock>,
        internal_phase: Option<InternalPhaseClock>,
    ) -> Self {
        Self {
            gate_clock,
            subdivision,
            internal_phase,
        }
    }
}

impl PhonationClock for CompositeClock {
    fn gather_candidates(&mut self, ctx: &CoreTickCtx, out: &mut Vec<CandidatePoint>) {
        let mut gate_candidates = Vec::new();
        self.gate_clock.gather_candidates(ctx, &mut gate_candidates);
        out.extend(gate_candidates.iter().cloned());
        let grid = ThetaGrid::from_candidates(&gate_candidates);
        if let Some(clock) = self.subdivision.as_ref() {
            clock.gather_candidates(&grid, out);
        }
        if let Some(clock) = self.internal_phase.as_mut() {
            clock.gather_candidates(&grid, out);
        }
    }
}

pub trait PhonationInterval: Send {
    fn on_candidate(&mut self, c: &IntervalInput, state: &CoreState) -> Option<PhonationKick>;
}

pub trait SubThetaMod: Send + Sync {
    fn mod_at_phase(&self, phase_in_gate: f32) -> f32;
}

#[derive(Debug, Default)]
pub struct NoneMod;

impl SubThetaMod for NoneMod {
    fn mod_at_phase(&self, _phase_in_gate: f32) -> f32 {
        1.0
    }
}

#[derive(Debug)]
pub struct CosineHarmonicMod {
    pub n: u32,
    pub depth: f32,
    pub phase0: f32,
}

impl SubThetaMod for CosineHarmonicMod {
    fn mod_at_phase(&self, phase_in_gate: f32) -> f32 {
        let depth = self.depth.clamp(0.0, 1.0);
        let phase = phase_in_gate.rem_euclid(1.0);
        1.0 + depth * (TAU * self.n as f32 * phase + self.phase0).cos()
    }
}

#[derive(Debug, Default)]
pub struct NoneInterval;

impl PhonationInterval for NoneInterval {
    fn on_candidate(&mut self, _c: &IntervalInput, _state: &CoreState) -> Option<PhonationKick> {
        None
    }
}

#[derive(Debug)]
pub struct AccumulatorInterval {
    pub rate_hz: f32,
    pub refractory_gates: u32,
    pub acc: f32,
    pub next_allowed_gate: u64,
}

impl AccumulatorInterval {
    pub fn new(rate_hz: f32, refractory_gates: u32, seed: u64) -> Self {
        let mut rng = SmallRng::seed_from_u64(seed);
        let acc = rng.random_range(0.7..1.0);
        Self {
            rate_hz,
            refractory_gates,
            acc,
            next_allowed_gate: 0,
        }
    }
}

impl PhonationInterval for AccumulatorInterval {
    fn on_candidate(&mut self, c: &IntervalInput, _state: &CoreState) -> Option<PhonationKick> {
        const ACC_MAX: f32 = 32.0;
        if !_state.is_alive {
            return None;
        }
        if !self.rate_hz.is_finite() || self.rate_hz <= 0.0 {
            return None;
        }
        let weight = c.weight.max(0.0);
        self.acc += self.rate_hz * weight * c.dt_sec;
        if !self.acc.is_finite() || self.acc > ACC_MAX {
            self.acc = ACC_MAX;
        }
        let refractory_ok = c.gate >= self.next_allowed_gate;
        if self.acc >= 1.0 && refractory_ok {
            self.acc -= 1.0;
            self.next_allowed_gate = c.gate + self.refractory_gates as u64 + 1;
            return Some(PhonationKick::Planned { strength: 1.0 });
        }
        None
    }
}

#[derive(Debug, Clone, Copy)]
pub struct ConnectNow {
    pub tick: Tick,
    pub gate: u64,
    pub theta_pos: f64,
}

#[derive(Debug, Clone, Copy)]
pub struct ConnectOnset {
    pub note_id: NoteId,
    pub tick: Tick,
    pub gate: u64,
    pub theta_pos: f64,
    pub exc_gate: f32,
    pub exc_slope: f32,
}

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum ConnectPlan {
    None,
    HoldTheta(f32),
}

pub trait PhonationConnect: Send {
    /// If on_note_on returns ConnectPlan::HoldTheta, the engine schedules the NoteOff via
    /// its pending-off queue, and implementations must not emit a NoteOff for that note_id in poll.
    fn on_note_on(&mut self, onset: ConnectOnset) -> ConnectPlan;
    fn poll(&mut self, now: ConnectNow, out: &mut Vec<PhonationCmd>);
}

#[derive(Debug)]
pub struct FixedGateConnect {
    pub length_gates: u32,
    pending: Vec<(NoteId, u64)>,
}

impl FixedGateConnect {
    pub fn new(length_gates: u32) -> Self {
        Self {
            length_gates,
            pending: Vec::new(),
        }
    }
}

impl PhonationConnect for FixedGateConnect {
    fn on_note_on(&mut self, onset: ConnectOnset) -> ConnectPlan {
        let off_gate = onset.gate + self.length_gates as u64;
        self.pending.push((onset.note_id, off_gate));
        ConnectPlan::None
    }

    fn poll(&mut self, now: ConnectNow, out: &mut Vec<PhonationCmd>) {
        let mut idx = 0;
        while idx < self.pending.len() {
            if self.pending[idx].1 <= now.gate {
                let note_id = self.pending[idx].0;
                self.pending.swap_remove(idx);
                out.push(PhonationCmd::NoteOff {
                    note_id,
                    off_tick: now.tick,
                });
            } else {
                idx += 1;
            }
        }
    }
}

#[derive(Debug)]
pub struct FieldConnect {
    pub hold_min_theta: f32,
    pub hold_max_theta: f32,
    pub curve_k: f32,
    pub curve_x0: f32,
    pub drop_gain: f32,
}

impl FieldConnect {
    pub fn new(
        hold_min_theta: f32,
        hold_max_theta: f32,
        curve_k: f32,
        curve_x0: f32,
        drop_gain: f32,
    ) -> Self {
        let hold_min_theta = if hold_min_theta.is_finite() {
            hold_min_theta.max(0.0)
        } else {
            0.25
        };
        let mut hold_max_theta = if hold_max_theta.is_finite() {
            hold_max_theta.max(0.0)
        } else {
            1.0
        };
        if hold_max_theta < hold_min_theta {
            hold_max_theta = hold_min_theta;
        }
        let curve_k = if curve_k.is_finite() { curve_k } else { 4.0 };
        let curve_x0 = if curve_x0.is_finite() { curve_x0 } else { 0.5 };
        let drop_gain = if drop_gain.is_finite() {
            drop_gain
        } else {
            0.0
        };
        Self {
            hold_min_theta,
            hold_max_theta,
            curve_k,
            curve_x0,
            drop_gain,
        }
    }

    fn hold_theta(&self, exc_gate: f32, exc_slope: f32) -> f32 {
        let min = self.hold_min_theta.max(0.0);
        let max = self.hold_max_theta.max(min);
        let p = 1.0 / (1.0 + (-(self.curve_k * (exc_gate - self.curve_x0))).exp());
        let mut hold = min + (max - min) * p;
        if self.drop_gain > 0.0 && exc_slope.is_finite() {
            let drop = (-exc_slope).max(0.0).clamp(0.0, 1.0);
            hold *= 1.0 - self.drop_gain.clamp(0.0, 1.0) * drop;
        }
        hold.max(0.0)
    }
}

impl PhonationConnect for FieldConnect {
    fn on_note_on(&mut self, onset: ConnectOnset) -> ConnectPlan {
        let exc_gate = onset.exc_gate.clamp(0.0, 1.0);
        let hold = self.hold_theta(exc_gate, onset.exc_slope);
        ConnectPlan::HoldTheta(hold)
    }

    fn poll(&mut self, now: ConnectNow, out: &mut Vec<PhonationCmd>) {
        let _ = now;
        let _ = out;
    }
}

#[derive(Debug, Clone, Copy)]
pub struct PhonationNoteEvent {
    pub note_id: NoteId,
    pub onset_tick: Tick,
}

#[derive(Debug, Clone, Copy)]
pub struct OnsetEvent {
    pub gate: u64,
    pub onset_tick: Tick,
    pub strength: f32,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
struct PendingOff {
    off_tick: Tick,
    note_id: NoteId,
}

impl Ord for PendingOff {
    fn cmp(&self, other: &Self) -> Ordering {
        self.off_tick
            .cmp(&other.off_tick)
            .then_with(|| self.note_id.cmp(&other.note_id))
    }
}

impl PartialOrd for PendingOff {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}

#[derive(Debug, Default)]
struct HoldCore {
    note_on_sent: bool,
    note_id: Option<NoteId>,
}

pub struct PhonationEngine {
    pub clock: Box<dyn PhonationClock + Send>,
    pub interval: Box<dyn PhonationInterval + Send>,
    pub connect: Box<dyn PhonationConnect + Send>,
    pub sub_theta_mod: Box<dyn SubThetaMod + Send + Sync>,
    pub mode: PhonationMode,
    hold: HoldCore,
    pub next_note_id: NoteId,
    last_gate_index: Option<u64>,
    last_theta_pos: Option<f64>,
    last_tick: Option<Tick>,
    active_notes: u32,
    pending_off: BinaryHeap<Reverse<PendingOff>>,
    scratch_candidates: Vec<CandidatePoint>,
    scratch_merged: Vec<CandidatePoint>,
}

impl fmt::Debug for PhonationEngine {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("PhonationEngine")
            .field("next_note_id", &self.next_note_id)
            .field("last_gate_index", &self.last_gate_index)
            .field("active_notes", &self.active_notes)
            .field("mode", &self.mode)
            .finish()
    }
}

impl PhonationEngine {
    pub fn from_config(config: &PhonationConfig, seed: u64) -> Self {
        let interval: Box<dyn PhonationInterval + Send> = match config.interval {
            PhonationIntervalConfig::None => Box::<NoneInterval>::default(),
            PhonationIntervalConfig::Accumulator {
                rate: rate_hz,
                refractory,
            } => Box::new(AccumulatorInterval::new(rate_hz, refractory, seed)),
        };
        let sub_theta_mod: Box<dyn SubThetaMod + Send + Sync> = match &config.sub_theta_mod {
            SubThetaModConfig::None => Box::<NoneMod>::default(),
            SubThetaModConfig::Cosine { n, depth, phase0 } => Box::new(CosineHarmonicMod {
                n: *n,
                depth: *depth,
                phase0: *phase0,
            }),
        };
        let connect: Box<dyn PhonationConnect + Send> = match config.connect {
            PhonationConnectConfig::FixedGate { length_gates } => {
                Box::new(FixedGateConnect::new(length_gates))
            }
            PhonationConnectConfig::Field {
                hold_min_theta,
                hold_max_theta,
                curve_k,
                curve_x0,
                drop_gain,
            } => Box::new(FieldConnect::new(
                hold_min_theta,
                hold_max_theta,
                curve_k,
                curve_x0,
                drop_gain,
            )),
        };
        let (subdivision, internal_phase) = match &config.clock {
            PhonationClockConfig::ThetaGate => (None, None),
            PhonationClockConfig::Composite {
                subdivision,
                internal_phase,
            } => {
                let subdivision = subdivision
                    .as_ref()
                    .map(|config| SubdivisionClock::new(config.divisions.clone()));
                let internal_phase = internal_phase
                    .as_ref()
                    .map(|config| InternalPhaseClock::new(config.ratio, config.phase0));
                (subdivision, internal_phase)
            }
        };
        Self {
            clock: match &config.clock {
                PhonationClockConfig::ThetaGate => Box::<ThetaGateClock>::default(),
                PhonationClockConfig::Composite { .. } => Box::new(CompositeClock::new(
                    ThetaGateClock::default(),
                    subdivision,
                    internal_phase,
                )),
            },
            interval,
            connect,
            sub_theta_mod,
            mode: config.mode,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        }
    }

    pub fn has_active_notes(&self) -> bool {
        self.active_notes > 0
    }

    fn tick_hold(
        &mut self,
        ctx: &CoreTickCtx,
        state: &CoreState,
        min_allowed_onset_tick: Option<Tick>,
        out_cmds: &mut Vec<PhonationCmd>,
        out_events: &mut Vec<PhonationNoteEvent>,
        out_onsets: &mut Vec<OnsetEvent>,
    ) {
        let allow_onset = min_allowed_onset_tick
            .map(|min_tick| ctx.now_tick >= min_tick)
            .unwrap_or(true);
        if allow_onset && state.is_alive && !self.hold.note_on_sent {
            let note_id = self.next_note_id;
            self.next_note_id = self.next_note_id.wrapping_add(1);
            self.hold.note_on_sent = true;
            self.hold.note_id = Some(note_id);
            out_cmds.push(PhonationCmd::NoteOn {
                note_id,
                kick: PhonationKick::Planned { strength: 1.0 },
            });
            self.active_notes = self.active_notes.saturating_add(1);
            out_events.push(PhonationNoteEvent {
                note_id,
                onset_tick: ctx.now_tick,
            });
            out_onsets.push(OnsetEvent {
                gate: 0,
                onset_tick: ctx.now_tick,
                strength: 1.0,
            });
        }
        if !state.is_alive
            && let Some(note_id) = self.hold.note_id.take()
        {
            out_cmds.push(PhonationCmd::NoteOff {
                note_id,
                off_tick: ctx.now_tick,
            });
            self.active_notes = self.active_notes.saturating_sub(1);
        }
    }

    fn schedule_note_off(&mut self, note_id: NoteId, off_tick: Tick) {
        self.pending_off
            .push(Reverse(PendingOff { off_tick, note_id }));
    }

    fn drain_note_offs(&mut self, up_to_tick: Tick, out_cmds: &mut Vec<PhonationCmd>) {
        while let Some(Reverse(next)) = self.pending_off.peek().copied() {
            if next.off_tick > up_to_tick {
                break;
            }
            self.pending_off.pop();
            out_cmds.push(PhonationCmd::NoteOff {
                note_id: next.note_id,
                off_tick: next.off_tick,
            });
            self.active_notes = self.active_notes.saturating_sub(1);
        }
    }

    fn schedule_hold_theta(
        &mut self,
        onset: ConnectOnset,
        hold_theta: f32,
        ctx: &CoreTickCtx,
        timing_grid: &mut ThetaGrid,
    ) {
        let hold_theta = if hold_theta.is_finite() {
            hold_theta.max(0.0)
        } else {
            0.0
        };
        let off_theta = onset.theta_pos + hold_theta as f64;
        let off_tick_opt = Self::tick_for_theta(off_theta, ctx, timing_grid);
        let fallback = timing_grid
            .boundaries
            .last()
            .map(|boundary| boundary.tick)
            .unwrap_or(onset.tick);
        let off_tick = off_tick_opt.unwrap_or(fallback).max(onset.tick);
        self.schedule_note_off(onset.note_id, off_tick);
    }

    fn tick_for_theta(
        theta_pos: f64,
        ctx: &CoreTickCtx,
        timing_grid: &mut ThetaGrid,
    ) -> Option<Tick> {
        if !theta_pos.is_finite() || theta_pos < 0.0 {
            return None;
        }
        let off_gate_f = theta_pos.floor();
        if off_gate_f >= u64::MAX as f64 {
            return None;
        }
        let mut off_gate = off_gate_f as u64;
        let mut off_phase = (theta_pos - off_gate_f).clamp(0.0, 1.0);
        if off_phase >= 1.0 {
            off_phase = 0.0;
            off_gate = off_gate.saturating_add(1);
        }
        timing_grid.ensure_boundaries_until(ctx, off_gate.saturating_add(1));
        timing_grid.tick_at(off_gate, off_phase as f32)
    }

    #[allow(clippy::too_many_arguments)]
    pub fn tick(
        &mut self,
        ctx: &CoreTickCtx,
        state: &CoreState,
        social: Option<&SocialDensityTrace>,
        social_coupling: f32,
        min_allowed_onset_tick: Option<Tick>,
        out_cmds: &mut Vec<PhonationCmd>,
        out_events: &mut Vec<PhonationNoteEvent>,
        out_onsets: &mut Vec<OnsetEvent>,
    ) {
        if matches!(self.mode, PhonationMode::Hold) {
            self.tick_hold(
                ctx,
                state,
                min_allowed_onset_tick,
                out_cmds,
                out_events,
                out_onsets,
            );
            return;
        }
        self.scratch_candidates.clear();
        self.clock
            .gather_candidates(ctx, &mut self.scratch_candidates);
        Self::merge_candidates_into(&mut self.scratch_merged, &mut self.scratch_candidates);
        let merged = std::mem::take(&mut self.scratch_merged);
        let mut timing_grid = ThetaGrid::from_candidates(&merged);
        let timing_field = TimingField::build_from(
            ctx,
            &timing_grid,
            social.map(|trace| (trace, social_coupling)),
        );
        self.process_candidates(
            ctx,
            &merged,
            &mut timing_grid,
            &timing_field,
            state,
            min_allowed_onset_tick,
            out_cmds,
            out_events,
            out_onsets,
        );
        self.scratch_merged = merged;
    }

    #[allow(clippy::too_many_arguments)]
    fn process_candidates(
        &mut self,
        ctx: &CoreTickCtx,
        candidates: &[CandidatePoint],
        timing_grid: &mut ThetaGrid,
        timing_field: &TimingField,
        state: &CoreState,
        min_allowed_onset_tick: Option<Tick>,
        out_cmds: &mut Vec<PhonationCmd>,
        out_events: &mut Vec<PhonationNoteEvent>,
        out_onsets: &mut Vec<OnsetEvent>,
    ) {
        let mut prev_gate_exc: Option<f32> = None;
        self.drain_note_offs(ctx.now_tick, out_cmds);
        for c in candidates {
            let allow_onset = min_allowed_onset_tick
                .map(|min_tick| c.tick >= min_tick)
                .unwrap_or(true);
            debug_assert!(c.theta_pos.is_finite());
            self.drain_note_offs(c.tick, out_cmds);
            // dt_theta spec: same tick -> 0; negative/non-finite delta -> 0 (debug assert);
            // NaN/Inf after cast -> 0.
            let dt_theta = if self.last_tick == Some(c.tick) {
                0.0
            } else {
                match self.last_theta_pos {
                    Some(prev_pos) => {
                        let dt = c.theta_pos - prev_pos;
                        if !dt.is_finite() {
                            debug_assert!(false, "candidate theta_pos delta must be finite");
                            0.0
                        } else if dt < 0.0 {
                            debug_assert!(false, "candidate theta_pos must be non-decreasing");
                            0.0
                        } else {
                            let dt_f32 = dt as f32;
                            if dt_f32.is_finite() { dt_f32 } else { 0.0 }
                        }
                    }
                    None => 1.0,
                }
            };
            let dt_sec = if self.last_tick == Some(c.tick) {
                0.0
            } else {
                match self.last_tick {
                    Some(prev_tick) => {
                        if c.tick < prev_tick {
                            debug_assert!(false, "candidate ticks must be non-decreasing");
                            0.0
                        } else {
                            let dt_ticks = c.tick - prev_tick;
                            let dt = dt_ticks as f32 / ctx.fs;
                            if dt.is_finite() { dt } else { 0.0 }
                        }
                    }
                    None => 0.0,
                }
            };
            let exc_gate = timing_field.e(c.gate);
            let exc_slope = match prev_gate_exc {
                Some(prev_exc) => (exc_gate - prev_exc).clamp(-1.0, 1.0),
                None => 0.0,
            };
            let connect_now = ConnectNow {
                tick: c.tick,
                gate: c.gate,
                theta_pos: c.theta_pos,
            };
            let before = out_cmds.len();
            self.connect.poll(connect_now, out_cmds);
            for cmd in &out_cmds[before..] {
                if matches!(cmd, PhonationCmd::NoteOff { .. }) {
                    self.active_notes = self.active_notes.saturating_sub(1);
                }
            }
            let sub_theta_mod = if c.phase_in_gate == 0.0 {
                1.0
            } else {
                self.sub_theta_mod.mod_at_phase(c.phase_in_gate)
            };
            let input = IntervalInput {
                gate: c.gate,
                tick: c.tick,
                dt_theta,
                dt_sec,
                weight: exc_gate * sub_theta_mod,
            };
            if allow_onset && let Some(kick) = self.interval.on_candidate(&input, state) {
                let note_id = self.next_note_id;
                self.next_note_id = self.next_note_id.wrapping_add(1);
                out_cmds.push(PhonationCmd::NoteOn { note_id, kick });
                self.active_notes = self.active_notes.saturating_add(1);
                out_events.push(PhonationNoteEvent {
                    note_id,
                    onset_tick: c.tick,
                });
                out_onsets.push(OnsetEvent {
                    gate: c.gate,
                    onset_tick: c.tick,
                    strength: kick.strength(),
                });
                let onset = ConnectOnset {
                    note_id,
                    tick: c.tick,
                    gate: c.gate,
                    theta_pos: c.theta_pos,
                    exc_gate,
                    exc_slope,
                };
                let plan = self.connect.on_note_on(onset);
                if let ConnectPlan::HoldTheta(hold_theta) = plan {
                    self.schedule_hold_theta(onset, hold_theta, ctx, timing_grid);
                }
            }
            self.last_gate_index = Some(c.gate);
            let before = out_cmds.len();
            self.connect.poll(connect_now, out_cmds);
            for cmd in &out_cmds[before..] {
                if matches!(cmd, PhonationCmd::NoteOff { .. }) {
                    self.active_notes = self.active_notes.saturating_sub(1);
                }
            }
            self.last_theta_pos = Some(c.theta_pos);
            self.last_tick = Some(c.tick);
            if c.phase_in_gate == 0.0 {
                prev_gate_exc = Some(exc_gate);
            }
        }
        self.drain_note_offs(ctx.frame_end.saturating_sub(1), out_cmds);
    }

    /// Merge rules:
    /// - sort by (tick, gate, phase_in_gate)
    /// - merge only when tick and gate match
    /// - prefer phase_in_gate == 0.0 (GateBoundary) as the representative
    /// - append sources (duplicates allowed)
    #[cfg(test)]
    fn merge_candidates(mut candidates: Vec<CandidatePoint>) -> Vec<CandidatePoint> {
        let mut merged = Vec::with_capacity(candidates.len());
        Self::merge_candidates_into(&mut merged, &mut candidates);
        merged
    }

    fn merge_candidates_into(out: &mut Vec<CandidatePoint>, candidates: &mut Vec<CandidatePoint>) {
        candidates.sort_by(|a, b| {
            a.tick
                .cmp(&b.tick)
                .then_with(|| a.gate.cmp(&b.gate))
                .then_with(|| a.phase_in_gate.total_cmp(&b.phase_in_gate))
        });
        out.clear();
        out.reserve(candidates.len());
        for candidate in candidates.drain(..) {
            if let Some(last) = out.last_mut()
                && last.tick == candidate.tick
                && last.gate == candidate.gate
            {
                if last.phase_in_gate != 0.0 && candidate.phase_in_gate == 0.0 {
                    let mut replacement = candidate;
                    replacement.sources.append(&mut last.sources);
                    *last = replacement;
                    continue;
                }
                last.sources.extend(candidate.sources);
                continue;
            }
            out.push(candidate);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BinaryHeap;
    use std::sync::{Arc, Mutex};

    fn candidate_at_gate(gate: u64) -> CandidatePoint {
        CandidatePoint {
            tick: gate as u64,
            gate,
            theta_pos: gate as f64,
            phase_in_gate: 0.0,
            sources: vec![ClockSource::GateBoundary],
        }
    }

    #[test]
    fn accumulator_rate_zero_never_fires() {
        let mut interval = AccumulatorInterval::new(0.0, 0, 1);
        interval.acc = 0.0;
        let state = CoreState { is_alive: true };
        for gate in 0..10u64 {
            let c = candidate_at_gate(gate);
            let input = IntervalInput {
                gate: c.gate,
                tick: c.tick,
                dt_theta: 1.0,
                dt_sec: 1.0,
                weight: 1.0,
            };
            assert!(interval.on_candidate(&input, &state).is_none());
        }
    }

    #[test]
    fn accumulator_rate_half_fires_every_other_gate() {
        let mut interval = AccumulatorInterval::new(0.5, 0, 1);
        interval.acc = 0.0;
        let state = CoreState { is_alive: true };
        let mut fired = Vec::new();
        for gate in 0..10u64 {
            let c = candidate_at_gate(gate);
            let input = IntervalInput {
                gate: c.gate,
                tick: c.tick,
                dt_theta: 1.0,
                dt_sec: 1.0,
                weight: 1.0,
            };
            if interval.on_candidate(&input, &state).is_some() {
                fired.push(gate);
            }
        }
        assert_eq!(fired, vec![1u64, 3, 5, 7, 9]);
    }

    #[test]
    fn accumulator_refractory_blocks_adjacent_gates() {
        let mut interval = AccumulatorInterval::new(1.0, 1, 1);
        interval.acc = 0.0;
        let state = CoreState { is_alive: true };
        let mut fired = Vec::new();
        for gate in 0..6u64 {
            let c = candidate_at_gate(gate);
            let input = IntervalInput {
                gate: c.gate,
                tick: c.tick,
                dt_theta: 1.0,
                dt_sec: 1.0,
                weight: 1.0,
            };
            if interval.on_candidate(&input, &state).is_some() {
                fired.push(gate);
            }
        }
        assert_eq!(fired, vec![0u64, 2, 4]);
    }

    #[test]
    fn accumulator_weighted_steps_fire_after_sum() {
        let mut interval = AccumulatorInterval::new(1.0, 0, 1);
        interval.acc = 0.0;
        let state = CoreState { is_alive: true };
        let mut fired = Vec::new();
        let inputs = [
            IntervalInput {
                gate: 0,
                tick: 0,
                dt_theta: 1.0,
                dt_sec: 1.0,
                weight: 0.5,
            },
            IntervalInput {
                gate: 1,
                tick: 1,
                dt_theta: 1.0,
                dt_sec: 1.0,
                weight: 0.5,
            },
        ];
        for input in inputs {
            if interval.on_candidate(&input, &state).is_some() {
                fired.push(input.gate);
            }
        }
        assert_eq!(fired, vec![1u64]);
    }

    #[test]
    fn accumulator_ignores_zero_weight() {
        let mut interval = AccumulatorInterval::new(1.0, 0, 1);
        interval.acc = 0.0;
        let state = CoreState { is_alive: true };
        let input = IntervalInput {
            gate: 0,
            tick: 0,
            dt_theta: 1.0,
            dt_sec: 1.0,
            weight: 0.0,
        };
        assert!(interval.on_candidate(&input, &state).is_none());
    }

    #[test]
    fn accumulator_respects_dt_sec() {
        let mut interval = AccumulatorInterval::new(1.0, 0, 1);
        interval.acc = 0.0;
        let state = CoreState { is_alive: true };
        let input = IntervalInput {
            gate: 0,
            tick: 0,
            dt_theta: 0.5,
            dt_sec: 0.5,
            weight: 1.0,
        };
        assert!(interval.on_candidate(&input, &state).is_none());
        let input = IntervalInput {
            gate: 1,
            tick: 1,
            dt_theta: 0.5,
            dt_sec: 0.5,
            weight: 1.0,
        };
        assert!(interval.on_candidate(&input, &state).is_some());
    }

    #[test]
    fn accumulator_acc_is_clamped() {
        let mut interval = AccumulatorInterval::new(1.0, 0, 1);
        interval.acc = 0.0;
        let state = CoreState { is_alive: true };
        let input = IntervalInput {
            gate: 0,
            tick: 0,
            dt_theta: 1.0,
            dt_sec: 1.0,
            weight: 1.0e9,
        };
        let _ = interval.on_candidate(&input, &state);
        assert!(interval.acc.is_finite());
        assert!(interval.acc <= 32.0);
    }

    #[test]
    fn fixed_gate_connect_sets_off_tick() {
        let mut connect = FixedGateConnect::new(0);
        let mut out = Vec::new();
        let plan = connect.on_note_on(ConnectOnset {
            note_id: 1,
            tick: 123,
            gate: 10,
            theta_pos: 10.0,
            exc_gate: 1.0,
            exc_slope: 0.0,
        });
        assert_eq!(plan, ConnectPlan::None);
        connect.poll(
            ConnectNow {
                tick: 123,
                gate: 10,
                theta_pos: 10.0,
            },
            &mut out,
        );
        assert_eq!(
            out,
            vec![PhonationCmd::NoteOff {
                note_id: 1,
                off_tick: 123,
            }]
        );
    }

    #[test]
    fn theta_gate_clock_emits_multiple_gates_in_hop() {
        let mut clock = ThetaGateClock::default();
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 10,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let mut out = Vec::new();
        let mut calls = 0;
        clock.gather_candidates_with(&ctx, &mut out, |_cursor, _ctx| {
            let tick = match calls {
                0 => Some(0),
                1 => Some(4),
                2 => Some(8),
                _ => None,
            };
            calls += 1;
            tick
        });
        assert!(out.len() >= 2, "expected multiple gates in hop");
        assert!(out[0].tick < out[1].tick);
    }

    #[test]
    fn theta_gate_clock_emits_candidate_at_frame_start_gate() {
        let mut clock = ThetaGateClock::default();
        let rhythms = NeuralRhythms::default();
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 4,
            fs: 1000.0,
            rhythms,
        };
        let mut out = Vec::new();
        clock.gather_candidates_with(&ctx, &mut out, |cursor, _ctx| {
            if cursor == 0 { Some(cursor) } else { None }
        });
        assert_eq!(out.len(), 1);
        assert_eq!(out[0].tick, 0);
    }

    #[test]
    fn phonation_engine_uses_timing_field_weight() {
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 8,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 4,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let timing_field = TimingField::from_values(0, vec![0.0, 1.0]);
        let mut interval = AccumulatorInterval::new(250.0, 0, 1);
        interval.acc = 0.0;
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(interval),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].onset_tick, 4);
    }

    #[test]
    fn timing_field_indexing_from_values() {
        let timing_field = TimingField::from_values(10, vec![0.2, 0.8]);
        assert_eq!(timing_field.e(10), 0.2);
        assert_eq!(timing_field.e(11), 0.8);
        assert_eq!(timing_field.e(12), 1.0);
    }

    #[test]
    fn timing_field_build_from_uses_env_gate() {
        let mut rhythms = NeuralRhythms::default();
        rhythms.env_open = 0.0;
        rhythms.env_level = 1.0;
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 4,
            fs: 1000.0,
            rhythms,
        };
        let grid = ThetaGrid {
            boundaries: vec![GateBoundary { gate: 0, tick: 0 }],
        };
        let timing_field = TimingField::build_from(&ctx, &grid, None);
        assert_eq!(timing_field.e(0), 0.0);
    }

    #[test]
    fn theta_grid_skips_duplicate_gates() {
        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 1,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 2,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let grid = ThetaGrid::from_candidates(&candidates);
        assert_eq!(
            grid.boundaries,
            vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 2 },
            ]
        );
    }

    #[test]
    #[cfg(debug_assertions)]
    #[should_panic]
    fn theta_grid_panics_on_reverse_gates() {
        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 1,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let _ = ThetaGrid::from_candidates(&candidates);
    }

    #[test]
    #[cfg(debug_assertions)]
    #[should_panic]
    fn theta_grid_panics_on_unsorted_ticks() {
        let candidates = vec![
            CandidatePoint {
                tick: 2,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 1,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let _ = ThetaGrid::from_candidates(&candidates);
    }

    #[test]
    #[cfg(debug_assertions)]
    #[should_panic]
    fn theta_grid_panics_on_noncontiguous_gates() {
        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 10,
                gate: 2,
                theta_pos: 2.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let _ = ThetaGrid::from_candidates(&candidates);
    }

    #[test]
    fn timing_field_fill_missing_gates() {
        let mut rhythms = NeuralRhythms::default();
        rhythms.env_open = 0.5;
        rhythms.env_level = 1.0;
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 1,
            fs: 1000.0,
            rhythms,
        };
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 2, tick: 0 },
            ],
        };
        let timing_field = TimingField::build_from(&ctx, &grid, None);
        assert_eq!(timing_field.e(0), 0.5);
        assert_eq!(timing_field.e(1), 0.5);
        assert_eq!(timing_field.e(2), 0.5);
    }

    #[test]
    fn theta_grid_tick_at_interpolates() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 100 },
            ],
        };
        assert_eq!(grid.tick_at(0, 0.5), Some(50));
    }

    #[test]
    fn theta_grid_tick_at_avoids_boundaries() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 10 },
            ],
        };
        assert_ne!(grid.tick_at(0, 0.95), Some(10));
    }

    #[test]
    fn theta_grid_tick_at_returns_none_when_interval_too_small() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 1 },
            ],
        };
        assert_eq!(grid.tick_at(0, 0.5), None);
    }

    #[test]
    fn tick_at_returns_none_on_too_short_interval_for_interior_phase() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 1 },
            ],
        };
        assert_eq!(grid.tick_at(0, 0.5), None);
    }

    #[test]
    fn tick_at_returns_boundary_ticks_for_phase_0_and_1() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 100 },
            ],
        };
        assert_eq!(grid.tick_at(0, 0.0), Some(0));
        assert_eq!(grid.tick_at(0, 1.0), Some(100));
    }

    #[test]
    fn theta_grid_ensure_boundaries_until_uses_next_gate_tick_after_boundary() {
        let mut rhythms = NeuralRhythms::default();
        rhythms.theta.freq_hz = 1.0;
        rhythms.theta.phase = 0.0;
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 1000,
            fs: 100.0,
            rhythms,
        };
        let t0 = 0;
        let expected =
            next_gate_tick(t0 + 1, ctx.fs, ctx.rhythms.theta, 0.0).expect("expected tick");
        let mut grid = ThetaGrid {
            boundaries: vec![GateBoundary { gate: 0, tick: t0 }],
        };
        grid.ensure_boundaries_until(&ctx, 1);
        assert_eq!(grid.boundaries.len(), 2);
        assert_eq!(grid.boundaries[1].tick, expected);
    }

    #[test]
    fn theta_grid_ensure_boundaries_until_is_monotonic() {
        let mut rhythms = NeuralRhythms::default();
        rhythms.theta.freq_hz = 1.0;
        rhythms.theta.phase = 0.0;
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 1000,
            fs: 100.0,
            rhythms,
        };
        let mut grid = ThetaGrid {
            boundaries: vec![GateBoundary { gate: 0, tick: 0 }],
        };
        grid.ensure_boundaries_until(&ctx, 4);
        assert!(grid.boundaries.len() >= 5);
        for pair in grid.boundaries.windows(2) {
            assert_eq!(pair[1].gate, pair[0].gate + 1);
            assert!(pair[1].tick > pair[0].tick);
        }
    }

    #[test]
    fn subdivision_clock_skips_short_interval() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 1 },
            ],
        };
        let mut candidates = Vec::new();
        let clock = SubdivisionClock::new(vec![2]);
        clock.gather_candidates(&grid, &mut candidates);
        assert!(candidates.is_empty());
    }

    #[test]
    fn subdivision_clock_merges_duplicate_ticks() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 100 },
            ],
        };
        let mut candidates = Vec::new();
        let clock = SubdivisionClock::new(vec![2, 4]);
        clock.gather_candidates(&grid, &mut candidates);
        let merged = PhonationEngine::merge_candidates(candidates);
        let tick_50 = merged.iter().find(|c| c.tick == 50).expect("tick 50");
        assert!(tick_50.sources.contains(&ClockSource::Subdivision { n: 2 }));
        assert!(tick_50.sources.contains(&ClockSource::Subdivision { n: 4 }));
    }

    #[test]
    fn dt_theta_is_continuous() {
        let log = Arc::new(Mutex::new(Vec::new()));
        struct RecordingInterval {
            log: Arc<Mutex<Vec<f32>>>,
        }

        impl PhonationInterval for RecordingInterval {
            fn on_candidate(
                &mut self,
                c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                self.log.lock().expect("dt log").push(c.dt_theta);
                None
            }
        }

        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 10,
                gate: 0,
                theta_pos: 0.5,
                phase_in_gate: 0.5,
                sources: vec![ClockSource::Subdivision { n: 2 }],
            },
            CandidatePoint {
                tick: 20,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 30,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let timing_field = TimingField::from_values(0, vec![1.0, 1.0]);
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(RecordingInterval { log: log.clone() }),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert_eq!(*log.lock().expect("dt log"), vec![1.0, 0.5, 0.5]);
    }

    #[test]
    fn dt_theta_zero_when_same_tick() {
        let log = Arc::new(Mutex::new(Vec::new()));
        struct RecordingInterval {
            log: Arc<Mutex<Vec<f32>>>,
        }

        impl PhonationInterval for RecordingInterval {
            fn on_candidate(
                &mut self,
                c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                self.log.lock().expect("dt log").push(c.dt_theta);
                None
            }
        }

        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 0,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 1,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let timing_field = TimingField::from_values(0, vec![1.0, 1.0]);
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(RecordingInterval { log: log.clone() }),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert_eq!(*log.lock().expect("dt log"), vec![1.0, 0.0]);
    }

    #[test]
    #[cfg(debug_assertions)]
    #[should_panic]
    fn dt_theta_panics_on_negative_theta() {
        let candidates = vec![CandidatePoint {
            tick: 1,
            gate: 0,
            theta_pos: 0.0,
            phase_in_gate: 0.0,
            sources: vec![ClockSource::GateBoundary],
        }];
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 2,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let timing_field = TimingField::from_values(0, vec![1.0]);
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::<NoneInterval>::default(),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: Some(1.0),
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
    }

    #[test]
    fn dt_theta_large_gate_precision() {
        let log = Arc::new(Mutex::new(Vec::new()));
        struct RecordingInterval {
            log: Arc<Mutex<Vec<f32>>>,
        }

        impl PhonationInterval for RecordingInterval {
            fn on_candidate(
                &mut self,
                c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                self.log.lock().expect("dt log").push(c.dt_theta);
                None
            }
        }

        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 20_000_000,
                theta_pos: 20_000_000.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 1,
                gate: 20_000_001,
                theta_pos: 20_000_001.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 2,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let timing_field = TimingField::from_values(20_000_000, vec![1.0, 1.0]);
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(RecordingInterval { log: log.clone() }),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert_eq!(*log.lock().expect("dt log"), vec![1.0, 1.0]);
    }

    #[test]
    fn cosine_mod_has_unit_mean() {
        let modulator = CosineHarmonicMod {
            n: 3,
            depth: 0.8,
            phase0: 0.2,
        };
        let mut sum = 0.0;
        let samples = 1000;
        for i in 0..samples {
            let phase = i as f32 / samples as f32;
            sum += modulator.mod_at_phase(phase);
        }
        let avg = sum / samples as f32;
        assert!((avg - 1.0).abs() < 1e-3);
    }

    #[test]
    fn sub_theta_mod_biases_onset() {
        let candidates = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 10,
                gate: 0,
                theta_pos: 0.5,
                phase_in_gate: 0.5,
                sources: vec![ClockSource::Subdivision { n: 2 }],
            },
            CandidatePoint {
                tick: 20,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 30,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let timing_field = TimingField::from_values(0, vec![1.0, 1.0]);
        let mut interval = AccumulatorInterval::new(50.0, 0, 1);
        interval.acc = 0.0;
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(interval),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::new(CosineHarmonicMod {
                n: 1,
                depth: 1.0,
                phase0: -std::f32::consts::PI,
            }),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: Some(0.0),
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert_eq!(events.len(), 1);
        assert_eq!(events[0].onset_tick, 10);
    }

    #[test]
    fn active_notes_tracks_note_on_and_off() {
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 2,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let mut interval = AccumulatorInterval::new(1.0, 0, 1);
        interval.acc = 1.0;
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(interval),
            connect: Box::new(FixedGateConnect::new(0)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let timing_field = TimingField::from_values(0, vec![1.0]);
        let candidates = vec![CandidatePoint {
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            phase_in_gate: 0.0,
            sources: vec![ClockSource::GateBoundary],
        }];
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert_eq!(engine.active_notes, 0, "note on/off should settle to zero");
        assert!(
            cmds.iter()
                .any(|cmd| matches!(cmd, PhonationCmd::NoteOn { .. }))
        );
        assert!(
            cmds.iter()
                .any(|cmd| matches!(cmd, PhonationCmd::NoteOff { .. }))
        );
    }

    #[test]
    fn active_notes_increments_on_note_on() {
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 2,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let mut interval = AccumulatorInterval::new(1.0, 0, 1);
        interval.acc = 1.0;
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(interval),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let timing_field = TimingField::from_values(0, vec![1.0]);
        let candidates = vec![CandidatePoint {
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            phase_in_gate: 0.0,
            sources: vec![ClockSource::GateBoundary],
        }];
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert_eq!(engine.active_notes, 1);
        assert!(
            cmds.iter()
                .any(|cmd| matches!(cmd, PhonationCmd::NoteOn { .. }))
        );
        assert!(
            !cmds
                .iter()
                .any(|cmd| matches!(cmd, PhonationCmd::NoteOff { .. }))
        );
    }

    #[test]
    fn pending_off_drains_without_candidates() {
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 10,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::<NoneInterval>::default(),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        engine.schedule_note_off(42, 5);
        let state = CoreState { is_alive: true };
        let timing_field = TimingField::from_values(0, Vec::new());
        let candidates: Vec<CandidatePoint> = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert!(cmds.iter().any(|cmd| matches!(
            cmd,
            PhonationCmd::NoteOff {
                note_id: 42,
                off_tick: 5
            }
        )));
    }

    #[test]
    fn note_off_emits_before_note_on_when_due() {
        struct AlwaysInterval;

        impl PhonationInterval for AlwaysInterval {
            fn on_candidate(
                &mut self,
                _c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                Some(PhonationKick::Planned { strength: 1.0 })
            }
        }

        struct NoopConnect;

        impl PhonationConnect for NoopConnect {
            fn on_note_on(&mut self, _onset: ConnectOnset) -> ConnectPlan {
                ConnectPlan::None
            }

            fn poll(&mut self, _now: ConnectNow, _out: &mut Vec<PhonationCmd>) {}
        }

        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 2,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let candidates = vec![CandidatePoint {
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            phase_in_gate: 0.0,
            sources: vec![ClockSource::GateBoundary],
        }];
        let timing_field = TimingField::from_values(0, vec![1.0]);
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(AlwaysInterval),
            connect: Box::new(NoopConnect),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        engine.schedule_note_off(99, 0);
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        let off_pos = cmds
            .iter()
            .position(|cmd| matches!(cmd, PhonationCmd::NoteOff { note_id: 99, .. }));
        let on_pos = cmds
            .iter()
            .position(|cmd| matches!(cmd, PhonationCmd::NoteOn { .. }));
        assert!(off_pos.is_some());
        assert!(on_pos.is_some());
        assert!(off_pos < on_pos);
    }

    #[test]
    fn schedule_hold_theta_fallback_never_schedules_before_onset() {
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 1,
            fs: 100.0,
            rhythms: NeuralRhythms::default(),
        };
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::<NoneInterval>::default(),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let onset = ConnectOnset {
            note_id: 7,
            tick: 10,
            gate: 0,
            theta_pos: 0.0,
            exc_gate: 0.0,
            exc_slope: 0.0,
        };
        let mut timing_grid = ThetaGrid {
            boundaries: Vec::new(),
        };
        engine.schedule_hold_theta(onset, 1.0, &ctx, &mut timing_grid);
        let off_tick = engine
            .pending_off
            .peek()
            .map(|entry| entry.0.off_tick)
            .expect("pending off");
        assert!(off_tick >= onset.tick);
    }

    #[test]
    fn schedule_hold_theta_does_not_panic_on_short_interval() {
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 2,
            fs: 100.0,
            rhythms: NeuralRhythms::default(),
        };
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::<NoneInterval>::default(),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let onset = ConnectOnset {
            note_id: 11,
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            exc_gate: 0.0,
            exc_slope: 0.0,
        };
        let mut timing_grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 1 },
            ],
        };
        engine.schedule_hold_theta(onset, 0.5, &ctx, &mut timing_grid);
        let off_tick = engine
            .pending_off
            .peek()
            .map(|entry| entry.0.off_tick)
            .expect("pending off");
        assert!(off_tick >= onset.tick);
    }

    #[test]
    fn tick_at_large_tick_precision() {
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary {
                    gate: 0,
                    tick: 100_000_000,
                },
                GateBoundary {
                    gate: 1,
                    tick: 100_000_100,
                },
            ],
        };
        assert_eq!(grid.tick_at(0, 0.5), Some(100_000_050));
    }

    #[test]
    fn merge_candidates_keeps_distinct_gates() {
        let candidates = vec![
            CandidatePoint {
                tick: 10,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 10,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let merged = PhonationEngine::merge_candidates(candidates);
        assert_eq!(merged.len(), 2);
        assert_ne!(merged[0].gate, merged[1].gate);
    }

    #[test]
    fn merge_candidates_prioritizes_gate_boundary_on_collision() {
        let candidates = vec![
            CandidatePoint {
                tick: 10,
                gate: 1,
                theta_pos: 1.5,
                phase_in_gate: 0.5,
                sources: vec![ClockSource::Subdivision { n: 2 }],
            },
            CandidatePoint {
                tick: 10,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let merged = PhonationEngine::merge_candidates(candidates);
        assert_eq!(merged.len(), 1);
        assert_eq!(merged[0].phase_in_gate, 0.0);
        assert!(merged[0].sources.contains(&ClockSource::GateBoundary));
        assert!(
            merged[0]
                .sources
                .contains(&ClockSource::Subdivision { n: 2 })
        );
    }

    #[test]
    fn fixed_gate_connect_releases_on_next_gate_tick() {
        let mut rhythms = NeuralRhythms::default();
        rhythms.env_open = 1.0;
        rhythms.env_level = 1.0;
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 10,
            fs: 1000.0,
            rhythms,
        };
        let mut interval = AccumulatorInterval::new(250.0, 0, 1);
        interval.acc = 0.0;
        struct StubClock {
            ticks: Vec<Tick>,
            index: usize,
        }

        impl PhonationClock for StubClock {
            fn gather_candidates(&mut self, ctx: &CoreTickCtx, out: &mut Vec<CandidatePoint>) {
                while self.index < self.ticks.len() {
                    let tick = self.ticks[self.index];
                    if tick < ctx.now_tick || tick >= ctx.frame_end {
                        return;
                    }
                    let gate = self.index as u64;
                    out.push(CandidatePoint {
                        tick,
                        gate,
                        theta_pos: gate as f64,
                        phase_in_gate: 0.0,
                        sources: vec![ClockSource::GateBoundary],
                    });
                    self.index += 1;
                }
            }
        }

        let mut engine = PhonationEngine {
            clock: Box::new(StubClock {
                ticks: vec![0, 4, 8],
                index: 0,
            }),
            interval: Box::new(interval),
            connect: Box::new(FixedGateConnect::new(1)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let state = CoreState { is_alive: true };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        engine.tick(
            &ctx,
            &state,
            None,
            0.0,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert!(events.len() >= 2, "expected at least two note ons");
        let first = events[0];
        let second = events[1];
        let off_tick = cmds.iter().find_map(|cmd| match cmd {
            PhonationCmd::NoteOff { note_id, off_tick } if *note_id == first.note_id => {
                Some(*off_tick)
            }
            _ => None,
        });
        assert_eq!(off_tick, Some(second.onset_tick));
    }

    #[test]
    fn timing_field_applies_social_coupling() {
        let mut rhythms = NeuralRhythms::default();
        rhythms.env_open = 1.0;
        rhythms.env_level = 1.0;
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 20,
            fs: 1000.0,
            rhythms,
        };
        let grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 10 },
            ],
        };
        let trace = SocialDensityTrace {
            start_tick: 0,
            bin_ticks: 10,
            bins: vec![1.0, 0.0],
        };
        let timing_field = TimingField::build_from(&ctx, &grid, Some((&trace, -1.0)));
        assert!(timing_field.e(0) < 0.5);
        assert!((timing_field.e(1) - 1.0).abs() < 1e-6);
    }

    #[test]
    fn field_connect_holds_longer_with_high_excitation() {
        let mut connect = FieldConnect::new(0.25, 1.0, 10.0, 0.5, 0.0);
        let low_plan = connect.on_note_on(ConnectOnset {
            note_id: 1,
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            exc_gate: 0.0,
            exc_slope: 0.0,
        });
        let high_plan = connect.on_note_on(ConnectOnset {
            note_id: 2,
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            exc_gate: 1.0,
            exc_slope: 0.0,
        });
        let hold_low = match low_plan {
            ConnectPlan::HoldTheta(hold) => hold,
            _ => panic!("expected hold plan for low excitation"),
        };
        let hold_high = match high_plan {
            ConnectPlan::HoldTheta(hold) => hold,
            _ => panic!("expected hold plan for high excitation"),
        };
        assert!(hold_high > hold_low);
    }

    #[test]
    fn field_connect_schedules_off_tick_when_next_boundary_not_in_candidates() {
        struct TickInterval {
            tick: Tick,
        }

        impl PhonationInterval for TickInterval {
            fn on_candidate(
                &mut self,
                c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                if c.tick == self.tick {
                    Some(PhonationKick::Planned { strength: 1.0 })
                } else {
                    None
                }
            }
        }

        let mut rhythms = NeuralRhythms::default();
        rhythms.theta.freq_hz = 1.0;
        rhythms.theta.phase = 0.0;
        let fs = 100.0;
        let expected_gate1_tick =
            next_gate_tick(1, fs, rhythms.theta, 0.0).expect("expected gate1 tick");
        let mut expected_off_tick = ((expected_gate1_tick as f64) * 0.5).round() as Tick;
        let lo = 1;
        let hi = expected_gate1_tick.saturating_sub(1);
        assert!(lo <= hi);
        expected_off_tick = expected_off_tick.clamp(lo, hi);
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: expected_off_tick.saturating_add(1),
            fs,
            rhythms,
        };
        let timing_field = TimingField::from_values(0, vec![1.0, 1.0]);
        let state = CoreState { is_alive: true };
        let candidates = vec![CandidatePoint {
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            phase_in_gate: 0.0,
            sources: vec![ClockSource::GateBoundary],
        }];
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(TickInterval { tick: 0 }),
            connect: Box::new(FieldConnect::new(0.5, 0.5, 10.0, 0.5, 0.0)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates);
        let _ = engine.process_candidates(
            &ctx,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        assert!(cmds.iter().any(|cmd| matches!(
            cmd,
            PhonationCmd::NoteOff {
                off_tick,
                ..
            } if *off_tick == expected_off_tick
        )));
    }

    #[test]
    fn field_connect_off_tick_independent_of_subdivision() {
        struct TickInterval {
            tick: Tick,
        }

        impl PhonationInterval for TickInterval {
            fn on_candidate(
                &mut self,
                c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                if c.tick == self.tick {
                    Some(PhonationKick::Planned { strength: 1.0 })
                } else {
                    None
                }
            }
        }

        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 120,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let timing_field = TimingField::from_values(0, vec![1.0, 1.0]);
        let state = CoreState { is_alive: true };

        let candidates_base = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 100,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];

        let mut engine_base = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(TickInterval { tick: 0 }),
            connect: Box::new(FieldConnect::new(0.5, 0.5, 10.0, 0.5, 0.0)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates_base);
        let _ = engine_base.process_candidates(
            &ctx,
            &candidates_base,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        let note_on_id = cmds.iter().find_map(|cmd| match cmd {
            PhonationCmd::NoteOn { note_id, .. } => Some(*note_id),
            _ => None,
        });
        let off_tick_base = cmds.iter().find_map(|cmd| match cmd {
            PhonationCmd::NoteOff { note_id, off_tick } if Some(*note_id) == note_on_id => {
                Some(*off_tick)
            }
            _ => None,
        });

        let candidates_sub = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 50,
                gate: 0,
                theta_pos: 0.5,
                phase_in_gate: 0.5,
                sources: vec![ClockSource::Subdivision { n: 2 }],
            },
            CandidatePoint {
                tick: 100,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];

        let mut engine_sub = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(TickInterval { tick: 0 }),
            connect: Box::new(FieldConnect::new(0.5, 0.5, 10.0, 0.5, 0.0)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let mut cmds_sub = Vec::new();
        let mut events_sub = Vec::new();
        let mut onsets_sub = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates_sub);
        let _ = engine_sub.process_candidates(
            &ctx,
            &candidates_sub,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds_sub,
            &mut events_sub,
            &mut onsets_sub,
        );
        let note_on_id_sub = cmds_sub.iter().find_map(|cmd| match cmd {
            PhonationCmd::NoteOn { note_id, .. } => Some(*note_id),
            _ => None,
        });
        let off_tick_sub = cmds_sub.iter().find_map(|cmd| match cmd {
            PhonationCmd::NoteOff { note_id, off_tick } if Some(*note_id) == note_on_id_sub => {
                Some(*off_tick)
            }
            _ => None,
        });

        assert_eq!(off_tick_base, Some(50));
        assert_eq!(off_tick_sub, Some(50));
    }

    #[test]
    fn field_connect_note_off_survives_empty_hop() {
        struct TickInterval {
            tick: Tick,
        }

        impl PhonationInterval for TickInterval {
            fn on_candidate(
                &mut self,
                c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                if c.tick == self.tick {
                    Some(PhonationKick::Planned { strength: 1.0 })
                } else {
                    None
                }
            }
        }

        let timing_field = TimingField::from_values(0, vec![1.0, 1.0]);
        let state = CoreState { is_alive: true };
        let mut engine = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(TickInterval { tick: 0 }),
            connect: Box::new(FieldConnect::new(1.0, 1.0, 10.0, 0.5, 0.0)),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };

        let ctx1 = CoreTickCtx {
            now_tick: 0,
            frame_end: 50,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let candidates = vec![CandidatePoint {
            tick: 0,
            gate: 0,
            theta_pos: 0.0,
            phase_in_gate: 0.0,
            sources: vec![ClockSource::GateBoundary],
        }];
        let mut timing_grid = ThetaGrid {
            boundaries: vec![
                GateBoundary { gate: 0, tick: 0 },
                GateBoundary { gate: 1, tick: 100 },
                GateBoundary { gate: 2, tick: 200 },
            ],
        };
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let _ = engine.process_candidates(
            &ctx1,
            &candidates,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        let note_on_id = cmds.iter().find_map(|cmd| match cmd {
            PhonationCmd::NoteOn { note_id, .. } => Some(*note_id),
            _ => None,
        });
        assert!(note_on_id.is_some());
        assert!(
            !cmds
                .iter()
                .any(|cmd| matches!(cmd, PhonationCmd::NoteOff { .. }))
        );

        let ctx2 = CoreTickCtx {
            now_tick: 50,
            frame_end: 120,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let empty: Vec<CandidatePoint> = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&empty);
        let mut cmds2 = Vec::new();
        let mut events2 = Vec::new();
        let mut onsets2 = Vec::new();
        let _ = engine.process_candidates(
            &ctx2,
            &empty,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds2,
            &mut events2,
            &mut onsets2,
        );
        let off_tick = cmds2.iter().find_map(|cmd| match cmd {
            PhonationCmd::NoteOff { note_id, off_tick } if Some(*note_id) == note_on_id => {
                Some(*off_tick)
            }
            _ => None,
        });
        assert_eq!(off_tick, Some(100));
    }

    #[test]
    fn exc_slope_is_stable_with_sub_candidates() {
        use std::collections::HashSet;
        use std::sync::{Arc, Mutex};

        struct TickFilteredInterval {
            ticks: HashSet<Tick>,
        }

        impl PhonationInterval for TickFilteredInterval {
            fn on_candidate(
                &mut self,
                c: &IntervalInput,
                _state: &CoreState,
            ) -> Option<PhonationKick> {
                if self.ticks.contains(&c.tick) {
                    Some(PhonationKick::Planned { strength: 1.0 })
                } else {
                    None
                }
            }
        }

        struct RecordingConnect {
            slopes: Arc<Mutex<Vec<f32>>>,
        }

        impl PhonationConnect for RecordingConnect {
            fn on_note_on(&mut self, onset: ConnectOnset) -> ConnectPlan {
                self.slopes.lock().expect("slopes").push(onset.exc_slope);
                ConnectPlan::None
            }

            fn poll(&mut self, _now: ConnectNow, _out: &mut Vec<PhonationCmd>) {}
        }

        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 30,
            fs: 1000.0,
            rhythms: NeuralRhythms::default(),
        };
        let timing_field = TimingField::from_values(0, vec![0.2, 0.8, 0.2]);
        let state = CoreState { is_alive: true };

        let slopes_base = Arc::new(Mutex::new(Vec::new()));
        let mut engine_base = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(TickFilteredInterval {
                ticks: [0, 10, 20].into_iter().collect(),
            }),
            connect: Box::new(RecordingConnect {
                slopes: slopes_base.clone(),
            }),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let candidates_base = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 10,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 20,
                gate: 2,
                theta_pos: 2.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates_base);
        let _ = engine_base.process_candidates(
            &ctx,
            &candidates_base,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        let base_slopes = slopes_base.lock().expect("slopes").clone();

        let slopes_sub = Arc::new(Mutex::new(Vec::new()));
        let mut engine_sub = PhonationEngine {
            clock: Box::<ThetaGateClock>::default(),
            interval: Box::new(TickFilteredInterval {
                ticks: [0, 10, 20].into_iter().collect(),
            }),
            connect: Box::new(RecordingConnect {
                slopes: slopes_sub.clone(),
            }),
            sub_theta_mod: Box::<NoneMod>::default(),
            mode: PhonationMode::Gated,
            hold: HoldCore::default(),
            next_note_id: 0,
            last_gate_index: None,
            last_theta_pos: None,
            last_tick: None,
            active_notes: 0,
            pending_off: BinaryHeap::new(),
            scratch_candidates: Vec::new(),
            scratch_merged: Vec::new(),
        };
        let candidates_sub = vec![
            CandidatePoint {
                tick: 0,
                gate: 0,
                theta_pos: 0.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 5,
                gate: 0,
                theta_pos: 0.5,
                phase_in_gate: 0.5,
                sources: vec![ClockSource::Subdivision { n: 2 }],
            },
            CandidatePoint {
                tick: 10,
                gate: 1,
                theta_pos: 1.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
            CandidatePoint {
                tick: 15,
                gate: 1,
                theta_pos: 1.5,
                phase_in_gate: 0.5,
                sources: vec![ClockSource::Subdivision { n: 2 }],
            },
            CandidatePoint {
                tick: 20,
                gate: 2,
                theta_pos: 2.0,
                phase_in_gate: 0.0,
                sources: vec![ClockSource::GateBoundary],
            },
        ];
        let mut cmds = Vec::new();
        let mut events = Vec::new();
        let mut onsets = Vec::new();
        let mut timing_grid = ThetaGrid::from_candidates(&candidates_sub);
        let _ = engine_sub.process_candidates(
            &ctx,
            &candidates_sub,
            &mut timing_grid,
            &timing_field,
            &state,
            None,
            &mut cmds,
            &mut events,
            &mut onsets,
        );
        let sub_slopes = slopes_sub.lock().expect("slopes").clone();
        assert_eq!(base_slopes, sub_slopes);
    }

    #[test]
    fn timing_field_social_coupling_clamps_exponent() {
        let mut rhythms = NeuralRhythms::default();
        rhythms.env_open = 1.0;
        rhythms.env_level = 1.0;
        let ctx = CoreTickCtx {
            now_tick: 0,
            frame_end: 1,
            fs: 1000.0,
            rhythms,
        };
        let grid = ThetaGrid {
            boundaries: vec![GateBoundary { gate: 0, tick: 0 }],
        };
        let trace = SocialDensityTrace {
            start_tick: 0,
            bin_ticks: 1,
            bins: vec![1000.0],
        };
        let timing_field = TimingField::build_from(&ctx, &grid, Some((&trace, 1000.0)));
        assert!(timing_field.e(0).is_finite());
    }
}
</file>

<file path="src/app.rs">
use std::collections::VecDeque;
use std::path::Path;
use std::sync::{
    Arc,
    atomic::{AtomicBool, Ordering},
};
use std::thread;
use std::time::{Duration, Instant};
use tracing::*;

use crossbeam_channel::{Receiver, Sender, bounded};
use ringbuf::traits::Observer;

#[cfg(debug_assertions)]
use crate::audio::writer::WavOutput;
use crate::core::harmonicity_kernel::HarmonicityKernel;
use crate::core::harmonicity_worker;
use crate::core::landscape::{Landscape, LandscapeFrame, LandscapeParams, LandscapeUpdate};
use crate::core::log2space::Log2Space;
use crate::core::nsgt_kernel::{NsgtKernelLog2, NsgtLog2Config, PowerMode};
use crate::core::nsgt_rt::{RtConfig, RtNsgtKernelLog2};
use crate::core::roughness_kernel::{KernelParams, RoughnessKernel};
use crate::core::roughness_worker;
use crate::core::stream::{
    dorsal::DorsalStream, harmonicity::HarmonicityStream, roughness::RoughnessStream,
};
use crate::core::timebase::Tick;
use crate::life::conductor::Conductor;
use crate::life::individual::{PhonationBatch, SoundBody};
use crate::life::population::Population;
use crate::life::scenario::{Action, Scenario};
use crate::life::schedule_renderer::ScheduleRenderer;
use crate::life::scripting::ScriptHost;
use crate::life::sound::{AudioCommand, VoiceTarget};
use crate::ui::viewdata::{
    AgentStateInfo, DorsalFrame, PlaybackState, SimulationMeta, SpecFrame, UiFrame, WaveFrame,
};
use crate::{
    audio::output::AudioOutput, config::AppConfig, core::harmonicity_kernel::HarmonicityParams,
};

struct AudioMonitor {
    min_occupancy: Option<usize>,
    max_peak: f32,
    slow_chunks: u32,
    last_stats_log: Instant,
    last_clip_log: Instant,
    last_lag_warn: Instant,
}

impl AudioMonitor {
    fn new() -> Self {
        let now = Instant::now();
        Self {
            min_occupancy: None,
            max_peak: 0.0,
            slow_chunks: 0,
            last_stats_log: now,
            last_clip_log: now,
            last_lag_warn: now,
        }
    }

    #[allow(clippy::too_many_arguments)]
    fn update(
        &mut self,
        current_time: f32,
        frame_idx: u64,
        hop: usize,
        hop_duration: Duration,
        buffer_capacity: usize,
        buffer_occupancy: usize,
        chunk_peak: f32,
        chunk_elapsed: Duration,
        harmonicity_lag: Option<u64>,
        roughness_lag: Option<u64>,
        conductor_done: bool,
    ) -> f32 {
        self.min_occupancy = Some(
            self.min_occupancy
                .map_or(buffer_occupancy, |m| m.min(buffer_occupancy)),
        );
        self.max_peak = self.max_peak.max(chunk_peak);

        if self.last_clip_log.elapsed() > Duration::from_millis(200) {
            if chunk_peak > 0.98 {
                warn!(
                    "[t={:.6}] Audio peak high: {:.3} at frame_idx={}. Consider more headroom.",
                    current_time, chunk_peak, frame_idx
                );
                self.last_clip_log = Instant::now();
            } else if chunk_peak > 0.9 {
                warn!(
                    "[t={:.6}] Audio peak nearing clip: {:.3} at frame_idx={}",
                    current_time, chunk_peak, frame_idx
                );
                self.last_clip_log = Instant::now();
            } else if conductor_done && chunk_peak > 1e-4 {
                warn!(
                    "[t={:.6}] Scenario done but audio active: peak={:.4}",
                    current_time, chunk_peak
                );
                self.last_clip_log = Instant::now();
            }
        }

        if chunk_elapsed > hop_duration {
            self.slow_chunks += 1;
            warn!(
                "[t={:.6}] Audio chunk compute slow: {:?} (hop {:?}) frame_idx={}",
                current_time, chunk_elapsed, hop_duration, frame_idx
            );
        }

        let should_warn = harmonicity_lag.is_some_and(|lag| lag >= 2)
            || roughness_lag.is_some_and(|lag| lag >= 2);
        if should_warn && self.last_lag_warn.elapsed() > Duration::from_secs(1) {
            let h = harmonicity_lag
                .map(|v| v.to_string())
                .unwrap_or_else(|| "-".into());
            let r = roughness_lag
                .map(|v| v.to_string())
                .unwrap_or_else(|| "-".into());
            warn!(
                "[t={:.3}] Analysis lag (frames): H={} R={} (Audio(gen)={})",
                current_time, h, r, frame_idx
            );
            self.last_lag_warn = Instant::now();
        }

        let peak_level = self.max_peak;

        if self.last_stats_log.elapsed() > Duration::from_secs(1) {
            if let Some(min_occ) = self.min_occupancy.take() {
                debug!(
                    "[t={:.6}] Audio stats: min_occ={}, cap={}, hop={}, max_peak={:.3}, slow_chunks={}",
                    current_time, min_occ, buffer_capacity, hop, peak_level, self.slow_chunks
                );
            }
            self.max_peak = 0.0;
            self.slow_chunks = 0;
            self.last_stats_log = Instant::now();
        }

        peak_level
    }
}

pub struct App {
    ui_frame_rx: Receiver<UiFrame>,
    _ctrl_tx: Sender<()>, // placeholder
    last_frame: UiFrame,
    ui_queue: VecDeque<UiFrame>,
    visual_delay_frames: usize,
    _audio: Option<AudioOutput>,
    audio_init_error: Option<String>,
    worker_handle: Option<std::thread::JoinHandle<()>>,
    wav_handle: Option<std::thread::JoinHandle<()>>,
    exiting: Arc<AtomicBool>,
    rhythm_history: VecDeque<(f64, crate::core::modulation::NeuralRhythms)>,
    dorsal_history: VecDeque<(f64, DorsalFrame)>,
    start_flag: Arc<AtomicBool>,
    level_history: VecDeque<(std::time::Instant, [f32; 2])>,
    show_raw_nsgt_power: bool,
    has_ui_frame: bool,
}

struct RuntimeInit {
    ui_frame_rx: Receiver<UiFrame>,
    ctrl_tx: Sender<()>,
    worker_handle: Option<std::thread::JoinHandle<()>>,
    wav_handle: Option<std::thread::JoinHandle<()>>,
    start_flag: Arc<AtomicBool>,
    audio_out: Option<AudioOutput>,
    audio_init_error: Option<String>,
    visual_delay_frames: usize,
}

pub fn compile_scenario_from_script(
    script_path: &Path,
    _args: &crate::cli::Args,
    _config: &AppConfig,
) -> Result<Scenario, String> {
    let ext = script_path
        .extension()
        .and_then(|s| s.to_str())
        .unwrap_or("")
        .to_ascii_lowercase();
    if ext != "rhai" {
        return Err(format!(
            "Scenario must be a .rhai script: {}",
            script_path.display()
        ));
    }
    let path_str = script_path.to_string_lossy();
    ScriptHost::load_script(&path_str).map_err(|e| {
        let pos = e
            .position
            .map(|pos| format!(" (line {})", pos.line().unwrap_or(0)))
            .unwrap_or_default();
        format!(
            "Failed to run scenario script {}: {}{pos}",
            script_path.display(),
            e.message
        )
    })
}

pub fn validate_scenario(scenario: &Scenario) -> Result<(), String> {
    if scenario.events.is_empty() {
        return Err("Scenario has no events".to_string());
    }

    let mut has_finish = false;
    for event in &scenario.events {
        for action in &event.actions {
            match action {
                Action::Finish => {
                    has_finish = true;
                }
                Action::Spawn { .. } => {}
                Action::Set { target, .. }
                | Action::Unset { target, .. }
                | Action::Remove { target }
                | Action::Release { target, .. } => {
                    validate_target_pattern(target)?;
                }
                Action::SetHarmonicity { .. }
                | Action::SetGlobalCoupling { .. }
                | Action::SetRoughnessTolerance { .. } => {}
                Action::PostIntent { .. } => {}
            }
        }
    }

    if !has_finish {
        return Err("Scenario has no Finish action".to_string());
    }

    if scenario.duration_sec <= 0.0 {
        return Err("Scenario duration_sec must be > 0".to_string());
    }
    if let Some(max_time) = scenario
        .events
        .iter()
        .map(|ev| ev.time)
        .max_by(|a, b| a.partial_cmp(b).unwrap_or(std::cmp::Ordering::Equal))
        && scenario.duration_sec + f32::EPSILON < max_time
    {
        return Err("Scenario duration_sec is before last event".to_string());
    }

    let mut prev_order = None;
    for event in &scenario.events {
        let order = event.order;
        if let Some(prev) = prev_order
            && order <= prev
        {
            return Err("Event order is not strictly increasing".to_string());
        }
        prev_order = Some(order);
    }

    Ok(())
}

fn validate_target_pattern(target: &str) -> Result<(), String> {
    if target.trim().is_empty() {
        return Err("target pattern is empty".to_string());
    }
    Ok(())
}

pub fn run_compile_only(args: crate::cli::Args, config: AppConfig) {
    let path = Path::new(&args.scenario_path);
    let scenario = compile_scenario_from_script(path, &args, &config).unwrap_or_else(|e| {
        eprintln!("{e}");
        std::process::exit(1);
    });
    if let Err(e) = validate_scenario(&scenario) {
        eprintln!("{e}");
        std::process::exit(1);
    }
    let mut markers = scenario.scene_markers.clone();
    markers.sort_by(|a, b| {
        a.time
            .partial_cmp(&b.time)
            .unwrap_or(std::cmp::Ordering::Equal)
            .then_with(|| a.order.cmp(&b.order))
    });
    for marker in &markers {
        eprintln!(
            "scene t={:.3} order={} name={}",
            marker.time, marker.order, marker.name
        );
    }
    let mut events = scenario.events.clone();
    events.sort_by(|a, b| {
        a.time
            .partial_cmp(&b.time)
            .unwrap_or(std::cmp::Ordering::Equal)
            .then_with(|| a.order.cmp(&b.order))
    });
    for event in &events {
        let action_descs: Vec<String> = event.actions.iter().map(ToString::to_string).collect();
        eprintln!(
            "event t={:.3} order={} {}",
            event.time,
            event.order,
            action_descs.join(" | ")
        );
    }
    let mut event_count = 0usize;
    let mut action_count = 0usize;
    let marker_count = scenario.scene_markers.len();
    event_count += scenario.events.len();
    for event in &scenario.events {
        action_count += event.actions.len();
    }
    eprintln!(
        "OK compile-only: {} (events={}, actions={}, markers={})",
        path.display(),
        event_count,
        action_count,
        marker_count
    );
}

impl App {
    pub fn new(
        cc: &eframe::CreationContext<'_>,
        args: crate::cli::Args,
        config: AppConfig,
        stop_flag: Arc<AtomicBool>,
    ) -> Self {
        let repaint_ctx = cc.egui_ctx.clone();
        let stop_flag_watch = stop_flag.clone();
        std::thread::spawn(move || {
            while !stop_flag_watch.load(Ordering::SeqCst) {
                std::thread::sleep(Duration::from_millis(50));
            }
            repaint_ctx.send_viewport_cmd(egui::ViewportCommand::Close);
            repaint_ctx.request_repaint();
            std::thread::sleep(Duration::from_millis(200));
            if stop_flag_watch.load(Ordering::SeqCst) {
                // Force exit in case the event loop is asleep (e.g., window not exposed).
                std::process::exit(0);
            }
        });

        let rt = init_runtime(args, config, stop_flag.clone());

        //cc.egui_ctx.set_pixels_per_point(1.0);
        cc.egui_ctx
            .send_viewport_cmd(egui::ViewportCommand::InnerSize(egui::Vec2 {
                x: 1200.0,
                y: 1020.0,
            }));
        cc.egui_ctx
            .send_viewport_cmd(egui::ViewportCommand::MinInnerSize(egui::Vec2 {
                x: 1200.0,
                y: 1020.0,
            }));

        Self {
            ui_frame_rx: rt.ui_frame_rx,
            _ctrl_tx: rt.ctrl_tx,
            last_frame: UiFrame::default(),
            ui_queue: VecDeque::new(),
            visual_delay_frames: rt.visual_delay_frames,
            _audio: rt.audio_out,
            audio_init_error: rt.audio_init_error,
            wav_handle: rt.wav_handle,
            worker_handle: rt.worker_handle,
            exiting: stop_flag,
            rhythm_history: VecDeque::with_capacity(4096),
            dorsal_history: VecDeque::with_capacity(4096),
            start_flag: rt.start_flag,
            level_history: VecDeque::with_capacity(256),
            show_raw_nsgt_power: false,
            has_ui_frame: false,
        }
    }

    fn apply_ui_frame(&mut self, frame: UiFrame) {
        self.last_frame = frame;

        let t = self.last_frame.time_sec as f64;
        if self.last_frame.meta.playback_state != PlaybackState::Finished {
            self.rhythm_history
                .push_back((t, self.last_frame.landscape.rhythm));
            self.dorsal_history.push_back((t, self.last_frame.dorsal));
        }

        let t_last = self
            .rhythm_history
            .back()
            .map(|(t, _)| *t)
            .or_else(|| self.dorsal_history.back().map(|(t, _)| *t));
        if let Some(t_last) = t_last {
            while self
                .rhythm_history
                .front()
                .is_some_and(|(time, _)| *time < t_last - 5.0)
            {
                self.rhythm_history.pop_front();
            }
            while self
                .dorsal_history
                .front()
                .is_some_and(|(time, _)| *time < t_last - 5.0)
            {
                self.dorsal_history.pop_front();
            }
        }

        // Track 1-second peak history for level meter.
        let now = std::time::Instant::now();
        self.level_history
            .push_back((now, self.last_frame.meta.channel_peak));
        while let Some((t, _)) = self.level_history.front() {
            if now.duration_since(*t).as_secs_f32() > 1.0 {
                self.level_history.pop_front();
            } else {
                break;
            }
        }
        let mut window_peak = [0.0f32; 2];
        for (_, peaks) in &self.level_history {
            window_peak[0] = window_peak[0].max(peaks[0]);
            window_peak[1] = window_peak[1].max(peaks[1]);
        }
        self.last_frame.meta.window_peak = window_peak;
    }
}

fn init_runtime(
    args: crate::cli::Args,
    config: AppConfig,
    stop_flag: Arc<AtomicBool>,
) -> RuntimeInit {
    let latency_ms = config.audio.latency_ms;

    // Audio
    let (audio_out, audio_prod, audio_init_error) = if args.play {
        match AudioOutput::new(latency_ms) {
            Ok((out, prod)) => (Some(out), Some(prod), None),
            Err(e) => {
                let msg = e.to_string();
                eprintln!("Audio init failed: {msg}");
                (None, None, Some(msg))
            }
        }
    } else {
        (None, None, None)
    };

    // Decide runtime sample rate: use actual stream rate when playing, otherwise config value.
    let runtime_sample_rate: u32 = if args.play {
        let device_rate = audio_out
            .as_ref()
            .map(|out| out.config.sample_rate)
            .unwrap_or(config.audio.sample_rate);
        if device_rate != config.audio.sample_rate {
            debug!(
                "Runtime sample rate overridden by device: {} (config {})",
                device_rate, config.audio.sample_rate
            );
        }
        device_rate
    } else {
        config.audio.sample_rate
    };

    // WAV (debug-only)
    #[cfg(debug_assertions)]
    let (wav_tx, wav_handle) = if let Some(path) = args.wav.clone() {
        let (wav_tx, wav_rx) = bounded::<Arc<[f32]>>(16);
        let wav_handle = WavOutput::run(wav_rx, path, runtime_sample_rate);
        (Some(wav_tx), Some(wav_handle))
    } else {
        (None, None)
    };
    #[cfg(not(debug_assertions))]
    let (wav_tx, wav_handle) = (None, None);

    // Analysis/NSGT setup
    let fs: f32 = runtime_sample_rate as f32;
    let space = Log2Space::new(55.0, 8000.0, 96);
    let lparams = LandscapeParams {
        fs,
        max_hist_cols: 256,
        alpha: 0.0,
        roughness_kernel: RoughnessKernel::new(KernelParams::default(), 0.005), // ΔERB LUT step
        harmonicity_kernel: HarmonicityKernel::new(&space, HarmonicityParams::default()),
        roughness_scalar_mode: crate::core::landscape::RoughnessScalarMode::Total,
        roughness_half: 0.1,
        consonance_roughness_weight: config.psychoacoustics.roughness_weight,
        loudness_exp: config.psychoacoustics.loudness_exp, // Zwicker
        tau_ms: config.analysis.tau_ms,
        ref_power: 1e-4,
        roughness_k: config.psychoacoustics.roughness_k,
        roughness_ref_f0_hz: 1000.0,
        roughness_ref_sep_erb: 0.25,
        roughness_ref_mass_split: 0.5,
        roughness_ref_eps: 1e-12,
    };
    let nfft = config.analysis.nfft;
    let hop = config.analysis.hop_size;
    let overlap = 1.0 - (hop as f32 / nfft as f32);
    let power_mode = if config.psychoacoustics.use_incoherent_power {
        PowerMode::Incoherent
    } else {
        PowerMode::Coherent
    };
    let nsgt_kernel = NsgtKernelLog2::new(
        NsgtLog2Config {
            fs,
            overlap,
            nfft_override: Some(nfft),
            kernel_align: config.analysis.kernel_align,
        },
        space,
        None,
        power_mode,
    );
    let nsgt = RtNsgtKernelLog2::with_config(nsgt_kernel.clone(), RtConfig::default());
    let hop_duration = Duration::from_secs_f32(hop as f32 / fs);
    let hop_ms = (hop as f32 / fs) * 1000.0;
    let visual_delay_frames = 0;
    debug!(
        "Visual delay frames: {} (latency_ms={:.1}, hop_ms={:.2})",
        visual_delay_frames, latency_ms, hop_ms
    );
    let ui_channel_capacity = (visual_delay_frames + 4).max(16);

    // Channels
    let (ui_frame_tx, ui_frame_rx) = bounded::<UiFrame>(ui_channel_capacity);
    let (ctrl_tx, _ctrl_rx) = bounded::<()>(1);
    let (harmonicity_tx, harmonicity_rx) = bounded::<LandscapeUpdate>(8);
    let (roughness_tx, roughness_rx) = bounded::<LandscapeUpdate>(8);

    let base_space = nsgt.space().clone();
    let roughness_stream = RoughnessStream::new(lparams.clone(), nsgt.clone());
    let harmonicity_stream =
        HarmonicityStream::new(base_space.clone(), lparams.harmonicity_kernel.clone());
    let landscape = Landscape::new(base_space.clone());
    let dorsal = DorsalStream::new(fs);
    let lparams_runtime = lparams.clone();

    // Analysis pipeline channels
    let (spectrum_to_harmonicity_tx, spectrum_to_harmonicity_rx) = bounded::<(u64, Arc<[f32]>)>(64);
    let (harmonicity_result_tx, harmonicity_result_rx) = bounded::<(u64, Vec<f32>, Vec<f32>)>(4);
    let (audio_to_roughness_tx, audio_to_roughness_rx) = bounded::<(u64, Arc<[f32]>)>(64);
    let (roughness_from_analysis_tx, roughness_from_analysis_rx) = bounded::<(u64, Landscape)>(4);

    // Spawn harmonicity thread
    {
        std::thread::Builder::new()
            .name("harmonicity".into())
            .spawn(move || {
                harmonicity_worker::run(
                    harmonicity_stream,
                    spectrum_to_harmonicity_rx,
                    harmonicity_result_tx,
                    harmonicity_rx,
                );
            })
            .expect("spawn analysis worker");
    }

    // Spawn roughness thread (NSGT-RT based audio analysis).
    {
        std::thread::Builder::new()
            .name("roughness".into())
            .spawn(move || {
                roughness_worker::run(
                    roughness_stream,
                    audio_to_roughness_rx,
                    roughness_from_analysis_tx,
                    roughness_rx,
                )
            })
            .expect("spawn roughness worker");
    }

    let path = Path::new(&args.scenario_path);
    let scenario_label = path
        .file_stem()
        .and_then(|s| s.to_str())
        .unwrap_or("scenario")
        .to_string();
    let scenario = compile_scenario_from_script(path, &args, &config).unwrap_or_else(|e| {
        eprintln!("{e}");
        std::process::exit(1);
    });
    let mut pop = Population::new(crate::core::timebase::Timebase {
        fs: runtime_sample_rate as f32,
        hop,
    });
    pop.set_seed(scenario.seed);
    let conductor = Conductor::from_scenario(scenario);

    // Give the worker its own handle if WAV output is enabled.
    let wav_tx_for_worker = wav_tx;

    // Spawn worker thread
    let stop_flag_worker = stop_flag.clone();
    let start_flag = Arc::new(AtomicBool::new(!config.playback.wait_user_start));
    let start_flag_for_worker = start_flag.clone();

    let worker_handle = Some(
        thread::Builder::new()
            .name("worker".into())
            .spawn(move || {
                worker_loop(
                    scenario_label,
                    config.playback.wait_user_exit,
                    start_flag_for_worker,
                    ui_frame_tx,
                    pop,
                    conductor,
                    landscape,
                    lparams_runtime,
                    dorsal,
                    audio_prod,
                    wav_tx_for_worker,
                    stop_flag_worker,
                    spectrum_to_harmonicity_tx,
                    harmonicity_result_rx,
                    harmonicity_tx,
                    audio_to_roughness_tx,
                    roughness_from_analysis_rx,
                    roughness_tx,
                    hop,
                    hop_duration,
                    fs,
                )
            })
            .expect("spawn worker"),
    );

    RuntimeInit {
        ui_frame_rx,
        ctrl_tx,
        worker_handle,
        wav_handle,
        start_flag,
        audio_out,
        audio_init_error,
        visual_delay_frames,
    }
}

pub fn run_headless(args: crate::cli::Args, config: AppConfig, stop_flag: Arc<AtomicBool>) {
    let rt = init_runtime(args, config, stop_flag);
    rt.start_flag.store(true, Ordering::SeqCst);
    let _audio = rt.audio_out;
    if let Some(handle) = rt.worker_handle {
        let _ = handle.join();
    }
    if let Some(handle) = rt.wav_handle {
        let _ = handle.join();
    }
}

impl eframe::App for App {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        if ctx.input(|i| i.viewport().close_requested()) {
            // Honor OS window close requests by stopping the worker thread.
            self.exiting.store(true, Ordering::SeqCst);
        }

        if self.exiting.load(Ordering::SeqCst) {
            debug!("SIGINT received: closing window.");
            ctx.send_viewport_cmd(egui::ViewportCommand::Close);
            return;
        }

        // Drain all frames into the delay queue.
        while let Ok(frame) = self.ui_frame_rx.try_recv() {
            self.ui_queue.push_back(frame);
        }
        if !self.has_ui_frame
            && let Some(frame) = self.ui_queue.pop_front()
        {
            self.apply_ui_frame(frame);
            self.has_ui_frame = true;
        }
        while self.ui_queue.len() > self.visual_delay_frames {
            if let Some(frame) = self.ui_queue.pop_front() {
                self.apply_ui_frame(frame);
            }
        }

        crate::ui::windows::main_window(
            ctx,
            &self.last_frame,
            &self.rhythm_history,
            &self.dorsal_history,
            self.audio_init_error.as_deref(),
            &self.exiting,
            &self.start_flag,
            &mut self.show_raw_nsgt_power,
        );
        ctx.request_repaint_after(std::time::Duration::from_millis(16));
    }
}

impl Drop for App {
    fn drop(&mut self) {
        debug!("App drop. Finalizing..");

        // Request shutdown so worker threads can exit before we join them.
        self.exiting.store(true, Ordering::SeqCst);

        if let Some(handle) = self.worker_handle.take() {
            let _ = handle.join();
        }
        if let Some(handle) = self.wav_handle.take() {
            let _ = handle.join();
        }
    }
}

#[allow(clippy::too_many_arguments)]
fn worker_loop(
    scenario_name: String,
    wait_user_exit: bool,
    start_flag: Arc<AtomicBool>,
    ui_tx: Sender<UiFrame>,
    mut pop: Population,
    mut conductor: Conductor,
    current_landscape: Landscape,
    mut lparams: LandscapeParams,
    mut dorsal: DorsalStream,
    mut audio_prod: Option<ringbuf::HeapProd<f32>>,
    mut wav_tx: Option<Sender<Arc<[f32]>>>,
    exiting: Arc<AtomicBool>,
    spectrum_to_harmonicity_tx: Sender<(u64, Arc<[f32]>)>,
    harmonicity_result_rx: Receiver<(u64, Vec<f32>, Vec<f32>)>,
    harmonicity_tx: Sender<LandscapeUpdate>,
    audio_to_roughness_tx: Sender<(u64, Arc<[f32]>)>,
    roughness_from_analysis_rx: Receiver<(u64, Landscape)>,
    roughness_tx: Sender<LandscapeUpdate>,
    hop: usize,
    hop_duration: Duration,
    fs: f32,
) {
    let mut current_landscape: LandscapeFrame = current_landscape;
    let mut playback_state = if start_flag.load(Ordering::SeqCst) {
        PlaybackState::Playing
    } else {
        PlaybackState::NotStarted
    };
    let mut finish_logged = false;
    let mut finished = false;
    let mut latest_spec_amps: Vec<f32> = vec![0.0; current_landscape.space.n_bins()];
    let mut log_space = current_landscape.space.clone();

    let mut current_time: f32 = 0.0;
    let mut frame_idx: u64 = 0;
    let mut monitor = AudioMonitor::new();
    let mut last_ui_update = Instant::now();
    let ui_min_interval = Duration::from_millis(33);
    let mut last_h_analysis_frame: Option<u64> = None;
    let mut last_r_analysis_frame: Option<u64> = None;
    let mut latest_h_scan: Option<Vec<f32>> = None;
    let timebase = crate::core::timebase::Timebase { fs, hop };
    let mut world = crate::life::world_model::WorldModel::new(timebase, log_space.clone());
    world.set_pred_params(lparams.clone());
    let mut schedule_renderer = ScheduleRenderer::new(timebase);
    let init_now_tick = timebase.frame_start_tick(frame_idx);
    world.advance_to(init_now_tick);
    let init_world_view = world.ui_view();
    let mut last_tick_log = Instant::now();
    let idle_silence = vec![0.0f32; hop];
    let mut scenario_end_tick: Option<Tick> = None;
    let mut phonation_batches_buf: Vec<PhonationBatch> = Vec::new();
    let mut audio_cmds: Vec<AudioCommand> = Vec::new();
    let mut voice_targets: Vec<VoiceTarget> = Vec::new();

    // Initial UI frame so metadata is visible before playback starts.
    let init_meta = SimulationMeta {
        time_sec: current_time,
        duration_sec: conductor.total_duration(),
        agent_count: pop.individuals.len(),
        event_queue_len: conductor.remaining_events(),
        peak_level: 0.0,
        scenario_name: scenario_name.clone(),
        scene_name: conductor.current_scene_name(current_time),
        playback_state: playback_state.clone(),
        channel_peak: [0.0; 2],
        window_peak: [0.0; 2],
    };
    let init_frame = UiFrame {
        wave: WaveFrame {
            fs,
            samples: Arc::from(Vec::<f32>::new()),
        },
        spec: SpecFrame {
            spec_hz: current_landscape.space.centers_hz.clone(),
            amps: vec![0.0; current_landscape.space.n_bins()],
        },
        dorsal: DorsalFrame::default(),
        landscape: current_landscape.clone(),
        time_sec: current_time,
        meta: init_meta,
        agents: Vec::new(),
        world: init_world_view,
    };
    let _ = ui_tx.try_send(init_frame);

    loop {
        if exiting.load(Ordering::SeqCst) {
            eprintln!("Stopping worker thread.");
            break;
        }

        if playback_state == PlaybackState::NotStarted && !start_flag.load(Ordering::SeqCst) {
            thread::sleep(Duration::from_millis(10));
            continue;
        } else if playback_state == PlaybackState::NotStarted {
            playback_state = PlaybackState::Playing;
        }

        if finished && wait_user_exit {
            if let Some(prod) = audio_prod.as_mut() {
                while prod.vacant_len() >= hop {
                    AudioOutput::push_samples(prod, &idle_silence);
                }
            }
            thread::sleep(Duration::from_millis(10));
            continue;
        }

        let buffer_capacity = audio_prod
            .as_ref()
            .map(|p| p.capacity().get())
            .unwrap_or(hop);

        let mut produced_any = false;
        let mut process_frame = |mut prod_opt: Option<&mut ringbuf::HeapProd<f32>>| {
            produced_any = true;
            let (_free, occupancy) = if let Some(prod) = prod_opt.as_ref() {
                let free = prod.vacant_len();
                (free, buffer_capacity.saturating_sub(free))
            } else {
                (hop, 0)
            };
            let now_tick = timebase.frame_start_tick(frame_idx);
            let now_sec = timebase.tick_to_sec(now_tick);
            world.advance_to(now_tick);
            world.update_gate_from_rhythm(now_tick, &current_landscape.rhythm);
            if frame_idx == 0 || last_tick_log.elapsed() >= Duration::from_secs(1) {
                info!(
                    "[tick] frame_idx={} now_tick={} now_sec={:.6}",
                    frame_idx, now_tick, now_sec
                );
                last_tick_log = Instant::now();
            }
            pop.set_current_frame(frame_idx);

            // Keep analysis aligned to generated frames: allow 1-frame delay, but do not advance
            // more than that. This keeps perc_* (R/H) coherent for population dynamics.
            let required_prev = frame_idx.saturating_sub(1);
            loop {
                // Merge analysis results (latest-only) into the landscape.
                let mut latest_body: Option<(u64, Vec<f32>, Vec<f32>)> = None;
                while let Ok((analyzed_id, h_scan, body_log)) = harmonicity_result_rx.try_recv() {
                    last_h_analysis_frame = Some(analyzed_id);
                    latest_body = Some((analyzed_id, h_scan, body_log));
                }
                if let Some((_, h_scan, _body_log)) = latest_body {
                    latest_h_scan = Some(h_scan);
                }

                let mut latest_audio: Option<(u64, Landscape)> = None;
                while let Ok((analyzed_id, frame)) = roughness_from_analysis_rx.try_recv() {
                    last_r_analysis_frame = Some(analyzed_id);
                    latest_audio = Some((analyzed_id, frame));
                }
                let mut roughness_updated = false;
                let mut harmonicity_updated = false;
                if let Some((_, frame)) = latest_audio {
                    let space_changed = current_landscape.space.n_bins() != frame.space.n_bins()
                        || current_landscape.space.fmin != frame.space.fmin
                        || current_landscape.space.fmax != frame.space.fmax
                        || current_landscape.space.bins_per_oct != frame.space.bins_per_oct;
                    if space_changed {
                        current_landscape.resize_to_space(frame.space.clone());
                        log_space = current_landscape.space.clone();
                        world.set_space(log_space.clone());
                    }
                    current_landscape.roughness = frame.roughness;
                    current_landscape.roughness01 = frame.roughness01;
                    current_landscape.roughness_total = frame.roughness_total;
                    current_landscape.roughness_max = frame.roughness_max;
                    current_landscape.roughness_p95 = frame.roughness_p95;
                    current_landscape.roughness_scalar_raw = frame.roughness_scalar_raw;
                    current_landscape.roughness_norm = frame.roughness_norm;
                    current_landscape.roughness01_scalar = frame.roughness01_scalar;
                    current_landscape.loudness_mass = frame.loudness_mass;
                    current_landscape.subjective_intensity = frame.subjective_intensity;
                    current_landscape.nsgt_power = frame.nsgt_power;
                    roughness_updated = true;
                }

                if let Some(h_scan) = &latest_h_scan {
                    debug_assert_eq!(h_scan.len(), current_landscape.space.n_bins());
                    if h_scan.len() == current_landscape.harmonicity.len() {
                        current_landscape.harmonicity.clone_from(h_scan);
                        harmonicity_updated = true;
                    }
                }

                if roughness_updated || harmonicity_updated {
                    current_landscape.recompute_consonance(&lparams);
                    if cfg!(debug_assertions) && frame_idx.is_multiple_of(30) {
                        let mut max_r = 0.0f32;
                        let mut max_i = 0usize;
                        for (i, &r) in current_landscape.roughness01.iter().enumerate() {
                            if r.is_finite() && r > max_r {
                                max_r = r;
                                max_i = i;
                            }
                        }
                        let h = current_landscape
                            .harmonicity01
                            .get(max_i)
                            .copied()
                            .unwrap_or(0.0);
                        let r = current_landscape
                            .roughness01
                            .get(max_i)
                            .copied()
                            .unwrap_or(0.0);
                        let c = current_landscape
                            .consonance
                            .get(max_i)
                            .copied()
                            .unwrap_or(0.0);
                        let c_pred = (h - lparams.consonance_roughness_weight * r).clamp(-1.0, 1.0);
                        debug!(
                            "c_signed_check bin={} h={:.4} r={:.4} c={:.4} c_pred={:.4}",
                            max_i, h, r, c, c_pred
                        );
                    }
                }

                // For frame 0 there is no previous frame to wait for.
                if frame_idx == 0 {
                    break;
                }
                let h_ok = last_h_analysis_frame.is_some_and(|id| id >= required_prev);
                let r_ok = last_r_analysis_frame.is_some_and(|id| id >= required_prev);
                if h_ok && r_ok {
                    break;
                }
                if exiting.load(Ordering::SeqCst) {
                    break;
                }
                thread::sleep(Duration::from_micros(200));
            }

            let t_start = Instant::now();
            conductor.dispatch_until(
                current_time,
                frame_idx,
                &current_landscape,
                None::<&mut crate::core::stream::roughness::RoughnessStream>,
                &mut pop,
                &mut world,
            );
            pop.drain_audio_cmds(&mut audio_cmds);

            let perc_frame = match (last_h_analysis_frame, last_r_analysis_frame) {
                (Some(h), Some(r)) => h.min(r),
                (Some(h), None) => h,
                (None, Some(r)) => r,
                (None, None) => frame_idx,
            };
            let _perc_tick = timebase.frame_start_tick(perc_frame);
            let phonation_count = if scenario_end_tick.is_none() {
                pop.publish_intents_into(
                    &mut world,
                    &current_landscape,
                    now_tick,
                    &mut phonation_batches_buf,
                )
            } else {
                0
            };
            let phonation_batches = &phonation_batches_buf[..phonation_count];
            let vitality = if pop.individuals.is_empty() {
                0.0
            } else {
                let sum: f32 = pop
                    .individuals
                    .iter()
                    .map(|agent| agent.last_signal.amplitude)
                    .sum();
                sum / pop.individuals.len() as f32
            };
            dorsal.set_vitality(vitality);
            if let Some(update) = pop.take_pending_update() {
                apply_params_update(&mut lparams, &update);
                current_landscape.recompute_consonance(&lparams);
                world.set_pred_params(lparams.clone());
                let _ = harmonicity_tx.try_send(update);
                let _ = roughness_tx.try_send(update);
            }

            if scenario_end_tick.is_none() && conductor.is_done() {
                scenario_end_tick = Some(now_tick);
                pop.individuals.clear();
                world.board.remove_onset_from(now_tick);
                schedule_renderer.shutdown_at(now_tick);
            }

            pop.advance(
                hop,
                fs,
                frame_idx,
                hop_duration.as_secs_f32(),
                &current_landscape,
            );
            let spectrum_body = pop
                .process_frame(
                    frame_idx,
                    &current_landscape.space,
                    hop_duration.as_secs_f32(),
                    conductor.is_done(),
                )
                .to_vec();
            let spectrum_body: Arc<[f32]> = Arc::from(spectrum_body);
            pop.fill_voice_targets(&mut voice_targets);

            // [FIX] Audio is MONO. Treat it as such.
            // Previously incorrectly treated as stereo, leading to bad metering and destructive downsampling.
            let (mono_chunk, max_abs, channel_peak) = {
                let time_chunk = schedule_renderer.render(
                    &world.board,
                    phonation_batches,
                    now_tick,
                    &current_landscape.rhythm,
                    &voice_targets,
                    &audio_cmds,
                );

                // Calculate Peak (Mono)
                let mut max_p = 0.0f32;
                for &s in time_chunk {
                    let abs_s = s.abs();
                    if abs_s > max_p {
                        max_p = abs_s;
                    }
                }

                // Output to Audio Backend
                // Note: If the audio backend expects Stereo, we might need to duplicate samples here.
                // But typically ringbuf just takes the slice. Assuming backend handles mono or we rely on OS mixing.
                if let Some(prod) = prod_opt.as_deref_mut() {
                    AudioOutput::push_samples(prod, time_chunk);
                }

                let mono_chunk: Arc<[f32]> = Arc::from(time_chunk);
                if let Some(tx) = wav_tx.as_ref() {
                    let _ = tx.try_send(Arc::clone(&mono_chunk));
                }

                // Channel peak for UI (Duplicate Mono to L/R)
                (mono_chunk, max_p, [max_p, max_p])
            };

            // [FIX] No Downmix needed. The signal is already Mono.
            if !finished {
                current_landscape.rhythm = dorsal.process(mono_chunk.as_ref());
            }
            let dorsal_metrics = dorsal.last_metrics();

            // Build log2 spectrum for analysis and UI (aligned with landscape space).
            latest_spec_amps.clear();
            latest_spec_amps.extend_from_slice(spectrum_body.as_ref());
            let _ = spectrum_to_harmonicity_tx.try_send((frame_idx, Arc::clone(&spectrum_body)));
            let _ = audio_to_roughness_tx.try_send((frame_idx, Arc::clone(&mono_chunk)));

            // Lag is measured against generated frames, because population dynamics depend on
            // the landscape evolution in the generated timebase (not wall-clock playback).
            let harmonicity_lag = last_h_analysis_frame.map(|id| frame_idx.saturating_sub(id));
            let roughness_lag = last_r_analysis_frame.map(|id| frame_idx.saturating_sub(id));

            let finished_now = if pop.abort_requested {
                true
            } else {
                scenario_end_tick.is_some() && schedule_renderer.is_idle()
            };
            if finished_now {
                playback_state = PlaybackState::Finished;
            }
            if finished_now && wav_tx.is_some() {
                wav_tx.take();
                info!("[t={:.6}] WAV closed.", current_time);
            }

            let must_send_ui = conductor.is_done() || pop.abort_requested;
            let should_send_ui = must_send_ui || last_ui_update.elapsed() >= ui_min_interval;

            let mut wave_frame: Option<WaveFrame> = None;
            let mut spec_frame: Option<SpecFrame> = None;
            let mut ui_landscape: Option<LandscapeFrame> = None;
            if should_send_ui {
                world.dorsal_metrics = Some(dorsal_metrics);
                wave_frame = Some(WaveFrame {
                    fs,
                    samples: Arc::clone(&mono_chunk),
                });
                spec_frame = Some(SpecFrame {
                    spec_hz: log_space.centers_hz.clone(),
                    amps: latest_spec_amps.iter().map(|&x| x.sqrt()).collect(),
                });
                ui_landscape = Some(current_landscape.clone());
            }

            let elapsed = t_start.elapsed();
            let peak_level = monitor.update(
                current_time,
                frame_idx,
                hop,
                hop_duration,
                buffer_capacity,
                occupancy,
                max_abs,
                elapsed,
                harmonicity_lag,
                roughness_lag,
                conductor.is_done(),
            );

            if let (Some(wave_frame), Some(spec_frame), Some(ui_landscape)) =
                (wave_frame, spec_frame, ui_landscape)
            {
                let world_view = world.ui_view();
                let agent_states: Vec<AgentStateInfo> = pop
                    .individuals
                    .iter()
                    .map(|agent| {
                        let f = agent.body.base_freq_hz();
                        AgentStateInfo {
                            id: agent.id,
                            freq_hz: f,
                            target_freq: 2.0f32.powf(agent.target_pitch_log2()),
                            integration_window: agent.integration_window(),
                            breath_gain: agent.articulation.gate(),
                            consonance: current_landscape.evaluate_pitch01(f),
                        }
                    })
                    .collect();
                let ui_frame = UiFrame {
                    wave: wave_frame,
                    spec: spec_frame,
                    dorsal: DorsalFrame {
                        e_low: dorsal_metrics.e_low,
                        e_mid: dorsal_metrics.e_mid,
                        e_high: dorsal_metrics.e_high,
                        flux: dorsal_metrics.flux,
                    },
                    landscape: ui_landscape,
                    time_sec: current_time,
                    meta: SimulationMeta {
                        time_sec: current_time,
                        duration_sec: conductor.total_duration(),
                        agent_count: pop.individuals.len(),
                        event_queue_len: conductor.remaining_events(),
                        peak_level,
                        scenario_name: scenario_name.clone(),
                        scene_name: conductor.current_scene_name(current_time),
                        playback_state: playback_state.clone(),
                        channel_peak,
                        window_peak: channel_peak,
                    },
                    agents: agent_states,
                    world: world_view,
                };
                let _ = ui_tx.try_send(ui_frame);
                last_ui_update = Instant::now();
            }

            if finished_now {
                finished = true;
                if !finish_logged {
                    let note = if wait_user_exit {
                        "Waiting for user exit."
                    } else {
                        "Exiting."
                    };
                    info!("[t={:.6}] Scenario finished. {note}", current_time);
                    finish_logged = true;
                }
                if !wait_user_exit {
                    exiting.store(true, Ordering::SeqCst);
                }
            }

            if !finished {
                current_time += hop_duration.as_secs_f32();
                frame_idx += 1;
            }
        };

        if let Some(prod) = audio_prod.as_mut() {
            while prod.vacant_len() >= hop {
                process_frame(Some(prod));
            }
        } else {
            // Offline/render-only mode: progress even without audio output.
            process_frame(None);
        }

        if exiting.load(Ordering::SeqCst) || (finished && !wait_user_exit) {
            break;
        }

        if !produced_any {
            thread::sleep(Duration::from_millis(1));
        }
    }
}

fn apply_params_update(params: &mut LandscapeParams, upd: &LandscapeUpdate) {
    if let Some(m) = upd.mirror {
        params.harmonicity_kernel.params.mirror_weight = m;
    }
    if let Some(l) = upd.limit {
        params.harmonicity_kernel.params.param_limit = l;
    }
    if let Some(k) = upd.roughness_k {
        params.roughness_k = k.max(1e-6);
    }
}
</file>

<file path="src/life/scenario.rs">
use schemars::JsonSchema;
use serde::{
    Deserialize, Serialize,
    de::{self, Deserializer},
    ser::{SerializeMap, Serializer},
};
use std::fmt;

use crate::core::landscape::LandscapeUpdate;
use crate::life::control::AgentControl;
use crate::life::individual::{AgentMetadata, Individual};
use crate::life::lifecycle::LifecycleConfig;
use serde_json::Value;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Scenario {
    pub seed: u64,
    pub scene_markers: Vec<SceneMarker>,
    pub events: Vec<TimedEvent>,
    pub duration_sec: f32,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SceneMarker {
    pub name: String,
    pub time: f32,
    pub order: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TimedEvent {
    pub time: f32,
    pub order: u64,
    pub actions: Vec<Action>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct EnvelopeConfig {
    pub attack_sec: f32,
    pub decay_sec: f32,
    pub sustain_level: f32,
}

impl Default for EnvelopeConfig {
    fn default() -> Self {
        Self {
            attack_sec: 0.01,
            decay_sec: 0.1,
            sustain_level: 0.0,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(rename_all = "snake_case")]
pub enum HarmonicMode {
    Harmonic, // Integer multiples (1, 2, 3...)
    Metallic, // Non-integer ratios (e.g., k^1.4)
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
pub struct TimbreGenotype {
    pub mode: HarmonicMode,

    // --- Structure ---
    pub stiffness: f32, // Inharmonicity coefficient

    // --- Color ---
    pub brightness: f32, // Spectral slope decay
    pub comb: f32,       // Even harmonic attenuation

    // --- Physics (Time-variant) ---
    pub damping: f32, // High-frequency decay factor based on energy level

    // --- Fluctuation & Texture ---
    pub vibrato_rate: f32,
    pub vibrato_depth: f32,
    pub jitter: f32, // 1/f Pink Noise FM strength
    pub unison: f32, // Detune amount (0.0 = single)
}

impl Default for TimbreGenotype {
    fn default() -> Self {
        Self {
            mode: HarmonicMode::Harmonic,
            stiffness: 0.0,
            brightness: 0.6,
            comb: 0.0,
            damping: 0.5,
            vibrato_rate: 5.0,
            vibrato_depth: 0.0,
            jitter: 0.0,
            unison: 0.0,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum PhonationIntervalConfig {
    None,
    Accumulator {
        rate: f32,
        #[serde(default)]
        refractory: u32,
    },
}

impl Default for PhonationIntervalConfig {
    fn default() -> Self {
        PhonationIntervalConfig::Accumulator {
            rate: 1.0,
            refractory: 1,
        }
    }
}

impl<'de> Deserialize<'de> for PhonationIntervalConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Value::deserialize(deserializer)?;
        match value {
            Value::String(s) => match s.as_str() {
                "none" => Ok(PhonationIntervalConfig::None),
                _ => Err(de::Error::custom(format!(
                    "phonation interval must be \"none\" or a map (got \"{s}\")"
                ))),
            },
            Value::Object(map) => {
                let ty = map
                    .get("type")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| de::Error::custom("phonation interval missing `type`"))?;
                match ty {
                    "none" => Ok(PhonationIntervalConfig::None),
                    "accumulator" => {
                        let rate = map.get("rate").and_then(|v| v.as_f64()).ok_or_else(|| {
                            de::Error::custom("phonation interval accumulator requires `rate`")
                        })? as f32;
                        let refractory =
                            map.get("refractory").and_then(|v| v.as_u64()).unwrap_or(0) as u32;
                        Ok(PhonationIntervalConfig::Accumulator { rate, refractory })
                    }
                    _ => Err(de::Error::custom(format!(
                        "phonation interval type must be \"none\" or \"accumulator\" (got \"{ty}\")"
                    ))),
                }
            }
            _ => Err(de::Error::custom(
                "phonation interval must be a string or map",
            )),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct SubdivisionClockConfig {
    pub divisions: Vec<u32>,
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct InternalPhaseClockConfig {
    pub ratio: f32,
    #[serde(default)]
    pub phase0: f32,
}

#[derive(Debug, Clone, PartialEq, JsonSchema, Default)]
pub enum PhonationClockConfig {
    #[default]
    ThetaGate,
    Composite {
        subdivision: Option<SubdivisionClockConfig>,
        internal_phase: Option<InternalPhaseClockConfig>,
    },
}

impl Serialize for PhonationClockConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            PhonationClockConfig::ThetaGate => serializer.serialize_str("theta_gate"),
            PhonationClockConfig::Composite {
                subdivision,
                internal_phase,
            } => {
                let mut map = serializer.serialize_map(None)?;
                map.serialize_entry("type", "composite")?;
                if let Some(config) = subdivision {
                    map.serialize_entry("subdivision", config)?;
                }
                if let Some(config) = internal_phase {
                    map.serialize_entry("internal_phase", config)?;
                }
                map.end()
            }
        }
    }
}

impl<'de> Deserialize<'de> for PhonationClockConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Value::deserialize(deserializer)?;
        match value {
            Value::String(s) => {
                let lowered = s.to_ascii_lowercase();
                match lowered.as_str() {
                    "theta_gate" | "thetagate" => Ok(Self::ThetaGate),
                    _ => Err(de::Error::custom(format!(
                        "phonation clock must be \"theta_gate\" (got \"{s}\")"
                    ))),
                }
            }
            Value::Object(map) => {
                let ty = map
                    .get("type")
                    .and_then(|v| v.as_str())
                    .unwrap_or("composite");
                match ty {
                    "composite" => {
                        let mut subdivision = None;
                        let mut internal_phase = None;
                        for (k, v) in map {
                            match k.as_str() {
                                "type" => {}
                                "subdivision" => {
                                    subdivision = Some(
                                        SubdivisionClockConfig::deserialize(v)
                                            .map_err(de::Error::custom)?,
                                    );
                                }
                                "internal_phase" => {
                                    internal_phase = Some(
                                        InternalPhaseClockConfig::deserialize(v)
                                            .map_err(de::Error::custom)?,
                                    );
                                }
                                _ => {
                                    return Err(de::Error::custom(format!(
                                        "phonation clock has unknown key: {k}"
                                    )));
                                }
                            }
                        }
                        Ok(Self::Composite {
                            subdivision,
                            internal_phase,
                        })
                    }
                    _ => Err(de::Error::custom(format!(
                        "phonation clock type must be \"composite\" (got \"{ty}\")"
                    ))),
                }
            }
            _ => Err(de::Error::custom("phonation clock must be a string or map")),
        }
    }
}

#[derive(Debug, Clone, PartialEq, JsonSchema, Default)]
pub enum SubThetaModConfig {
    #[default]
    None,
    Cosine {
        n: u32,
        depth: f32,
        phase0: f32,
    },
}

impl Serialize for SubThetaModConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        match self {
            SubThetaModConfig::None => serializer.serialize_str("none"),
            SubThetaModConfig::Cosine { n, depth, phase0 } => {
                let mut map = serializer.serialize_map(None)?;
                map.serialize_entry("type", "cosine")?;
                map.serialize_entry("n", n)?;
                map.serialize_entry("depth", depth)?;
                map.serialize_entry("phase0", phase0)?;
                map.end()
            }
        }
    }
}

impl<'de> Deserialize<'de> for SubThetaModConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Value::deserialize(deserializer)?;
        match value {
            Value::String(s) => {
                let lowered = s.to_ascii_lowercase();
                match lowered.as_str() {
                    "none" => Ok(Self::None),
                    _ => Err(de::Error::custom(format!(
                        "sub_theta_mod must be \"none\" (got \"{s}\")"
                    ))),
                }
            }
            Value::Object(map) => {
                let ty = map.get("type").and_then(|v| v.as_str()).unwrap_or("cosine");
                match ty {
                    "cosine" => {
                        let n = map.get("n").and_then(|v| v.as_u64()).unwrap_or(1) as u32;
                        let depth = map.get("depth").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        let phase0 =
                            map.get("phase0").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        Ok(Self::Cosine { n, depth, phase0 })
                    }
                    _ => Err(de::Error::custom(format!(
                        "sub_theta_mod type must be \"cosine\" (got \"{ty}\")"
                    ))),
                }
            }
            _ => Err(de::Error::custom("sub_theta_mod must be a string or map")),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, JsonSchema)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum PhonationConnectConfig {
    FixedGate {
        length_gates: u32,
    },
    Field {
        hold_min_theta: f32,
        hold_max_theta: f32,
        curve_k: f32,
        curve_x0: f32,
        drop_gain: f32,
    },
}

impl Default for PhonationConnectConfig {
    fn default() -> Self {
        PhonationConnectConfig::FixedGate { length_gates: 8 }
    }
}

impl<'de> Deserialize<'de> for PhonationConnectConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Value::deserialize(deserializer)?;
        match value {
            Value::String(s) => match s.as_str() {
                "fixed_gate" => Ok(PhonationConnectConfig::FixedGate { length_gates: 8 }),
                "field" => Ok(PhonationConnectConfig::Field {
                    hold_min_theta: 0.25,
                    hold_max_theta: 1.0,
                    curve_k: 4.0,
                    curve_x0: 0.5,
                    drop_gain: 0.0,
                }),
                _ => Err(de::Error::custom(format!(
                    "phonation connect must be \"fixed_gate\" or a map (got \"{s}\")"
                ))),
            },
            Value::Object(map) => {
                let ty = map
                    .get("type")
                    .and_then(|v| v.as_str())
                    .ok_or_else(|| de::Error::custom("phonation connect missing `type`"))?;
                match ty {
                    "fixed_gate" => {
                        for key in map.keys() {
                            match key.as_str() {
                                "type" | "length_gates" => {}
                                _ => {
                                    return Err(de::Error::custom(format!(
                                        "phonation connect fixed_gate has unknown key `{key}`; allowed keys: type, length_gates",
                                    )));
                                }
                            }
                        }
                        let length_gates = map
                            .get("length_gates")
                            .and_then(|v| v.as_u64())
                            .unwrap_or(8) as u32;
                        Ok(PhonationConnectConfig::FixedGate { length_gates })
                    }
                    "field" => {
                        for key in map.keys() {
                            match key.as_str() {
                                "type" | "hold_min_theta" | "hold_max_theta" | "curve_k"
                                | "curve_x0" | "drop_gain" => {}
                                _ => {
                                    return Err(de::Error::custom(format!(
                                        "phonation connect field has unknown key `{key}`; allowed keys: type, hold_min_theta, hold_max_theta, curve_k, curve_x0, drop_gain",
                                    )));
                                }
                            }
                        }
                        let hold_min_theta = map
                            .get("hold_min_theta")
                            .and_then(|v| v.as_f64())
                            .unwrap_or(0.25) as f32;
                        let hold_max_theta = map
                            .get("hold_max_theta")
                            .and_then(|v| v.as_f64())
                            .unwrap_or(1.0) as f32;
                        let curve_k =
                            map.get("curve_k").and_then(|v| v.as_f64()).unwrap_or(4.0) as f32;
                        let curve_x0 =
                            map.get("curve_x0").and_then(|v| v.as_f64()).unwrap_or(0.5) as f32;
                        let drop_gain =
                            map.get("drop_gain").and_then(|v| v.as_f64()).unwrap_or(0.0) as f32;
                        Ok(PhonationConnectConfig::Field {
                            hold_min_theta,
                            hold_max_theta,
                            curve_k,
                            curve_x0,
                            drop_gain,
                        })
                    }
                    _ => Err(de::Error::custom(format!(
                        "phonation connect type must be \"fixed_gate\" or \"field\" (got \"{ty}\")"
                    ))),
                }
            }
            _ => Err(de::Error::custom(
                "phonation connect must be a string or map",
            )),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct SocialConfig {
    #[serde(default)]
    pub coupling: f32,
    #[serde(default)]
    pub bin_ticks: u32,
    #[serde(default)]
    pub smooth: f32,
}

impl Default for SocialConfig {
    fn default() -> Self {
        Self {
            coupling: 0.0,
            bin_ticks: 0,
            smooth: 0.0,
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize, JsonSchema, Default)]
#[serde(rename_all = "snake_case")]
pub enum PhonationMode {
    #[default]
    Gated,
    Hold,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct PhonationConfig {
    #[serde(default)]
    pub mode: PhonationMode,
    #[serde(default)]
    pub interval: PhonationIntervalConfig,
    #[serde(default)]
    pub connect: PhonationConnectConfig,
    #[serde(default)]
    pub clock: PhonationClockConfig,
    #[serde(default)]
    pub sub_theta_mod: SubThetaModConfig,
    #[serde(default)]
    pub social: SocialConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(deny_unknown_fields)]
pub struct IndividualConfig {
    #[serde(default)]
    pub control: AgentControl,
    pub tag: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "core", rename_all = "snake_case", deny_unknown_fields)]
pub enum SoundBodyConfig {
    Sine {
        #[serde(default)]
        phase: Option<f32>,
    },
    Harmonic {
        #[serde(default, flatten)]
        genotype: TimbreGenotype,
        #[serde(default)]
        partials: Option<usize>,
    },
}

impl Default for SoundBodyConfig {
    fn default() -> Self {
        SoundBodyConfig::Sine { phase: None }
    }
}

#[derive(Debug, Clone, Serialize, JsonSchema)]
#[serde(tag = "core", rename_all = "snake_case", deny_unknown_fields)]
pub enum ArticulationCoreConfig {
    Entrain {
        #[serde(flatten)]
        lifecycle: LifecycleConfig,
        #[serde(default)]
        rhythm_freq: Option<f32>,
        #[serde(default)]
        rhythm_sensitivity: Option<f32>,
        #[serde(default)]
        breath_gain_init: Option<f32>,
    },
    Seq {
        duration: f32,
        #[serde(default)]
        breath_gain_init: Option<f32>,
    },
    Drone {
        #[serde(default)]
        sway: Option<f32>,
        #[serde(default)]
        breath_gain_init: Option<f32>,
    },
}

impl Default for ArticulationCoreConfig {
    fn default() -> Self {
        ArticulationCoreConfig::Entrain {
            lifecycle: LifecycleConfig::default(),
            rhythm_freq: None,
            rhythm_sensitivity: None,
            breath_gain_init: None,
        }
    }
}

impl<'de> Deserialize<'de> for ArticulationCoreConfig {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let value = Value::deserialize(deserializer)?;
        let obj = value
            .as_object()
            .ok_or_else(|| de::Error::custom("articulation core must be a map"))?;
        let core = obj
            .get("core")
            .and_then(|v| v.as_str())
            .ok_or_else(|| de::Error::custom("articulation core missing `core`"))?;
        match core {
            "entrain" => {
                let rhythm_freq = obj
                    .get("rhythm_freq")
                    .and_then(|v| v.as_f64())
                    .map(|v| v as f32);
                let rhythm_sensitivity = obj
                    .get("rhythm_sensitivity")
                    .and_then(|v| v.as_f64())
                    .map(|v| v as f32);
                let breath_gain_init = obj
                    .get("breath_gain_init")
                    .and_then(|v| v.as_f64())
                    .map(|v| v as f32);
                let mut lifecycle_obj = obj.clone();
                lifecycle_obj.remove("core");
                lifecycle_obj.remove("rhythm_freq");
                lifecycle_obj.remove("rhythm_sensitivity");
                lifecycle_obj.remove("breath_gain_init");
                let lifecycle_value = Value::Object(lifecycle_obj);
                let lifecycle =
                    LifecycleConfig::deserialize(lifecycle_value).map_err(de::Error::custom)?;
                Ok(ArticulationCoreConfig::Entrain {
                    lifecycle,
                    rhythm_freq,
                    rhythm_sensitivity,
                    breath_gain_init,
                })
            }
            "seq" => {
                for key in obj.keys() {
                    if key != "core" && key != "duration" && key != "breath_gain_init" {
                        return Err(de::Error::unknown_field(
                            key,
                            &["core", "duration", "breath_gain_init"],
                        ));
                    }
                }
                let duration = obj
                    .get("duration")
                    .and_then(|v| v.as_f64())
                    .ok_or_else(|| de::Error::custom("seq core requires `duration`"))?
                    as f32;
                let breath_gain_init = obj
                    .get("breath_gain_init")
                    .and_then(|v| v.as_f64())
                    .map(|v| v as f32);
                Ok(ArticulationCoreConfig::Seq {
                    duration,
                    breath_gain_init,
                })
            }
            "drone" => {
                for key in obj.keys() {
                    if key != "core" && key != "sway" && key != "breath_gain_init" {
                        return Err(de::Error::unknown_field(
                            key,
                            &["core", "sway", "breath_gain_init"],
                        ));
                    }
                }
                let sway = obj.get("sway").and_then(|v| v.as_f64()).map(|v| v as f32);
                let breath_gain_init = obj
                    .get("breath_gain_init")
                    .and_then(|v| v.as_f64())
                    .map(|v| v as f32);
                Ok(ArticulationCoreConfig::Drone {
                    sway,
                    breath_gain_init,
                })
            }
            other => Err(de::Error::unknown_variant(
                other,
                &["entrain", "seq", "drone"],
            )),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "core", rename_all = "snake_case", deny_unknown_fields)]
pub enum PitchCoreConfig {
    PitchHillClimb {
        #[serde(default)]
        neighbor_step_cents: Option<f32>,
        #[serde(default)]
        tessitura_gravity: Option<f32>,
        #[serde(default)]
        improvement_threshold: Option<f32>,
        #[serde(default)]
        exploration: Option<f32>,
        #[serde(default)]
        persistence: Option<f32>,
    },
}

impl Default for PitchCoreConfig {
    fn default() -> Self {
        PitchCoreConfig::PitchHillClimb {
            neighbor_step_cents: None,
            tessitura_gravity: None,
            improvement_threshold: None,
            exploration: None,
            persistence: None,
        }
    }
}

// Scenes are represented by SceneMarker and do not own events.

impl IndividualConfig {
    pub fn id(&self) -> Option<u64> {
        None
    }

    pub fn tag(&self) -> Option<&String> {
        self.tag.as_ref()
    }

    pub fn spawn(
        &self,
        assigned_id: u64,
        start_frame: u64,
        mut metadata: AgentMetadata,
        fs: f32,
        seed_offset: u64,
    ) -> Individual {
        metadata.id = assigned_id;
        if metadata.tag.is_none() {
            metadata.tag = self.tag().cloned();
        }
        Individual::spawn_from_control(
            self.control.clone(),
            assigned_id,
            start_frame,
            metadata,
            fs,
            seed_offset,
        )
    }
}

impl fmt::Display for IndividualConfig {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let tag_str = self.tag.as_deref().unwrap_or("-");
        write!(f, "Agent(tag={}, control={:?})", tag_str, self.control)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Action {
    Spawn {
        tag: String,
        count: u32,
        #[serde(default, skip_serializing_if = "Option::is_none")]
        opts: Option<SpawnOpts>,
        patch: Value,
    },
    Set {
        target: String,
        patch: Value,
    },
    Unset {
        target: String,
        path: String,
    },
    Remove {
        target: String,
    },
    Release {
        target: String,
        fade_sec: f32,
    },
    SetHarmonicity {
        update: LandscapeUpdate,
    },
    SetGlobalCoupling {
        value: f32,
    },
    SetRoughnessTolerance {
        value: f32,
    },
    PostIntent {
        source_id: u64,
        onset_sec: f32,
        duration_sec: f32,
        freq_hz: f32,
        amp: f32,
        tag: Option<String>,
        confidence: f32,
    },
    Finish,
}

impl fmt::Display for Action {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Action::Spawn { tag, count, .. } => write!(f, "Spawn tag={} count={}", tag, count),
            Action::Set { target, .. } => write!(f, "Set target={}", target),
            Action::Unset { target, path } => {
                write!(f, "Unset target={} path={}", target, path)
            }
            Action::Remove { target } => write!(f, "Remove target={}", target),
            Action::Release { target, fade_sec } => {
                write!(f, "Release target={} fade={:.3}", target, fade_sec)
            }
            Action::SetHarmonicity { update } => write!(
                f,
                "SetHarmonicity mirror={:?} limit={:?} roughness_k={:?}",
                update.mirror, update.limit, update.roughness_k
            ),
            Action::SetGlobalCoupling { value } => {
                write!(f, "SetGlobalCoupling value={:.3}", value)
            }
            Action::SetRoughnessTolerance { value } => {
                write!(f, "SetRoughnessTolerance value={:.3}", value)
            }
            Action::PostIntent {
                source_id,
                onset_sec,
                duration_sec,
                freq_hz,
                amp,
                tag,
                confidence,
            } => write!(
                f,
                "PostIntent src={} onset={:.3} dur={:.3} freq={:.1} amp={:.3} tag={:?} conf={:.2}",
                source_id, onset_sec, duration_sec, freq_hz, amp, tag, confidence
            ),
            Action::Finish => write!(f, "Finish"),
        }
    }
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema)]
#[serde(tag = "mode", rename_all = "snake_case", deny_unknown_fields)]
pub enum SpawnMethod {
    /// Deterministically search a frequency that maximizes H = C - R.
    #[schemars(title = "harmonicity")]
    Harmonicity {
        min_freq: f32,
        max_freq: f32,
        /// Minimum ERB distance between newborn fundamentals at spawn time. Default: 1.0
        min_dist_erb: Option<f32>,
    },
    /// Deterministically search a frequency that minimizes H = C - R.
    #[schemars(title = "low_harmonicity")]
    LowHarmonicity {
        min_freq: f32,
        max_freq: f32,
        /// Minimum ERB distance between newborn fundamentals at spawn time. Default: 1.0
        min_dist_erb: Option<f32>,
    },
    /// Stochastically sample using H as a density (temperature controls sharpness).
    #[schemars(title = "harmonic_density")]
    HarmonicDensity {
        min_freq: f32,
        max_freq: f32,
        temperature: Option<f32>,
        /// Minimum ERB distance between newborn fundamentals at spawn time. Default: 1.0
        min_dist_erb: Option<f32>,
    },
    /// Search for a region where H ≈ 0.5 (midpoint of normalized consonance).
    #[schemars(title = "zero_crossing")]
    ZeroCrossing {
        min_freq: f32,
        max_freq: f32,
        /// Minimum ERB distance between newborn fundamentals at spawn time. Default: 1.0
        min_dist_erb: Option<f32>,
    },
    /// Search for an energy gap (a spectral valley).
    #[schemars(title = "spectral_gap")]
    SpectralGap {
        min_freq: f32,
        max_freq: f32,
        /// Minimum ERB distance between newborn fundamentals at spawn time. Default: 1.0
        min_dist_erb: Option<f32>,
    },
    /// Random log-uniform sampling between `min_freq` and `max_freq`.
    #[schemars(title = "random_log_uniform")]
    RandomLogUniform {
        min_freq: f32,
        max_freq: f32,
        /// Minimum ERB distance between newborn fundamentals at spawn time. Default: 1.0
        min_dist_erb: Option<f32>,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize, JsonSchema, Default)]
#[serde(deny_unknown_fields)]
pub struct SpawnOpts {
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub method: Option<SpawnMethod>,
}

impl Default for SpawnMethod {
    fn default() -> Self {
        SpawnMethod::RandomLogUniform {
            min_freq: 110.0,
            max_freq: 440.0,
            min_dist_erb: Some(0.0),
        }
    }
}

impl SpawnMethod {
    pub fn freq_range_hz(&self) -> (f32, f32) {
        match self {
            SpawnMethod::Harmonicity {
                min_freq, max_freq, ..
            }
            | SpawnMethod::LowHarmonicity {
                min_freq, max_freq, ..
            }
            | SpawnMethod::HarmonicDensity {
                min_freq, max_freq, ..
            }
            | SpawnMethod::ZeroCrossing {
                min_freq, max_freq, ..
            }
            | SpawnMethod::SpectralGap {
                min_freq, max_freq, ..
            }
            | SpawnMethod::RandomLogUniform {
                min_freq, max_freq, ..
            } => (*min_freq, *max_freq),
        }
    }

    pub fn min_dist_erb_or_default(&self) -> f32 {
        let min_dist_erb = match self {
            SpawnMethod::Harmonicity { min_dist_erb, .. }
            | SpawnMethod::LowHarmonicity { min_dist_erb, .. }
            | SpawnMethod::HarmonicDensity { min_dist_erb, .. }
            | SpawnMethod::ZeroCrossing { min_dist_erb, .. }
            | SpawnMethod::SpectralGap { min_dist_erb, .. }
            | SpawnMethod::RandomLogUniform { min_dist_erb, .. } => *min_dist_erb,
        };
        min_dist_erb.unwrap_or(1.0)
    }
}

impl fmt::Display for SpawnMethod {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            SpawnMethod::Harmonicity {
                min_freq,
                max_freq,
                min_dist_erb,
            } => write!(
                f,
                "method=harmonicity({:.1}-{:.1} Hz, min_dist_erb={})",
                min_freq,
                max_freq,
                min_dist_erb.unwrap_or(1.0)
            ),
            SpawnMethod::LowHarmonicity {
                min_freq,
                max_freq,
                min_dist_erb,
            } => write!(
                f,
                "method=low_harmonicity({:.1}-{:.1} Hz, min_dist_erb={})",
                min_freq,
                max_freq,
                min_dist_erb.unwrap_or(1.0)
            ),
            SpawnMethod::HarmonicDensity {
                min_freq,
                max_freq,
                temperature,
                min_dist_erb,
            } => {
                let temp = temperature.unwrap_or(1.0);
                write!(
                    f,
                    "method=harmonic_density({:.1}-{:.1} Hz, temp={}, min_dist_erb={})",
                    min_freq,
                    max_freq,
                    temp,
                    min_dist_erb.unwrap_or(1.0)
                )
            }
            SpawnMethod::ZeroCrossing {
                min_freq,
                max_freq,
                min_dist_erb,
            } => {
                write!(
                    f,
                    "method=zero_crossing({:.1}-{:.1} Hz, min_dist_erb={})",
                    min_freq,
                    max_freq,
                    min_dist_erb.unwrap_or(1.0)
                )
            }
            SpawnMethod::SpectralGap {
                min_freq,
                max_freq,
                min_dist_erb,
            } => write!(
                f,
                "method=spectral_gap({:.1}-{:.1} Hz, min_dist_erb={})",
                min_freq,
                max_freq,
                min_dist_erb.unwrap_or(1.0)
            ),
            SpawnMethod::RandomLogUniform {
                min_freq,
                max_freq,
                min_dist_erb,
            } => write!(
                f,
                "method=random_log_uniform({:.1}-{:.1} Hz, min_dist_erb={})",
                min_freq,
                max_freq,
                min_dist_erb.unwrap_or(1.0)
            ),
        }
    }
}
</file>

<file path="src/life/population.rs">
use super::control::{AgentControl, matches_tag_pattern, merge_json};
use super::individual::{AgentMetadata, Individual, PhonationBatch, SoundBody};
use super::scenario::{Action, IndividualConfig, SocialConfig, SpawnMethod};
use crate::core::landscape::{LandscapeFrame, LandscapeUpdate};
use crate::core::log2space::Log2Space;
use crate::core::timebase::{Tick, Timebase};
use crate::life::social_density::SocialDensityTrace;
use crate::life::sound::{AudioCommand, VoiceTarget};
use crate::life::world_model::WorldModel;
use rand::{Rng, SeedableRng, distr::Distribution, distr::weighted::WeightedIndex, rngs::SmallRng};
use std::hash::{Hash, Hasher};
use tracing::{debug, info, warn};

#[derive(Default)]
struct WorkBuffers {
    amps: Vec<f32>,
}

pub struct Population {
    pub individuals: Vec<Individual>,
    current_frame: u64,
    pub abort_requested: bool,
    buffers: WorkBuffers,
    pub global_coupling: f32,
    birth_energy: f32,
    shutdown_gain: f32,
    pending_update: Option<LandscapeUpdate>,
    time: Timebase,
    seed: u64,
    next_agent_id: u64,
    spawn_counter: u64,
    social_trace: Option<SocialDensityTrace>,
    audio_cmds: Vec<AudioCommand>,
}

impl Population {
    const REMOVE_FADE_SEC_DEFAULT: f32 = 0.05;
    const CONTROL_STEP_SAMPLES: usize = 64;
    /// Returns true if `freq_hz` is within `min_dist_erb` (ERB scale) of any existing agent's base
    /// frequency.
    pub fn is_range_occupied(&self, freq_hz: f32, min_dist_erb: f32) -> bool {
        if !freq_hz.is_finite() || min_dist_erb <= 0.0 {
            return false;
        }
        let target_erb = crate::core::erb::hz_to_erb(freq_hz.max(1e-6));
        for agent in &self.individuals {
            let base_hz = agent.body.base_freq_hz();
            if !base_hz.is_finite() {
                continue;
            }
            let d_erb = (crate::core::erb::hz_to_erb(base_hz.max(1e-6)) - target_erb).abs();
            if d_erb < min_dist_erb {
                return true;
            }
        }
        false
    }

    pub fn new(time: Timebase) -> Self {
        debug!("Population sample rate: {:.1} Hz", time.fs);
        Self {
            individuals: Vec::new(),
            current_frame: 0,
            abort_requested: false,
            buffers: WorkBuffers::default(),
            global_coupling: 1.0,
            birth_energy: 1.0,
            shutdown_gain: 1.0,
            pending_update: None,
            time,
            seed: rand::random::<u64>(),
            next_agent_id: 1,
            spawn_counter: 0,
            social_trace: None,
            audio_cmds: Vec::new(),
        }
    }

    pub fn set_seed(&mut self, seed: u64) {
        self.seed = seed;
    }

    fn spawn_seed(&self, tag: &str, count: u32, seq: u64) -> u64 {
        let mut hasher = std::collections::hash_map::DefaultHasher::new();
        self.seed.hash(&mut hasher);
        self.current_frame.hash(&mut hasher);
        seq.hash(&mut hasher);
        count.hash(&mut hasher);
        tag.hash(&mut hasher);
        hasher.finish() ^ 0x9E37_79B9_7F4A_7C15
    }

    fn find_individual_mut(&mut self, id: u64) -> Option<&mut Individual> {
        self.individuals.iter_mut().find(|a| a.id() == id)
    }

    pub fn add_individual(&mut self, individual: Individual) {
        let id = individual.id();
        if self.individuals.iter().any(|a| a.id() == id) {
            warn!("AddIndividual: id collision for {id}");
            return;
        }
        self.individuals.push(individual);
    }

    pub fn set_current_frame(&mut self, frame: u64) {
        self.current_frame = frame;
    }

    pub fn drain_audio_cmds(&mut self, out: &mut Vec<AudioCommand>) {
        out.clear();
        out.append(&mut self.audio_cmds);
    }

    pub fn fill_voice_targets(&self, out: &mut Vec<VoiceTarget>) {
        out.clear();
        out.reserve(self.individuals.len());
        for agent in &self.individuals {
            if !agent.is_alive() {
                continue;
            }
            let pitch_hz = agent.body.base_freq_hz();
            let amp = agent.body.amp();
            out.push(VoiceTarget {
                id: agent.id(),
                pitch_hz,
                amp,
            });
        }
    }

    pub fn publish_intents(
        &mut self,
        world: &mut WorldModel,
        landscape: &LandscapeFrame,
        now: Tick,
    ) -> Vec<PhonationBatch> {
        let mut batches = Vec::new();
        let count = self.publish_intents_into(world, landscape, now, &mut batches);
        batches.truncate(count);
        batches
    }

    pub(crate) fn publish_intents_into(
        &mut self,
        world: &mut WorldModel,
        landscape: &LandscapeFrame,
        now: Tick,
        out: &mut Vec<PhonationBatch>,
    ) -> usize {
        let hop_tick = (world.time.hop as Tick).max(1);
        let tb = &world.time;
        let frame_end = now.saturating_add(hop_tick);
        let mut used = 0usize;
        let social_trace = self.social_trace.as_ref();
        for agent in &mut self.individuals {
            let social_coupling = agent.phonation_social.coupling;
            if used == out.len() {
                out.push(PhonationBatch::default());
            }
            let batch = &mut out[used];
            agent.tick_phonation_into(
                tb,
                now,
                &landscape.rhythm,
                social_trace,
                social_coupling,
                batch,
            );
            let has_output =
                !(batch.cmds.is_empty() && batch.notes.is_empty() && batch.onsets.is_empty());
            if has_output {
                used += 1;
            }
        }
        let active_batches = &out[..used];
        let social_enabled =
            social_trace_enabled_from_configs(self.individuals.iter().map(|a| a.phonation_social));
        if social_enabled {
            let (bin_ticks, smooth) = social_trace_params(&self.individuals, hop_tick);
            self.social_trace = Some(build_social_trace_from_batches(
                active_batches,
                frame_end,
                hop_tick,
                bin_ticks,
                smooth,
                self.individuals.len(),
            ));
        } else {
            self.social_trace = None;
        }
        used
    }

    fn resolve_target_ids(&self, pattern: &str) -> Vec<u64> {
        self.individuals
            .iter()
            .filter_map(|a| {
                let meta = a.metadata();
                match meta.tag.as_deref() {
                    Some(tag) if matches_tag_pattern(pattern, tag) => Some(meta.id),
                    _ => None,
                }
            })
            .collect()
    }

    fn decide_frequency<R: Rng + ?Sized>(
        &self,
        method: &SpawnMethod,
        landscape: &LandscapeFrame,
        rng: &mut R,
    ) -> f32 {
        let space = &landscape.space;
        let n_bins = space.n_bins();
        if n_bins == 0 {
            return 440.0;
        }

        let (min_freq, max_freq) = method.freq_range_hz();

        let mut idx_min = space.index_of_freq(min_freq).unwrap_or(0);
        let mut idx_max = space
            .index_of_freq(max_freq)
            .unwrap_or_else(|| n_bins.saturating_sub(1));
        if idx_min > idx_max {
            std::mem::swap(&mut idx_min, &mut idx_max);
        }
        idx_max = idx_max.min(n_bins.saturating_sub(1));
        if idx_min >= n_bins || idx_min > idx_max {
            return space.freq_of_index(n_bins / 2);
        }

        let min_dist_erb = method.min_dist_erb_or_default();

        let jitter_bin = |idx: usize, rng: &mut R| -> f32 {
            let idx = idx.min(n_bins - 1);
            let center = space.freq_of_index(idx);
            let step = space.step();
            let half = step * 0.5;
            let center_log2 = center.log2();
            let sample_log2 = rng.random_range((center_log2 - half)..(center_log2 + half));
            2.0f32.powf(sample_log2).clamp(space.fmin, space.fmax)
        };

        let jitter_free_bin = |idx: usize, rng: &mut R| -> f32 {
            let center = space.freq_of_index(idx.min(n_bins - 1));
            // Try a few times to jitter within the bin while avoiding occupied bands.
            for _ in 0..16 {
                let f = jitter_bin(idx, rng);
                if !self.is_range_occupied(f, min_dist_erb) {
                    return f;
                }
            }
            center
        };

        let pick_idx = match method {
            SpawnMethod::Harmonicity { .. } => {
                let mut best = idx_min;
                let mut best_val = f32::MIN;
                let mut found = false;
                for i in idx_min..=idx_max {
                    let f = space.freq_of_index(i);
                    if self.is_range_occupied(f, min_dist_erb) {
                        continue;
                    }
                    if let Some(&c_val) = landscape.consonance01.get(i)
                        && c_val > best_val
                    {
                        found = true;
                        best_val = c_val;
                        best = i;
                    }
                }
                if found {
                    best
                } else {
                    // Fallback: everything is occupied; pick the best bin ignoring occupancy.
                    let mut best = idx_min;
                    let mut best_val = f32::MIN;
                    for i in idx_min..=idx_max {
                        if let Some(&c_val) = landscape.consonance01.get(i)
                            && c_val > best_val
                        {
                            best_val = c_val;
                            best = i;
                        }
                    }
                    best
                }
            }
            SpawnMethod::LowHarmonicity { .. } => {
                let mut best = idx_min;
                let mut best_val = f32::MAX;
                let mut found = false;
                for i in idx_min..=idx_max {
                    let f = space.freq_of_index(i);
                    if self.is_range_occupied(f, min_dist_erb) {
                        continue;
                    }
                    if let Some(&v) = landscape.consonance01.get(i)
                        && v < best_val
                    {
                        found = true;
                        best_val = v;
                        best = i;
                    }
                }
                if found { best } else { idx_min }
            }
            SpawnMethod::ZeroCrossing { .. } => {
                let mut best = idx_min;
                let mut best_val = f32::MAX;
                let mut found = false;
                for i in idx_min..=idx_max {
                    let f = space.freq_of_index(i);
                    if self.is_range_occupied(f, min_dist_erb) {
                        continue;
                    }
                    if let Some(&v) = landscape.consonance01.get(i) {
                        let d = (v - 0.5).abs();
                        if d < best_val {
                            found = true;
                            best_val = d;
                            best = i;
                        }
                    }
                }
                if found { best } else { idx_min }
            }
            SpawnMethod::SpectralGap { .. } => {
                let weights: Vec<f32> = (idx_min..=idx_max)
                    .map(|i| {
                        let f = space.freq_of_index(i);
                        if self.is_range_occupied(f, min_dist_erb) {
                            return 0.0;
                        }
                        let amp = landscape
                            .subjective_intensity
                            .get(i)
                            .copied()
                            .unwrap_or(0.0)
                            .max(1e-6);
                        (1.0f32 / amp).max(0.0)
                    })
                    .collect();
                if let Ok(dist) = WeightedIndex::new(&weights) {
                    idx_min + dist.sample(rng)
                } else {
                    // Fallback to the quietest bin.
                    let mut best = idx_min;
                    let mut best_val = f32::MAX;
                    for i in idx_min..=idx_max {
                        let f = space.freq_of_index(i);
                        if self.is_range_occupied(f, min_dist_erb) {
                            continue;
                        }
                        if let Some(&v) = landscape.subjective_intensity.get(i)
                            && v < best_val
                        {
                            best_val = v;
                            best = i;
                        }
                    }
                    best
                }
            }
            SpawnMethod::HarmonicDensity { temperature, .. } => {
                let mut weights: Vec<f32> = (idx_min..=idx_max)
                    .enumerate()
                    .map(|(local_idx, i)| {
                        let f = space.freq_of_index(i);
                        let occupied = self.is_range_occupied(f, min_dist_erb);
                        let _ = local_idx;
                        let c01 = landscape.consonance01.get(i).copied().unwrap_or(0.0);
                        harmonic_density_weight(c01, occupied)
                    })
                    .collect();
                if let Some(temp) = temperature
                    && *temp > 0.0
                {
                    for w in &mut weights {
                        *w = w.powf(1.0 / temp);
                    }
                }
                if let Ok(dist) = WeightedIndex::new(&weights) {
                    idx_min + dist.sample(rng)
                } else {
                    // fallback to random log-uniform
                    let min_l = min_freq.log2();
                    let max_l = max_freq.log2();
                    if !min_l.is_finite() || !max_l.is_finite() || min_l >= max_l {
                        return min_freq.max(1e-6);
                    }
                    for _ in 0..32 {
                        let r = rng.random_range(min_l..max_l);
                        let f = 2.0f32.powf(r);
                        if !self.is_range_occupied(f, min_dist_erb) {
                            return f;
                        }
                    }
                    return 2.0f32.powf(rng.random_range(min_l..max_l));
                }
            }
            SpawnMethod::RandomLogUniform { .. } => {
                let min_l = min_freq.log2();
                let max_l = max_freq.log2();
                if !min_l.is_finite() || !max_l.is_finite() || min_l >= max_l {
                    return min_freq.max(1e-6);
                }
                for _ in 0..32 {
                    let r = rng.random_range(min_l..max_l);
                    let f = 2.0f32.powf(r);
                    if !self.is_range_occupied(f, min_dist_erb) {
                        return f;
                    }
                }
                return 2.0f32.powf(rng.random_range(min_l..max_l));
            }
        };

        jitter_free_bin(pick_idx, rng)
    }

    pub fn apply_action(
        &mut self,
        action: Action,
        landscape: &LandscapeFrame,
        _landscape_rt: Option<&mut crate::core::stream::roughness::RoughnessStream>,
    ) {
        match action {
            Action::Finish => {
                self.abort_requested = true;
            }
            Action::Spawn {
                tag,
                count,
                opts,
                patch,
            } => {
                let spawn_seq = self.spawn_counter;
                self.spawn_counter = self.spawn_counter.wrapping_add(1);
                let seed = self.spawn_seed(&tag, count, spawn_seq);
                let mut rng = SmallRng::seed_from_u64(seed);
                let mut patch = patch;
                strip_null_pitch_freq(&mut patch);
                let opts_method = opts.and_then(|opts| opts.method);
                let mut control = match AgentControl::from_json(merge_json(
                    AgentControl::default().to_json().unwrap_or_default(),
                    patch.clone(),
                )) {
                    Ok(control) => control,
                    Err(err) => {
                        warn!("Spawn: invalid patch for tag={}: {}", tag, err);
                        return;
                    }
                };
                let freq_in_patch = patch_sets_freq(&patch);
                if !freq_in_patch {
                    let method = opts_method.unwrap_or_default();
                    let freq = self.decide_frequency(&method, landscape, &mut rng);
                    control.pitch.freq = freq.max(1.0);
                }
                for i in 0..count {
                    let id = self.next_agent_id;
                    self.next_agent_id = self.next_agent_id.wrapping_add(1);
                    let metadata = AgentMetadata {
                        id,
                        tag: Some(tag.clone()),
                        group_idx: 0,
                        member_idx: i as usize,
                    };
                    let cfg = IndividualConfig {
                        control: control.clone(),
                        tag: Some(tag.clone()),
                    };
                    let spawned =
                        cfg.spawn(id, self.current_frame, metadata, self.time.fs, self.seed);
                    let body = spawned.body_snapshot();
                    let pitch_hz = spawned.body.base_freq_hz();
                    let amp = spawned.body.amp();
                    self.add_individual(spawned);
                    self.audio_cmds.push(AudioCommand::EnsureVoice {
                        id,
                        body,
                        pitch_hz,
                        amp,
                    });
                    self.audio_cmds.push(AudioCommand::Impulse {
                        id,
                        energy: self.birth_energy,
                    });
                }
            }
            Action::Set { target, patch } => {
                let ids = self.resolve_target_ids(&target);
                for id in ids {
                    if let Some(agent) = self.find_individual_mut(id) {
                        match agent.apply_control_patch(patch.clone()) {
                            Ok(()) => {}
                            Err(err) => {
                                warn!("Set: agent {id} rejected patch: {}", err);
                                continue;
                            }
                        }
                    } else {
                        warn!("Set: agent {id} not found");
                        continue;
                    }
                }
            }
            Action::Unset { target, path } => {
                let ids = self.resolve_target_ids(&target);
                for id in ids {
                    if let Some(agent) = self.find_individual_mut(id) {
                        match agent.apply_unset_path(&path) {
                            Ok(_removed) => {}
                            Err(err) => {
                                warn!("Unset: agent {id} rejected path {}: {}", path, err);
                                continue;
                            }
                        }
                    } else {
                        warn!("Unset: agent {id} not found");
                        continue;
                    }
                }
            }
            Action::Remove { target } => {
                let ids = self.resolve_target_ids(&target);
                for id in ids {
                    if let Some(agent) = self.find_individual_mut(id) {
                        agent.start_remove_fade(Self::REMOVE_FADE_SEC_DEFAULT);
                    } else {
                        warn!("Remove: agent {id} not found");
                    }
                }
            }
            Action::Release { target, fade_sec } => {
                let ids = self.resolve_target_ids(&target);
                let fade_sec = fade_sec.max(0.0);
                for id in ids {
                    if let Some(agent) = self.find_individual_mut(id) {
                        agent.start_remove_fade(fade_sec);
                    } else {
                        warn!("Release: agent {id} not found");
                    }
                }
            }
            Action::SetHarmonicity { update } => {
                self.merge_landscape_update(update);
            }
            Action::SetGlobalCoupling { value } => {
                self.global_coupling = value.max(0.0);
            }
            Action::SetRoughnessTolerance { value } => {
                let update = LandscapeUpdate {
                    roughness_k: Some(value),
                    ..LandscapeUpdate::default()
                };
                self.merge_landscape_update(update);
            }
            Action::PostIntent { .. } => {}
        }
    }

    fn merge_landscape_update(&mut self, update: LandscapeUpdate) {
        let mut merged = self.pending_update.unwrap_or_default();
        if update.mirror.is_some() {
            merged.mirror = update.mirror;
        }
        if update.limit.is_some() {
            merged.limit = update.limit;
        }
        if update.roughness_k.is_some() {
            merged.roughness_k = update.roughness_k;
        }
        self.pending_update = Some(merged);
    }

    pub fn take_pending_update(&mut self) -> Option<LandscapeUpdate> {
        self.pending_update.take()
    }

    /// Assumes `set_current_frame` has been called for the current hop.
    pub fn remove_agent(&mut self, id: u64) {
        let mut next = Vec::with_capacity(self.individuals.len());
        for agent in self.individuals.drain(..) {
            if agent.id() != id {
                next.push(agent);
            }
        }
        self.individuals = next;
    }

    /// Advance agent state without emitting audio (ScheduleRenderer is output authority).
    /// `samples_len` controls sub-stepping of control-rate updates within the block.
    pub fn advance(
        &mut self,
        samples_len: usize,
        _fs: f32,
        current_frame: u64,
        dt_sec: f32,
        landscape: &crate::core::landscape::Landscape,
    ) {
        self.current_frame = current_frame;
        if !dt_sec.is_finite() || dt_sec <= 0.0 {
            return;
        }
        // Sub-step updates to keep control-rate integration stable across hop sizes.
        let steps = (samples_len / Self::CONTROL_STEP_SAMPLES).max(1);
        let dt_step_sec = dt_sec / steps as f32;
        if !dt_step_sec.is_finite() || dt_step_sec <= 0.0 {
            return;
        }
        let mut rhythms = landscape.rhythm;
        for _ in 0..steps {
            for agent in self.individuals.iter_mut() {
                if agent.is_alive() {
                    agent.tick_control(dt_step_sec, &rhythms, landscape, self.global_coupling);
                }
            }
            rhythms.advance_in_place(dt_step_sec);
        }

        if self.abort_requested {
            let step = dt_sec / 0.05; // fade over ~50ms
            if step.is_finite() && step > 0.0 {
                self.shutdown_gain = (self.shutdown_gain - step).max(0.0);
            }
            if self.shutdown_gain <= 0.0 {
                self.individuals.clear();
            }
        }
    }

    /// Render spectral bodies on the provided log2 axis (explicit for external DSP handoff).
    pub fn process_frame(
        &mut self,
        current_frame: u64,
        space: &Log2Space,
        dt_sec: f32,
        scenario_finished: bool,
    ) -> &[f32] {
        self.current_frame = current_frame;
        self.buffers.amps.resize(space.n_bins(), 0.0);
        self.buffers.amps.fill(0.0);
        for agent in self.individuals.iter_mut() {
            if agent.is_alive() {
                agent.render_spectrum(&mut self.buffers.amps, space);
            }
        }
        let before_count = self.individuals.len();
        let mut next = Vec::with_capacity(self.individuals.len());
        for agent in self.individuals.drain(..) {
            if agent.should_retain() {
                next.push(agent);
            }
        }
        self.individuals = next;
        let removed_count = before_count - self.individuals.len();

        if removed_count > 0 {
            let t = current_frame as f32 * dt_sec;
            let prefix = if scenario_finished || self.abort_requested {
                "Event after scenario close: "
            } else {
                ""
            };
            if scenario_finished || self.abort_requested {
                warn!(
                    "{prefix}[t={:.6}] Cleaned up {} dead individuals. Remaining: {} (frame_idx={})",
                    t,
                    removed_count,
                    self.individuals.len(),
                    current_frame
                );
            } else {
                info!(
                    "{prefix}[t={:.6}] Cleaned up {} dead individuals. Remaining: {} (frame_idx={})",
                    t,
                    removed_count,
                    self.individuals.len(),
                    current_frame
                );
            }
        }
        &self.buffers.amps
    }
}

fn harmonic_density_weight(c01: f32, occupied: bool) -> f32 {
    if occupied {
        return 0.0;
    }
    let c = c01.clamp(0.0, 1.0);
    let eps = 1e-6f32;
    eps + (1.0 - eps) * c
}

fn build_social_trace_from_batches(
    phonation_batches: &[PhonationBatch],
    frame_end: Tick,
    hop_tick: Tick,
    bin_ticks: u32,
    smooth: f32,
    population_size: usize,
) -> SocialDensityTrace {
    let mut onset_ticks = Vec::new();
    for batch in phonation_batches {
        for onset in &batch.onsets {
            onset_ticks.push((onset.onset_tick.saturating_add(hop_tick), onset.strength));
        }
    }
    SocialDensityTrace::from_onsets(
        frame_end,
        frame_end.saturating_add(hop_tick),
        bin_ticks,
        smooth,
        population_size,
        &onset_ticks,
    )
}

fn social_trace_params(individuals: &[Individual], hop_tick: Tick) -> (u32, f32) {
    let base = individuals
        .iter()
        .find(|agent| agent.phonation_social.bin_ticks != 0 || agent.phonation_social.smooth != 0.0)
        .map(|agent| agent.phonation_social)
        .unwrap_or_default();
    if individuals.iter().any(|agent| {
        agent.phonation_social.bin_ticks != base.bin_ticks
            || agent.phonation_social.smooth != base.smooth
    }) {
        warn!("Population social trace params differ across agents; using first match settings");
    }
    let auto_bin = (hop_tick / 64).max(1);
    let bin_ticks = if base.bin_ticks == 0 {
        auto_bin.min(u32::MAX as Tick) as u32
    } else {
        base.bin_ticks
    };
    (bin_ticks, base.smooth)
}

fn social_trace_enabled_from_configs<I>(configs: I) -> bool
where
    I: IntoIterator<Item = SocialConfig>,
{
    configs.into_iter().any(|cfg| cfg.coupling != 0.0)
}

fn patch_sets_freq(patch: &serde_json::Value) -> bool {
    let serde_json::Value::Object(map) = patch else {
        return false;
    };
    let Some(serde_json::Value::Object(pitch)) = map.get("pitch") else {
        return false;
    };
    pitch.get("freq").and_then(|val| val.as_f64()).is_some()
}

fn strip_null_pitch_freq(patch: &mut serde_json::Value) {
    let serde_json::Value::Object(map) = patch else {
        return;
    };
    let Some(serde_json::Value::Object(pitch)) = map.get_mut("pitch") else {
        return;
    };
    if matches!(pitch.get("freq"), Some(serde_json::Value::Null)) {
        pitch.remove("freq");
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::landscape::Landscape;
    use crate::life::control::{BodyMethod, PhonationType};
    use crate::life::individual::{AnyArticulationCore, ArticulationWrapper, DroneCore};
    use crate::life::intent::BodySnapshot;
    use crate::life::phonation_engine::{OnsetEvent, PhonationCmd, PhonationKick};
    use crate::life::scenario::SocialConfig;
    use crate::life::world_model::WorldModel;
    use rand::SeedableRng;
    use serde_json::json;

    fn make_dummy_note_spec() -> crate::life::individual::PhonationNoteSpec {
        crate::life::individual::PhonationNoteSpec {
            note_id: 1,
            onset: 0,
            hold_ticks: None,
            freq_hz: 440.0,
            amp: 0.5,
            smoothing_tau_sec: 0.0,
            body: BodySnapshot {
                kind: "sine".to_string(),
                amp_scale: 1.0,
                brightness: 0.0,
                noise_mix: 0.0,
            },
            articulation: ArticulationWrapper::new(
                AnyArticulationCore::Drone(DroneCore {
                    phase: 0.0,
                    sway_rate: 1.0,
                }),
                1.0,
            ),
        }
    }

    #[test]
    fn decide_frequency_uses_consonance01() {
        let space = Log2Space::new(100.0, 400.0, 12);
        let mut landscape = LandscapeFrame::new(space.clone());
        landscape.consonance.fill(-10.0);
        landscape.consonance01.fill(0.0);

        let idx_high = space.index_of_freq(200.0).expect("idx");
        let idx_raw = space.index_of_freq(300.0).expect("idx");
        landscape.consonance01[idx_high] = 1.0;
        landscape.consonance[idx_raw] = 10.0;

        let pop = Population::new(Timebase {
            fs: 48_000.0,
            hop: 64,
        });
        let method = SpawnMethod::Harmonicity {
            min_freq: 100.0,
            max_freq: 400.0,
            min_dist_erb: Some(0.0),
        };
        let mut rng = rand::rngs::StdRng::seed_from_u64(7);
        let freq = pop.decide_frequency(&method, &landscape, &mut rng);
        let picked_idx = space.index_of_freq(freq).expect("picked idx");
        assert_eq!(picked_idx, idx_high);
    }

    #[test]
    fn harmonic_density_weight_eps_floor() {
        let w = harmonic_density_weight(0.0, false);
        assert!(w > 0.0);
    }

    #[test]
    fn harmonic_density_weight_occupied_is_zero() {
        let w = harmonic_density_weight(1.0, true);
        assert_eq!(w, 0.0);
    }

    #[test]
    fn harmonic_density_weighted_index_accepts_zero_c01() {
        let weights = vec![
            harmonic_density_weight(0.0, false),
            harmonic_density_weight(0.0, false),
        ];
        assert!(WeightedIndex::new(&weights).is_ok());
    }

    #[test]
    fn harmonic_density_weighted_index_fails_when_all_occupied() {
        let weights = vec![
            harmonic_density_weight(1.0, true),
            harmonic_density_weight(0.2, true),
        ];
        assert!(WeightedIndex::new(&weights).is_err());
    }

    #[test]
    fn social_trace_is_delayed_by_one_hop() {
        let batch = PhonationBatch {
            source_id: 1,
            cmds: Vec::new(),
            notes: Vec::new(),
            onsets: vec![OnsetEvent {
                gate: 0,
                onset_tick: 90,
                strength: 1.0,
            }],
        };
        let trace = build_social_trace_from_batches(&[batch], 100, 10, 5, 0.0, 1);
        assert_eq!(trace.start_tick, 100);
        assert_eq!(trace.density_at(95), 0.0);
        assert_eq!(trace.density_at(100), 1.0);
    }

    #[test]
    fn social_trace_enabled_with_nonzero_coupling() {
        let base = SocialConfig {
            coupling: 0.0,
            bin_ticks: 0,
            smooth: 0.0,
        };
        let other = SocialConfig {
            coupling: 1.0,
            bin_ticks: 0,
            smooth: 0.0,
        };
        let configs = vec![base, other];
        assert!(social_trace_enabled_from_configs(configs));
    }

    #[test]
    fn glob_matches_wildcards_and_escapes() {
        assert!(matches_tag_pattern("a*", "a1"));
        assert!(matches_tag_pattern("a*", "a2"));
        assert!(!matches_tag_pattern("a*", "b1"));
        assert!(matches_tag_pattern(r"a\*", "a*"));
        assert!(!matches_tag_pattern(r"a\*", "a1"));
        assert!(matches_tag_pattern("a?b", "acb"));
        assert!(!matches_tag_pattern("a?b", "ab"));
    }

    #[test]
    fn set_applies_to_matching_tags() {
        let mut pop = Population::new(Timebase {
            fs: 48_000.0,
            hop: 64,
        });
        let landscape = LandscapeFrame::default();
        for tag in ["lead_1", "lead_2", "bass_1"] {
            pop.apply_action(
                Action::Spawn {
                    tag: tag.to_string(),
                    count: 1,
                    opts: None,
                    patch: json!({}),
                },
                &landscape,
                None,
            );
        }
        pop.apply_action(
            Action::Set {
                target: "lead_*".to_string(),
                patch: json!({
                    "body": { "amp": 0.42 }
                }),
            },
            &landscape,
            None,
        );
        assert_eq!(pop.individuals.len(), 3);
        for agent in &pop.individuals {
            let tag = agent.metadata.tag.as_deref().unwrap_or_default();
            let amp = agent.effective_control.body.amp;
            if tag.starts_with("lead_") {
                assert!((amp - 0.42).abs() <= 1e-6, "tag {tag} should match");
            } else {
                assert!(
                    (amp - AgentControl::default().body.amp).abs() <= 1e-6,
                    "tag {tag} should not match"
                );
            }
        }
    }

    #[test]
    fn remove_applies_to_matching_tags() {
        let mut pop = Population::new(Timebase {
            fs: 48_000.0,
            hop: 64,
        });
        let landscape = LandscapeFrame::default();
        for tag in ["lead_1", "lead_2", "bass_1"] {
            pop.apply_action(
                Action::Spawn {
                    tag: tag.to_string(),
                    count: 1,
                    opts: None,
                    patch: json!({}),
                },
                &landscape,
                None,
            );
        }
        pop.apply_action(
            Action::Remove {
                target: "lead_?".to_string(),
            },
            &landscape,
            None,
        );
        let dt = 0.1;
        let samples_per_hop = (pop.time.fs * dt) as usize;
        let rt_landscape = Landscape::new(Log2Space::new(55.0, 4000.0, 64));
        pop.advance(samples_per_hop, pop.time.fs, 0, dt, &rt_landscape);
        pop.process_frame(0, &rt_landscape.space, dt, false);
        assert_eq!(pop.individuals.len(), 1);
        assert_eq!(pop.individuals[0].metadata.tag.as_deref(), Some("bass_1"));
    }

    #[test]
    fn unset_reverts_to_base_control() {
        let mut pop = Population::new(Timebase {
            fs: 48_000.0,
            hop: 64,
        });
        let landscape = LandscapeFrame::default();
        pop.apply_action(
            Action::Spawn {
                tag: "unset".to_string(),
                count: 1,
                opts: None,
                patch: json!({
                    "body": { "amp": 0.30 }
                }),
            },
            &landscape,
            None,
        );
        pop.apply_action(
            Action::Set {
                target: "unset".to_string(),
                patch: json!({
                    "body": { "amp": 0.80 }
                }),
            },
            &landscape,
            None,
        );
        pop.apply_action(
            Action::Unset {
                target: "unset".to_string(),
                path: "body.amp".to_string(),
            },
            &landscape,
            None,
        );
        let agent = pop.individuals.first().expect("agent exists");
        assert!((agent.effective_control.body.amp - 0.30).abs() <= 1e-6);
        pop.apply_action(
            Action::Unset {
                target: "unset".to_string(),
                path: "body.missing".to_string(),
            },
            &landscape,
            None,
        );
        let agent = pop.individuals.first().expect("agent exists");
        assert!((agent.effective_control.body.amp - 0.30).abs() <= 1e-6);
    }

    #[test]
    fn set_cannot_change_body_method() {
        let mut pop = Population::new(Timebase {
            fs: 48_000.0,
            hop: 64,
        });
        let landscape = LandscapeFrame::default();
        pop.apply_action(
            Action::Spawn {
                tag: "body_method".to_string(),
                count: 1,
                opts: None,
                patch: json!({
                    "body": { "method": "harmonic" }
                }),
            },
            &landscape,
            None,
        );
        pop.apply_action(
            Action::Set {
                target: "body_method".to_string(),
                patch: json!({
                    "body": { "method": "sine" }
                }),
            },
            &landscape,
            None,
        );
        let agent = pop.individuals.first().expect("agent exists");
        assert_eq!(agent.effective_control.body.method, BodyMethod::Harmonic);
    }

    #[test]
    fn set_cannot_change_phonation_type() {
        let mut pop = Population::new(Timebase {
            fs: 48_000.0,
            hop: 64,
        });
        let landscape = LandscapeFrame::default();
        pop.apply_action(
            Action::Spawn {
                tag: "phonation_type".to_string(),
                count: 1,
                opts: None,
                patch: json!({
                    "phonation": { "type": "interval" }
                }),
            },
            &landscape,
            None,
        );
        pop.apply_action(
            Action::Set {
                target: "phonation_type".to_string(),
                patch: json!({
                    "phonation": { "type": "hold" }
                }),
            },
            &landscape,
            None,
        );
        let agent = pop.individuals.first().expect("agent exists");
        assert_eq!(
            agent.effective_control.phonation.r#type,
            PhonationType::Interval
        );
    }

    #[test]
    fn publish_intents_into_clears_unused_batch() {
        let time = Timebase {
            fs: 48_000.0,
            hop: 64,
        };
        let space = Log2Space::new(55.0, 880.0, 12);
        let landscape = LandscapeFrame::new(space.clone());
        let mut world = WorldModel::new(time, space);
        let mut pop = Population::new(time);
        pop.apply_action(
            Action::Spawn {
                tag: "silent".to_string(),
                count: 1,
                opts: None,
                patch: serde_json::json!({
                    "pitch": { "freq": 440.0 },
                    "phonation": { "type": "none" }
                }),
            },
            &landscape,
            None,
        );

        let mut batches = vec![PhonationBatch {
            source_id: 99,
            cmds: vec![PhonationCmd::NoteOn {
                note_id: 1,
                kick: PhonationKick::Planned { strength: 1.0 },
            }],
            notes: vec![make_dummy_note_spec()],
            onsets: vec![OnsetEvent {
                gate: 0,
                onset_tick: 0,
                strength: 1.0,
            }],
        }];

        let used = pop.publish_intents_into(&mut world, &landscape, 0, &mut batches);
        assert_eq!(used, 0);
        assert!(batches[0].cmds.is_empty());
        assert!(batches[0].notes.is_empty());
        assert!(batches[0].onsets.is_empty());
    }
}
</file>

<file path="src/life/individual.rs">
use crate::core::landscape::Landscape;
use crate::core::log2space::Log2Space;
use crate::core::modulation::NeuralRhythms;
use crate::core::timebase::{Tick, Timebase};
use crate::life::control::{
    AgentControl, AgentPatch, BodyControl, BodyMethod, PerceptualControl, PhonationControl,
    PhonationType, PitchControl, merge_json, remove_json_path,
};
use crate::life::intent::BodySnapshot;
use crate::life::lifecycle::LifecycleConfig;
use crate::life::perceptual::PerceptualConfig;
use crate::life::phonation_engine::{
    CoreState, CoreTickCtx, NoteId, OnsetEvent, PhonationCmd, PhonationEngine, PhonationNoteEvent,
};
use crate::life::scenario::{
    ArticulationCoreConfig, HarmonicMode, PhonationClockConfig, PhonationConfig,
    PhonationConnectConfig, PhonationIntervalConfig, PhonationMode, PitchCoreConfig, SocialConfig,
    SoundBodyConfig, SubThetaModConfig, TimbreGenotype,
};
use crate::life::social_density::SocialDensityTrace;
use rand::SeedableRng;

#[path = "articulation_core.rs"]
pub mod articulation_core;
#[path = "pitch_controller.rs"]
pub mod pitch_controller;
#[path = "pitch_core.rs"]
pub mod pitch_core;
#[path = "sound_body.rs"]
pub mod sound_body;

pub use articulation_core::{
    AnyArticulationCore, ArticulationCore, ArticulationSignal, ArticulationState,
    ArticulationWrapper, DroneCore, KuramotoCore, PinkNoise, PlannedGate, PlannedPitch,
    Sensitivity, SequencedCore,
};
pub use pitch_controller::PitchController;
pub use pitch_core::{AnyPitchCore, PitchCore, PitchHillClimbPitchCore, TargetProposal};
pub use sound_body::{AnySoundBody, HarmonicBody, SineBody, SoundBody};

#[derive(Debug, Clone, Default)]
pub struct AgentMetadata {
    pub id: u64,
    pub tag: Option<String>,
    pub group_idx: usize,
    pub member_idx: usize,
}

#[derive(Debug)]
pub struct Individual {
    pub(crate) seed: u64,
    pub id: u64,
    pub metadata: AgentMetadata,
    pub base_control: AgentControl,
    pub override_json: serde_json::Value,
    pub effective_control: AgentControl,
    pub articulation: ArticulationWrapper,
    pub(crate) pitch_ctl: PitchController,
    pub phonation_engine: PhonationEngine,
    pub phonation_social: SocialConfig,
    pub body: AnySoundBody,
    pub last_signal: ArticulationSignal,
    pub(crate) release_gain: f32,
    pub(crate) release_sec: f32,
    pub(crate) release_pending: bool,
    pub(crate) remove_pending: bool,
    pub(crate) phonation_scratch: PhonationScratch,
}

#[derive(Clone, Debug)]
pub struct PhonationNoteSpec {
    pub note_id: NoteId,
    pub onset: Tick,
    pub hold_ticks: Option<Tick>,
    pub freq_hz: f32,
    pub amp: f32,
    pub smoothing_tau_sec: f32,
    pub body: BodySnapshot,
    pub articulation: ArticulationWrapper,
}

#[derive(Debug, Default)]
pub(crate) struct PhonationScratch {
    events: Vec<PhonationNoteEvent>,
}

#[derive(Clone, Debug, Default)]
pub struct PhonationBatch {
    pub source_id: u64,
    pub cmds: Vec<PhonationCmd>,
    pub notes: Vec<PhonationNoteSpec>,
    pub onsets: Vec<OnsetEvent>,
}

impl PhonationBatch {
    pub(crate) fn clear(&mut self) {
        self.cmds.clear();
        self.notes.clear();
        self.onsets.clear();
    }
}

#[derive(Clone, Copy, Debug)]
struct BodyRuntime {
    amp: f32,
    brightness: f32,
    inharmonic: f32,
    width: f32,
    motion: f32,
}

impl BodyRuntime {
    fn from_control(body: &BodyControl) -> Self {
        let timbre = &body.timbre;
        Self {
            amp: body.amp,
            brightness: timbre.brightness,
            inharmonic: timbre.inharmonic,
            width: timbre.width,
            motion: timbre.motion,
        }
    }
}

impl Individual {
    const AMP_EPS: f32 = 1e-6;

    pub fn spawn_from_control(
        control: AgentControl,
        assigned_id: u64,
        start_frame: u64,
        mut metadata: AgentMetadata,
        fs: f32,
        seed_offset: u64,
    ) -> Self {
        metadata.id = assigned_id;
        let seed = seed_offset ^ assigned_id ^ start_frame.wrapping_mul(0x9E37_79B9_7F4A_7C15);
        let mut rng = rand::rngs::SmallRng::seed_from_u64(seed);

        let effective_control = control.clone();
        let target_freq = effective_control.pitch.freq.max(1.0);
        let target_pitch_log2 = target_freq.log2();
        let integration_window = 2.0 + 10.0 / target_freq.max(1.0);

        let articulation_config = ArticulationCoreConfig::default();
        let core =
            AnyArticulationCore::from_config(&articulation_config, fs, assigned_id, &mut rng);

        let phonation_config = phonation_config_from_control(&effective_control.phonation);
        let phonation_engine = PhonationEngine::from_config(&phonation_config, seed);
        let phonation_social = phonation_config.social;

        let pitch_config = pitch_core_config_from_control(&effective_control.pitch);
        let pitch = AnyPitchCore::from_config(&pitch_config, target_pitch_log2, &mut rng);
        let perceptual_config = perceptual_config_from_control(&effective_control.perceptual);
        let perceptual =
            crate::life::perceptual::PerceptualContext::from_config(&perceptual_config, 0);

        let body_config = sound_body_config_from_control(&effective_control.body);
        let body = AnySoundBody::from_config(
            &body_config,
            target_freq,
            effective_control.body.amp,
            &mut rng,
        );

        let pitch_ctl = PitchController::new(
            pitch,
            perceptual,
            target_pitch_log2,
            integration_window,
            rng,
        );

        let (articulation_core, lifecycle_label, default_by_articulation, breath_gain_init) =
            match &articulation_config {
                ArticulationCoreConfig::Entrain {
                    lifecycle,
                    breath_gain_init,
                    ..
                } => {
                    let life_label = match lifecycle {
                        LifecycleConfig::Decay { .. } => "decay",
                        LifecycleConfig::Sustain { .. } => "sustain",
                    };
                    ("entrain", life_label, 1.0, *breath_gain_init)
                }
                ArticulationCoreConfig::Seq {
                    breath_gain_init, ..
                } => ("seq", "none", 1.0, *breath_gain_init),
                ArticulationCoreConfig::Drone {
                    breath_gain_init, ..
                } => ("drone", "none", 0.0, *breath_gain_init),
            };
        let breath_gain = breath_gain_init
            .unwrap_or(default_by_articulation)
            .clamp(0.0, 1.0);
        tracing::debug!(
            target: "rhythm::spawn",
            id = assigned_id,
            tag = ?metadata.tag,
            articulation = articulation_core,
            lifecycle = lifecycle_label,
            breath_gain_init,
            breath_gain
        );

        let mut agent = Individual {
            seed,
            id: assigned_id,
            metadata,
            base_control: control,
            override_json: serde_json::Value::Object(serde_json::Map::new()),
            effective_control,
            articulation: ArticulationWrapper::new(core, breath_gain),
            pitch_ctl,
            phonation_engine,
            phonation_social,
            body,
            last_signal: Default::default(),
            release_gain: 1.0,
            release_sec: 0.03,
            release_pending: false,
            remove_pending: false,
            phonation_scratch: Default::default(),
        };
        agent.apply_body_runtime();
        agent.apply_perceptual_control();
        agent.apply_pitch_control();
        agent
    }

    fn apply_body_runtime(&mut self) {
        let runtime = BodyRuntime::from_control(&self.effective_control.body);
        self.body.set_amp(runtime.amp);
        match &mut self.body {
            AnySoundBody::Sine(_body) => {}
            AnySoundBody::Harmonic(body) => {
                body.genotype.brightness = runtime.brightness;
                body.genotype.stiffness = runtime.inharmonic;
                body.genotype.unison = runtime.width;
                body.genotype.jitter = runtime.motion;
                body.genotype.vibrato_depth = runtime.motion * 0.02;
            }
        }
    }

    fn apply_perceptual_control(&mut self) {
        let params = perceptual_params_from_control(&self.effective_control.perceptual);
        let perceptual = self.pitch_ctl.perceptual_mut();
        perceptual.tau_fast = params.tau_fast;
        perceptual.tau_slow = params.tau_slow;
        perceptual.w_boredom = params.w_boredom;
        perceptual.w_familiarity = params.w_familiarity;
        perceptual.rho_self = params.rho_self;
        perceptual.boredom_gamma = params.boredom_gamma;
        perceptual.self_smoothing_radius = params.self_smoothing_radius;
        perceptual.silence_mass_epsilon = params.silence_mass_epsilon;
        self.pitch_ctl.set_perceptual_enabled(params.enabled);
    }

    fn apply_pitch_control(&mut self) {
        let pitch = &self.effective_control.pitch;
        let center_log2 = pitch.freq.max(1.0).log2();
        let gravity = tessitura_gravity_from_control(pitch.gravity);
        let core = self.pitch_ctl.core_mut();
        core.set_tessitura_center(center_log2);
        core.set_tessitura_gravity(gravity);
        core.set_exploration(pitch.exploration);
        core.set_persistence(pitch.persistence);
    }

    fn apply_phonation_control(&mut self) {
        let config = phonation_config_from_control(&self.effective_control.phonation);
        self.phonation_engine = PhonationEngine::from_config(&config, self.seed);
        self.phonation_social = config.social;
    }

    fn apply_effective_control(&mut self, control: AgentControl) {
        self.effective_control = control;
        self.apply_body_runtime();
        self.apply_perceptual_control();
        self.apply_pitch_control();
        self.apply_phonation_control();
    }

    pub fn should_retain(&self) -> bool {
        if self.remove_pending && self.release_gain <= 0.0 {
            return false;
        }
        if self.remove_pending {
            return self.is_alive();
        }
        self.is_alive() || self.phonation_engine.has_active_notes()
    }
    pub fn metadata(&self) -> &AgentMetadata {
        &self.metadata
    }

    pub fn id(&self) -> u64 {
        self.id
    }

    pub fn target_pitch_log2(&self) -> f32 {
        self.pitch_ctl.target_pitch_log2()
    }

    pub fn integration_window(&self) -> f32 {
        self.pitch_ctl.integration_window()
    }

    pub fn release_gain(&self) -> f32 {
        self.release_gain
    }

    pub fn apply_control_patch(&mut self, patch: serde_json::Value) -> Result<(), String> {
        let patch_struct: AgentPatch =
            serde_json::from_value(patch.clone()).map_err(|e| format!("parse AgentPatch: {e}"))?;
        if patch_struct.contains_type_switch() {
            return Err(
                "set() cannot change body.method or phonation.type; use spawn() for type selection"
                    .to_string(),
            );
        }
        let merged_override = merge_json(self.override_json.clone(), patch);
        let base_json = self.base_control.to_json()?;
        let effective_json = merge_json(base_json, merged_override.clone());
        let effective = AgentControl::from_json(effective_json)?;
        self.override_json = merged_override;
        self.apply_effective_control(effective);
        Ok(())
    }

    pub fn apply_unset_path(&mut self, path: &str) -> Result<bool, String> {
        let mut override_json = self.override_json.clone();
        let removed = remove_json_path(&mut override_json, path);
        if !removed {
            return Ok(false);
        }
        let base_json = self.base_control.to_json()?;
        let effective_json = merge_json(base_json, override_json.clone());
        let effective = AgentControl::from_json(effective_json)?;
        self.override_json = override_json;
        self.apply_effective_control(effective);
        Ok(true)
    }

    #[cfg(test)]
    pub(crate) fn set_accumulated_time_for_test(&mut self, value: f32) {
        self.pitch_ctl.set_accumulated_time_for_test(value);
    }

    #[cfg(test)]
    pub(crate) fn accumulated_time_for_test(&self) -> f32 {
        self.pitch_ctl.accumulated_time_for_test()
    }

    #[cfg(test)]
    pub(crate) fn set_theta_phase_state_for_test(&mut self, last_phase: f32, initialized: bool) {
        self.pitch_ctl
            .set_theta_phase_state_for_test(last_phase, initialized);
    }

    pub fn force_set_pitch_log2(&mut self, log_freq: f32) {
        let log_freq = log_freq.max(0.0);
        self.body.set_pitch_log2(log_freq);
        self.articulation.set_gate(1.0);
        self.pitch_ctl.force_set_target_pitch_log2(log_freq);
    }

    /// Update pitch targets at control rate (hop-sized steps).
    pub fn update_pitch_target(
        &mut self,
        rhythms: &NeuralRhythms,
        dt_sec: f32,
        landscape: &Landscape,
    ) {
        let current_freq = self.body.base_freq_hz();
        self.pitch_ctl.update_pitch_target(
            current_freq,
            rhythms,
            dt_sec,
            landscape,
            &self.effective_control.pitch,
        );
    }

    /// Control-rate entry point for pitch + articulation updates.
    pub fn tick_control(
        &mut self,
        dt_sec: f32,
        rhythms: &NeuralRhythms,
        landscape: &Landscape,
        global_coupling: f32,
    ) -> ArticulationSignal {
        self.apply_body_runtime();
        self.update_articulation(dt_sec, rhythms, landscape, global_coupling)
    }

    /// Update articulation at control rate (hop-sized steps).
    pub fn update_articulation(
        &mut self,
        dt_sec: f32,
        rhythms: &NeuralRhythms,
        landscape: &Landscape,
        global_coupling: f32,
    ) -> ArticulationSignal {
        self.update_pitch_target(rhythms, dt_sec, landscape);
        self.update_articulation_autonomous(dt_sec, rhythms);
        self.tick_articulation_lifecycle(dt_sec, rhythms, landscape, global_coupling)
    }

    pub fn update_articulation_autonomous(&mut self, dt_sec: f32, rhythms: &NeuralRhythms) {
        let current_freq = self.body.base_freq_hz().max(1.0);
        let current_pitch_log2 = current_freq.log2();
        let target_pitch_log2 = self.target_pitch_log2();
        let planned = PlannedPitch {
            target_pitch_log2,
            jump_cents_abs: 1200.0 * (target_pitch_log2 - current_pitch_log2).abs(),
            salience: self.pitch_ctl.last_target_salience(),
        };
        let apply_planned_pitch = self.articulation.update_gate(&planned, rhythms, dt_sec);
        if apply_planned_pitch {
            self.body.set_pitch_log2(planned.target_pitch_log2);
        }
    }

    pub fn tick_articulation_lifecycle(
        &mut self,
        dt_sec: f32,
        rhythms: &NeuralRhythms,
        landscape: &Landscape,
        global_coupling: f32,
    ) -> ArticulationSignal {
        let consonance = landscape.evaluate_pitch01(self.body.base_freq_hz());
        let mut signal = self
            .articulation
            .process(consonance, rhythms, dt_sec, global_coupling);
        signal.amplitude *= self.articulation.gate();
        if self.release_pending {
            let step = dt_sec / self.release_sec.max(1e-6);
            self.release_gain = (self.release_gain - step).max(0.0);
        }
        signal.amplitude *= self.release_gain;
        signal.is_active = signal.is_active && signal.amplitude > 0.0;
        self.last_signal = signal;
        signal
    }

    pub fn start_remove_fade(&mut self, fade_sec: f32) {
        if self.remove_pending {
            return;
        }
        self.remove_pending = true;
        self.release_pending = true;
        self.release_sec = fade_sec.max(1e-4);
        self.release_gain = self.release_gain.clamp(0.0, 1.0);
    }

    pub fn tick_phonation(
        &mut self,
        tb: &Timebase,
        now: Tick,
        rhythms: &NeuralRhythms,
        social: Option<&SocialDensityTrace>,
        social_coupling: f32,
    ) -> PhonationBatch {
        let mut batch = PhonationBatch::default();
        self.tick_phonation_into(tb, now, rhythms, social, social_coupling, &mut batch);
        batch
    }

    pub fn tick_phonation_into(
        &mut self,
        tb: &Timebase,
        now: Tick,
        rhythms: &NeuralRhythms,
        social: Option<&SocialDensityTrace>,
        social_coupling: f32,
        out: &mut PhonationBatch,
    ) {
        out.source_id = self.id;
        out.clear();
        self.phonation_scratch.events.clear();
        if matches!(self.effective_control.phonation.r#type, PhonationType::None) {
            return;
        }
        let hop_tick = (tb.hop as Tick).max(1);
        let frame_end = now.saturating_add(hop_tick);
        let ctx = CoreTickCtx {
            now_tick: now,
            frame_end,
            fs: tb.fs,
            rhythms: *rhythms,
        };
        let state = CoreState {
            is_alive: self.is_alive() && !self.remove_pending,
        };
        self.phonation_engine.tick(
            &ctx,
            &state,
            social,
            social_coupling,
            None,
            &mut out.cmds,
            &mut self.phonation_scratch.events,
            &mut out.onsets,
        );
        let had_note_on = out
            .cmds
            .iter()
            .any(|cmd| matches!(cmd, PhonationCmd::NoteOn { .. }));
        if self.phonation_scratch.events.is_empty() {
            debug_assert!(
                !had_note_on,
                "NoteOn emitted without note specs (no note events)"
            );
            return;
        }
        let amp = self.compute_target_amp();
        if amp <= Self::AMP_EPS {
            debug_assert!(
                !had_note_on,
                "NoteOn emitted but amp invalid => no note specs"
            );
            self.phonation_scratch.events.clear();
            return;
        }
        let freq_hz = self.body.base_freq_hz();
        if !freq_hz.is_finite() || freq_hz <= 0.0 {
            debug_assert!(
                !had_note_on,
                "NoteOn emitted but freq invalid => no note specs"
            );
            self.phonation_scratch.events.clear();
            return;
        }
        let articulation = self.articulation_snapshot_for_render();
        let body = self.body_snapshot();
        let smoothing_tau_sec = 0.0;
        for event in self.phonation_scratch.events.drain(..) {
            out.notes.push(PhonationNoteSpec {
                note_id: event.note_id,
                onset: event.onset_tick,
                hold_ticks: None,
                freq_hz,
                amp,
                smoothing_tau_sec,
                body: body.clone(),
                articulation: articulation.clone(),
            });
        }
        debug_assert!(
            !had_note_on || !out.notes.is_empty(),
            "NoteOn emitted without note specs"
        );
    }

    pub(crate) fn compute_target_amp(&self) -> f32 {
        let release_gain = self.release_gain.clamp(0.0, 1.0);
        // Include articulation gate in the final target amp.
        let gate = self.articulation.gate().clamp(0.0, 1.0);
        let mut amp = self.body.amp() * release_gain * gate;
        if !amp.is_finite() {
            amp = 0.0;
        }
        amp.max(0.0)
    }

    /// Gate is baked into amp, so render-side gate is fixed to 1.0 while other articulation state is preserved.
    fn articulation_snapshot_for_render(&self) -> ArticulationWrapper {
        let mut articulation = self.articulation.clone();
        // Normalize render gate to avoid double-applying the gate.
        articulation.set_gate(1.0);
        articulation
    }

    pub(crate) fn body_snapshot(&self) -> BodySnapshot {
        match &self.body {
            AnySoundBody::Sine(_body) => BodySnapshot {
                kind: "sine".to_string(),
                // Target amp already includes body gain; keep snapshot scale neutral.
                amp_scale: 1.0,
                brightness: 0.0,
                noise_mix: 0.0,
            },
            AnySoundBody::Harmonic(body) => BodySnapshot {
                kind: "harmonic".to_string(),
                // Target amp already includes body gain; keep snapshot scale neutral.
                amp_scale: 1.0,
                brightness: body.genotype.brightness.clamp(0.0, 1.0),
                noise_mix: body.genotype.jitter.clamp(0.0, 1.0),
            },
        }
    }

    pub fn render_spectrum(&mut self, amps: &mut [f32], space: &Log2Space) {
        let signal = self.last_signal;
        if !signal.is_active || signal.amplitude <= 0.0 {
            return;
        }
        self.body.project_spectral_body(amps, space, &signal);
    }

    pub fn is_alive(&self) -> bool {
        if self.remove_pending && self.release_gain <= 0.0 {
            return false;
        }
        self.articulation.is_alive() && self.release_gain > 0.0
    }
}

#[derive(Clone, Copy, Debug)]
struct PerceptualParams {
    enabled: bool,
    tau_fast: f32,
    tau_slow: f32,
    w_boredom: f32,
    w_familiarity: f32,
    rho_self: f32,
    boredom_gamma: f32,
    self_smoothing_radius: usize,
    silence_mass_epsilon: f32,
}

fn perceptual_params_from_control(control: &PerceptualControl) -> PerceptualParams {
    let adaptation = control.adaptation.clamp(0.0, 1.0);
    let tau_fast = 0.1 + (1.0 - adaptation) * 0.8;
    let tau_slow = 5.0 + (1.0 - adaptation) * 30.0;
    let (w_boredom, w_familiarity, rho_self) = if control.enabled {
        (
            control.novelty_bias,
            0.2,
            control.self_focus.clamp(0.0, 1.0),
        )
    } else {
        (0.0, 0.0, 0.0)
    };
    PerceptualParams {
        enabled: control.enabled,
        tau_fast,
        tau_slow,
        w_boredom,
        w_familiarity,
        rho_self,
        boredom_gamma: 0.5,
        self_smoothing_radius: 1,
        silence_mass_epsilon: 1e-6,
    }
}

fn tessitura_gravity_from_control(gravity: f32) -> f32 {
    gravity.clamp(0.0, 1.0) * 0.2
}

fn pitch_core_config_from_control(pitch: &PitchControl) -> PitchCoreConfig {
    PitchCoreConfig::PitchHillClimb {
        neighbor_step_cents: None,
        tessitura_gravity: Some(tessitura_gravity_from_control(pitch.gravity)),
        improvement_threshold: None,
        exploration: Some(pitch.exploration),
        persistence: Some(pitch.persistence),
    }
}

fn perceptual_config_from_control(control: &PerceptualControl) -> PerceptualConfig {
    let params = perceptual_params_from_control(control);
    PerceptualConfig {
        tau_fast: Some(params.tau_fast),
        tau_slow: Some(params.tau_slow),
        w_boredom: Some(params.w_boredom),
        w_familiarity: Some(params.w_familiarity),
        rho_self: Some(params.rho_self),
        boredom_gamma: Some(params.boredom_gamma),
        self_smoothing_radius: Some(params.self_smoothing_radius),
        silence_mass_epsilon: Some(params.silence_mass_epsilon),
    }
}

fn sound_body_config_from_control(body: &BodyControl) -> SoundBodyConfig {
    match body.method {
        BodyMethod::Sine => SoundBodyConfig::Sine { phase: None },
        BodyMethod::Harmonic => {
            let timbre = &body.timbre;
            let genotype = TimbreGenotype {
                mode: HarmonicMode::Harmonic,
                stiffness: timbre.inharmonic,
                brightness: timbre.brightness,
                comb: 0.0,
                damping: 0.5,
                vibrato_rate: 5.0,
                vibrato_depth: timbre.motion * 0.02,
                jitter: timbre.motion,
                unison: timbre.width,
            };
            SoundBodyConfig::Harmonic {
                genotype,
                partials: None,
            }
        }
    }
}

fn phonation_config_from_control(control: &PhonationControl) -> PhonationConfig {
    // Hold ignores density/sync/legato; it is purely lifecycle-driven.
    if matches!(control.r#type, PhonationType::Hold) {
        let social = SocialConfig {
            coupling: control.sociality.clamp(0.0, 1.0),
            bin_ticks: 0,
            smooth: 0.0,
        };
        return PhonationConfig {
            mode: PhonationMode::Hold,
            interval: PhonationIntervalConfig::None,
            connect: PhonationConnectConfig::FixedGate { length_gates: 1 },
            clock: PhonationClockConfig::ThetaGate,
            sub_theta_mod: SubThetaModConfig::None,
            social,
        };
    }
    let density = control.density.clamp(0.0, 1.0);
    let rate = 0.5 + density * 3.5;
    let interval = match control.r#type {
        PhonationType::None => PhonationIntervalConfig::None,
        _ => PhonationIntervalConfig::Accumulator {
            rate,
            refractory: 1,
        },
    };
    let legato = control.legato.clamp(0.0, 1.0);
    let length_gates = (1.0 + legato * 8.0).round().max(1.0) as u32;
    let connect = match control.r#type {
        PhonationType::Field => PhonationConnectConfig::Field {
            hold_min_theta: 0.1 + legato * 0.2,
            hold_max_theta: 0.6 + legato * 0.4,
            curve_k: 2.0,
            curve_x0: 0.5,
            drop_gain: (1.0 - legato).clamp(0.0, 1.0),
        },
        _ => PhonationConnectConfig::FixedGate { length_gates },
    };
    let sub_theta_mod = if control.sync > 0.0 {
        SubThetaModConfig::Cosine {
            n: 1,
            depth: control.sync.clamp(0.0, 1.0),
            phase0: 0.0,
        }
    } else {
        SubThetaModConfig::None
    };
    let social = SocialConfig {
        coupling: control.sociality.clamp(0.0, 1.0),
        bin_ticks: 0,
        smooth: 0.0,
    };
    PhonationConfig {
        mode: PhonationMode::Gated,
        interval,
        connect,
        clock: PhonationClockConfig::ThetaGate,
        sub_theta_mod,
        social,
    }
}
</file>

</files>
