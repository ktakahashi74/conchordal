This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  audio/
    buffer.rs
    mod.rs
    output.rs
    writer.rs
  core/
    erb.rs
    fft.rs
    harmonicity_kernel_templatematch.rs
    harmonicity_kernel.rs
    landscape.rs
    log2space.rs
    nsgt_fft.rs
    nsgt_kernel.rs
    nsgt_rt.rs
    nsgt.rs
    roughness_kernel.rs
    utils.rs
  life/
    individual.rs
    meta.rs
    mod.rs
    population.rs
  synth/
    engine.rs
    mod.rs
  ui/
    mod.rs
    plots.rs
    viewdata.rs
    windows.rs
  app.rs
  config.rs
  core.rs
  main.rs
.gitignore
a.tar
AGENTS.md
Cargo.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/audio/buffer.rs">
// Generic audio buffer type to support mono/stereo interleaved data
#[derive(Clone, Debug)]
pub struct AudioBuffer {
    pub channels: usize,
    pub samples: Vec<f32>,
}

impl AudioBuffer {
    pub fn mono(samples: Vec<f32>) -> Self {
        Self { channels: 1, samples }
    }

    pub fn stereo(left: Vec<f32>, right: Vec<f32>) -> Self {
        assert_eq!(left.len(), right.len());
        let mut interleaved = Vec::with_capacity(left.len() * 2);
        for (l, r) in left.into_iter().zip(right.into_iter()) {
            interleaved.push(l);
            interleaved.push(r);
        }
        Self { channels: 2, samples: interleaved }
    }
}
</file>

<file path="src/audio/mod.rs">
pub mod output;
pub mod buffer;
pub mod writer;
</file>

<file path="src/audio/output.rs">
use cpal::traits::{DeviceTrait, HostTrait, StreamTrait};

use ringbuf::{HeapRb, HeapProd, HeapCons};
use ringbuf::traits::*;



/// 出力デバイスに接続するモジュール
pub struct AudioOutput {
    stream: Option<cpal::Stream>,
    capacity: usize,
    pub config: cpal::StreamConfig,
}

impl AudioOutput {
    /// AudioOutput を開始し、ワーカーループ側が push できる Producer を返す
    pub fn new(latency_ms: f32) -> (Self, HeapProd<f32>) {
        let host = cpal::default_host();
        let device = host
            .default_output_device()
            .expect("No output device");
	
        let supported_config = device.default_output_config().expect("No default config");
        let sample_rate = supported_config.sample_rate().0;
        let channels = supported_config.channels();

	let config = cpal::StreamConfig {
            channels,
            sample_rate: cpal::SampleRate(sample_rate),
            buffer_size: cpal::BufferSize::Default,
        };

        let capacity = (sample_rate as f32 * latency_ms / 1000.0) as usize;
        let rb = HeapRb::<f32>::new(capacity * channels as usize * 10);
        let (prod, mut cons): (HeapProd<f32>, HeapCons<f32>) = rb.split();

        let stream = device
            .build_output_stream(
                &config,
                move |data: &mut [f32], _: &cpal::OutputCallbackInfo| {
		    eprintln!("CPAL callback: requested {} samples", data.len());

		    let mut frames_filled = 0;
		    let n_frames = data.len() / channels as usize;
		    
		    for frame in 0..n_frames {
			// 1フレーム分のサンプル値を取り出す
			let s = cons.try_pop().unwrap_or(0.0);
			
			// モノラル: 全チャンネルに同じ値を複製
			for ch in 0..channels {
			    data[frame * channels as usize + ch as usize] = s;
			}
			
			frames_filled += 1;
		    }
		},

                |err| eprintln!("Stream error: {:?}", err),
                None,
            )
            .unwrap();
        stream.play().unwrap();

        (
            Self {
                stream: Some(stream),
		capacity,
		config
            },
            prod,
        )
    }

    pub fn stop(&mut self) {
	self.stream.take(); // take and Drop
    }
    
    /// ワーカーループが新しいサンプルを push
    pub fn push_samples(prod: &mut HeapProd<f32>, samples: &[f32]) {
	let mut offset = 0;
        while offset < samples.len() {
            let written = prod.push_slice(&samples[offset..]);
            offset += written;

            if offset < samples.len() {
                std::thread::sleep(std::time::Duration::from_micros(200));
            }
        }
    }

    // pub fn buffered_samples(&self) -> usize {
    //     self._rb.occupied_len()
    // }

    // pub fn capacity(&self) -> usize {
    //     self._rb.capacity().get()
    // }
    
}


impl Drop for  AudioOutput {
    fn drop(&mut self) {
	if self.stream.is_some() {
	    eprintln!("AudioOutput drop: stopping CPAL stream.");
	}
	self.stream.take();
    }
}
</file>

<file path="src/audio/writer.rs">
use crossbeam_channel::Receiver;
use hound::{WavWriter, WavSpec, SampleFormat};

pub struct WavOutput {
    // Writer is kept alive in the thread
}

impl WavOutput {
    pub fn run(rx: Receiver<Vec<f32>>, path: String, sample_rate: u32) -> std::thread::JoinHandle<()>{
        std::thread::spawn(move || {
            let spec = WavSpec {
                channels: 1,
                sample_rate,
                bits_per_sample: 16,
                sample_format: SampleFormat::Int,
            };
            let mut writer = WavWriter::create(path, spec).expect("create wav");

            while let Ok(samples) = rx.recv() {
                for s in samples {
                    let v = (s.clamp(-1.0, 1.0) * i16::MAX as f32) as i16;
                    writer.write_sample(v).unwrap();
                }
            }

            writer.finalize().unwrap();
        })
    }
}
</file>

<file path="src/core/log2space.rs">
//! core/log2.rs — Log2 frequency space (octave-based).
//!
//! Provides uniform log2(Hz) mapping used by NSGT and kernel convolution.
//! Example: 27.5 Hz → log2(27.5)=4.78, 55 Hz→5.78 (1 octave up).

use std::f32::consts::LOG2_10;

/// Uniform log2(Hz) frequency space.
#[derive(Clone, Debug)]
pub struct Log2Space {
    pub fmin: f32,
    pub fmax: f32,
    pub bins_per_oct: u32,
    pub centers_hz: Vec<f32>,
    pub centers_log2: Vec<f32>,
    pub step_log2: f32,
}

impl Log2Space {
    /// Create a log2-space grid between fmin..fmax (inclusive).
    pub fn new(fmin: f32, fmax: f32, bins_per_oct: u32) -> Self {
        assert!(fmin > 0.0 && fmax > fmin);
        assert!(bins_per_oct > 0);

        let lo = fmin.log2();
        let hi = fmax.log2();
        let step_log2 = 1.0 / bins_per_oct as f32;
        let n_bins = ((hi - lo) / step_log2).floor() as usize + 1;

        let centers_log2: Vec<f32> = (0..n_bins).map(|i| lo + i as f32 * step_log2).collect();
        let centers_hz: Vec<f32> = centers_log2.iter().map(|&x| 2f32.powf(x)).collect();

        Self {
            fmin,
            fmax,
            bins_per_oct,
            centers_hz,
            centers_log2,
            step_log2,
        }
    }

    /// Number of bins.
    #[inline]
    pub fn n_bins(&self) -> usize {
        self.centers_hz.len()
    }

    /// Convert Hz → log2(Hz)
    #[inline]
    pub fn hz_to_log2(&self, hz: f32) -> f32 {
        hz.log2()
    }

    /// Convert log2(Hz) → Hz
    #[inline]
    pub fn log2_to_hz(&self, l: f32) -> f32 {
        2f32.powf(l)
    }

    /// Return Δlog2 per bin (1/bins_per_oct).
    #[inline]
    pub fn step(&self) -> f32 {
        self.step_log2
    }

    /// Find nearest bin index for given frequency.
    pub fn index_of_freq(&self, hz: f32) -> Option<usize> {
        if hz < self.fmin || hz > self.fmax {
            return None;
        }
        let l = hz.log2();
        let idx = ((l - self.centers_log2[0]) / self.step_log2).round() as usize;
        self.centers_hz.get(idx)?;
        Some(idx)
    }

    pub fn freq_of_index(&self, i: usize) -> f32 {
        self.centers_hz[i]
    }

    /// Approximate linear bandwidth (Hz) of a log2-space bin.
    ///
    /// - Constant-Q spacing: Δlog2 = 1 / bins_per_oct.
    /// - Formula: Δf = f * (2^(Δlog2/2) − 2^(−Δlog2/2)).
    /// - Q = f / Δf = 1 / (2^(Δlog2/2) − 2^(−Δlog2/2)).
    ///
    /// Use `bandwidth_hz_at(i)` for bin index, or this for arbitrary frequency.
    #[inline]
    pub fn bandwidth_hz(&self, f_hz: f32) -> f32 {
        let half_step = 0.5 * self.step_log2;
        let delta = 2f32.powf(half_step) - 2f32.powf(-half_step);
        (f_hz * delta).max(1e-6)
    }

    /// Bandwidth (Hz) of the i-th bin center.
    #[inline]
    pub fn bandwidth_hz_at(&self, i: usize) -> f32 {
        if let Some(&f_hz) = self.centers_hz.get(i) {
            self.bandwidth_hz(f_hz)
        } else {
            0.0
        }
    }

    /// Return Δlog2 between two frequencies.
    #[inline]
    pub fn delta_log2(&self, f1: f32, f2: f32) -> f32 {
        f2.log2() - f1.log2()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_log2space_basic() {
        let s = Log2Space::new(27.5, 880.0, 12);
        assert!(s.n_bins() > 0);
        assert!(s.centers_hz[0] >= 27.5);
        assert!(s.centers_hz.last().unwrap() <= &880.1);
        let idx = s.index_of_freq(55.0).unwrap();
        let ratio = s.centers_hz[idx] / s.centers_hz[0];
        // One octave ≈ factor 2
        assert!(ratio > 1.9 && ratio < 2.1);
    }

    #[test]
    fn test_bandwidth_constant_q_relation() {
        let space = Log2Space::new(100.0, 6400.0, 24);
        let q_target = 1.0 / (2f32.powf(1.0 / (24.0 * 2.0)) - 2f32.powf(-1.0 / (24.0 * 2.0)));
        for &f in &[100.0, 400.0, 1600.0, 6400.0] {
            let bw = space.bandwidth_hz(f);
            let q = f / bw;
            assert!(
                (q / q_target - 1.0).abs() < 1e-5,
                "Q mismatch: got {q}, want {q_target}"
            );
        }
    }

    #[test]
    fn test_bandwidth_hz_at_matches_bandwidth_hz() {
        let space = Log2Space::new(100.0, 6400.0, 24);
        for i in [0, space.n_bins() / 2, space.n_bins() - 1] {
            let bw_f = space.bandwidth_hz(space.centers_hz[i]);
            let bw_i = space.bandwidth_hz_at(i);
            assert!((bw_f - bw_i).abs() / bw_f < 1e-6, "Mismatch at bin {i}");
        }
    }

    #[test]
    fn test_bandwidth_scales_linearly_with_frequency() {
        let space = Log2Space::new(100.0, 6400.0, 12);
        let bw1 = space.bandwidth_hz(100.0);
        let bw2 = space.bandwidth_hz(200.0);
        let bw4 = space.bandwidth_hz(400.0);
        let ratio12 = bw2 / bw1;
        let ratio24 = bw4 / bw2;
        assert!((ratio12 - 2.0).abs() < 0.05);
        assert!((ratio24 - 2.0).abs() < 0.05);
    }
}
</file>

<file path="src/core/utils.rs">
use rand::{Rng, SeedableRng};

// --- noise generators ---
pub fn white_noise(n: usize, seed: u64) -> Vec<f32> {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    (0..n).map(|_| rng.random_range(-1.0..1.0)).collect()
}

/// Pink noise via simple 3-pole filter approximation (Voss–McCartney not required)
pub fn pink_noise(n: usize, seed: u64) -> Vec<f32> {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let mut b0 = 0.0f32;
    let mut b1 = 0.0f32;
    let mut b2 = 0.0f32;
    let mut out = Vec::with_capacity(n);
    for _ in 0..n {
        let white = rng.random_range(-1.0..1.0);
        // Paul Kellet 3-pole filter (approx −3 dB/oct)
        b0 = 0.99765 * b0 + white * 0.0990460;
        b1 = 0.96300 * b1 + white * 0.2965164;
        b2 = 0.57000 * b2 + white * 1.0526913;
        let pink = b0 + b1 + b2 + white * 0.1848;
        out.push((pink * 0.03) as f32); // normalize
    }
    out
}

/// Brown (red) noise via single-pole low-pass filter (−6 dB/oct)
pub fn brown_noise(n: usize, seed: u64) -> Vec<f32> {
    let mut rng = rand::rngs::StdRng::seed_from_u64(seed);
    let mut y = 0.0f32;
    let mut out = Vec::with_capacity(n);

    // Simple 1-pole IIR with pole near DC
    // y[n] = a*y[n-1] + (1 - a)*x[n]
    // choose a close to 1.0 to get strong low-frequency emphasis
    let a = 0.995; // ≈ −6 dB/oct

    for _ in 0..n {
        let white = rng.random_range(-1.0..1.0);
        y = a * y + (1.0 - a) * white;
        out.push(y);
    }
    out
}
</file>

<file path="src/life/individual.rs">
#[derive(Clone, Debug)]
pub struct PureTone {
    pub freq_hz: f32,
    pub amp: f32,
}

impl PureTone {
    pub fn new(freq_hz: f32, amp: f32) -> Self {
        Self { freq_hz, amp }
    }
}
</file>

<file path="src/life/meta.rs">
// Placeholder for environment meta-parameters
#[derive(Clone, Debug, Default)]
pub struct MetaParams {
    pub temperature: f32,
    pub energy: f32,
}
</file>

<file path="src/life/mod.rs">
pub mod individual;
pub mod meta;
pub mod population;
</file>

<file path="src/life/population.rs">
use super::individual::PureTone;

#[derive(Clone, Debug)]
pub struct PopulationParams {
    pub initial_tones_hz: Vec<f32>,
    pub amplitude: f32,
}

#[derive(Clone, Debug)]
pub struct Population {
    pub tones: Vec<PureTone>,
}

impl Population {
    pub fn new(p: PopulationParams) -> Self {
        let tones = p
            .initial_tones_hz
            .into_iter()
            .map(|f| PureTone::new(f, p.amplitude))
            .collect();
        Self { tones }
    }

    /// Project tones to magnitude spectrum bins using simple triangular (soft) binning.
    pub fn project_spectrum(&self, n_bins: usize, fs: f32, n_fft: usize) -> Vec<f32> {
        let mut amps = vec![0.0f32; n_bins];

	for t in &self.tones {
            let bin_f = t.freq_hz * n_fft as f32 / fs;
            let k = bin_f.round() as isize;
            if k >= 0 && (k as usize) < n_bins {
		amps[k as usize] += t.amp;
            }
	}
	amps
    }
}
</file>

<file path="src/synth/mod.rs">
pub mod engine;
</file>

<file path="src/ui/mod.rs">
pub mod windows;
pub mod plots;
pub mod viewdata;
</file>

<file path="src/config.rs">
// Placeholder for future configuration loading (serde/ron).
#[derive(Debug, Clone, serde::Deserialize, serde::Serialize, Default)]
pub struct Config {}
</file>

<file path="AGENTS.md">
# Repository Guidelines

## Project Structure & Module Organization
- Source lives in `src/` with focused modules:
  - `core/` (DSP primitives: `fft.rs`, `gammatone.rs`, `erb.rs`, `hilbert.rs`, `roughness.rs`, `landscape.rs`, `util.rs`)
  - `audio/` (I/O: `buffer.rs`, `output.rs`, `writer.rs`)
  - `synth/` (synthesis engine)
  - `ui/` (views, plots, windows)
  - `life/` (evolutionary components: `individual.rs`, `population.rs`, `meta.rs`)
- Entrypoints: `src/main.rs` (binary) and `src/app.rs` (app wiring). Config lives in `src/config.rs`.
- Sample assets like `a.wav` are acceptable for dev; prefer an `assets/` folder for larger or generated files.

## Build, Test, and Development Commands
- Build (debug): `cargo build` — compiles the crate and dependencies.
- Run (debug): `cargo run` — runs the main binary.
- Run (optimized): `cargo run --release` — useful for audio/DSP perf.
- Tests: `cargo test` — runs unit/integration tests.
- Format: `cargo fmt --all` — applies `rustfmt`.
- Lint: `cargo clippy -- -D warnings` — lints and fails on warnings.

## Coding Style & Naming Conventions
- Indentation: 4 spaces; rely on `rustfmt` with default settings.
- Naming: `snake_case` for functions/modules, `CamelCase` for types/traits, `SCREAMING_SNAKE_CASE` for consts.
- Files: one module per file where practical; keep public APIs minimal (`pub(crate)` when possible).
- Audio/DSP code: prefer `f32`, avoid allocations in real‑time paths; document units and ranges.

## Testing Guidelines
- Unit tests colocated via `#[cfg(test)] mod tests { ... }` in each module.
- Integration tests (if added) live under `tests/` and use `*_tests.rs` naming.
- Favor deterministic fixtures for DSP (seeded data) and assert spectral/temporal properties.
- Run `cargo test` before PRs; keep tests fast (<1s per module when possible).

## Commit & Pull Request Guidelines
- Commits: imperative mood, concise subject (≤72 chars), optional body. Prefix with scope when helpful (e.g., `core:`, `audio:`, `ui:`).
- PRs: clear description, rationale, before/after notes; link issues; include screenshots for UI/plot changes and short audio notes for synthesis changes.
- CI hygiene: ensure `cargo fmt`, `clippy`, and `test` pass locally.

## Security & Configuration Tips
- Centralize tunables in `src/config.rs`. Do not commit secrets or large generated audio; ignore via `.gitignore`.
- Prefer environment variables (`std::env`) or config files for local overrides.
</file>

<file path="src/core/harmonicity_kernel_templatematch.rs">
//! core/harmonicity_kernel.rs
//! Multi-octave harmonicity kernel on Log2Space.
//!
//! - Build a stationary kernel K(Δlog2) over ±L octaves from integer ratios.
//! - Weights favor small integers and decay with octave distance.
//! - Per-frame result is linear convolution (FFT) on the full log2 axis.
//! - Optional post gate for absolute-frequency physiology (phase locking, ERB).

use crate::core::erb::erb_bw_hz;
use crate::core::fft::linear_convolve_fft;
use crate::core::log2space::Log2Space;

#[inline]
fn log2f(x: f32) -> f32 {
    x.log2()
}

#[inline]
fn gcd_u32(mut a: u32, mut b: u32) -> u32 {
    while b != 0 {
        let r = a % b;
        a = b;
        b = r;
    }
    a
}

/// Parameters for the multi-octave kernel.
#[derive(Clone, Copy, Debug)]
pub struct HarmonicityParams {
    /// Base Gaussian width per ratio [cents].
    pub sigma_cents: f32,
    /// Weight ~ (m+n)^(-gamma).
    pub gamma_ratio: f32,
    /// Normalize kernel to max=1.
    pub normalize_kernel: bool,
    /// Max numerator for ratio set.
    pub max_num: u32,
    /// Max denominator for ratio set.
    pub max_den: u32,
    /// Optional (m+n) limit.
    pub max_complexity: Option<u32>,
    /// Weight for 1/1 (0..1)
    pub identity_weight: f32,

    /// Kernel half span in octaves (support is [-span, +span]).
    pub span_octaves: f32,
    /// Exponential decay by octave distance: exp(-alpha*|μ|).
    pub alpha_oct_decay: f32,
    /// Extra weight for harmonic side (m>=n): m^-p_harm.
    pub p_harm: f32,
    /// Extra weight for subharmonic side (n>m): n^-q_sub.
    pub q_sub: f32,
    /// Broadening by order: σ = σ0 * sqrt(1 + max(m,n)/k0).
    pub k0_for_sigma: u32,
    /// If false, drop subharmonics (n>m).
    pub allow_subharmonics: bool,

    /// Apply abs-frequency gating
    pub freq_gate: bool,
    /// Phase-locking roll-off pivot [Hz].
    pub tfs_f_pl_hz: f32,
    /// Phase-locking roll-off steepness.
    pub tfs_eta: f32,
    ///// ERB gate exponent; gain *= (1/ERB(f))^rho.
    //pub erb_rho: f32,
}

impl Default for HarmonicityParams {
    fn default() -> Self {
        Self {
            sigma_cents: 7.0,
            gamma_ratio: 0.9,
            normalize_kernel: true,
            max_num: 16,
            max_den: 16,
            max_complexity: Some(15),
            identity_weight: 0.5,

            span_octaves: 5.0,
            alpha_oct_decay: 0.35,
            p_harm: 0.5,
            q_sub: 1.0,
            k0_for_sigma: 4,
            allow_subharmonics: true,

            freq_gate: false,
            tfs_f_pl_hz: 4500.0,
            tfs_eta: 4.0,
        }
    }
}

/// Multi-octave integer-ratio kernel for harmonicity.
#[derive(Clone, Debug)]
pub struct HarmonicityKernel {
    pub bins_per_oct: u32,
    pub params: HarmonicityParams,
    /// Centered kernel samples over Δlog2 ∈ [-span, +span].
    kernel: Vec<f32>,
    /// Index of Δ=0 inside `kernel`.
    center_idx: usize,
    /// Debug info.
    ratio_mu_log2: Vec<f32>,
    ratio_weights: Vec<f32>,
    ratio_sigmas_log2: Vec<f32>,
}

impl HarmonicityKernel {
    pub fn new(space: &Log2Space, params: HarmonicityParams) -> Self {
        let (ratio_mu_log2, ratio_weights, ratio_sigmas_log2) =
            Self::build_ratio_set_multi_oct(&params);
        let (kernel, center_idx) = Self::build_kernel_multi_oct(
            space.bins_per_oct,
            params.span_octaves,
            &ratio_mu_log2,
            &ratio_weights,
            &ratio_sigmas_log2,
            params.normalize_kernel,
        );
        Self {
            bins_per_oct: space.bins_per_oct,
            params,
            kernel,
            center_idx,
            ratio_mu_log2,
            ratio_weights,
            ratio_sigmas_log2,
        }
    }

    /// Build integer-ratio set without folding to [1,2).
    /// μ = log2(m/n) kept as-is within ±span.
    fn build_ratio_set_multi_oct(params: &HarmonicityParams) -> (Vec<f32>, Vec<f32>, Vec<f32>) {
        use std::collections::HashMap;

        let mut mu = Vec::new();
        let mut w = Vec::new();
        let mut sg = Vec::new();

        // Micro-cent quantization for dedup.
        let quant = 1200.0_f32 * 1000.0_f32; // 0.001 cent
        let mut chosen: HashMap<i64, (usize, u32)> = HashMap::new();

        for m in 1..=params.max_num {
            for n in 1..=params.max_den {
                if !params.allow_subharmonics && n > m {
                    continue;
                }
                let g = gcd_u32(m, n);
                let (rm, rn) = (m / g, n / g);
                let cmplx = rm + rn;
                if let Some(limit) = params.max_complexity {
                    if cmplx > limit {
                        continue;
                    }
                }
                let mu0 = log2f(rm as f32) - log2f(rn as f32);
                if mu0.abs() > params.span_octaves {
                    continue;
                }

                // Weights.
                let base = (cmplx as f32).powf(-params.gamma_ratio);
                let dir = if rm >= rn {
                    (rm as f32).powf(-params.p_harm)
                } else {
                    (rn as f32).powf(-params.q_sub)
                };
                let dist = (-params.alpha_oct_decay * mu0.abs()).exp();
                let is_identity = rm == 1 && rn == 1;
                let mut w_all = base * dir * dist;
                if is_identity {
                    w_all *= params.identity_weight;
                }

                // Width (log2).
                let k = rm.max(rn) as f32;
                let sig_cents = params.sigma_cents * (1.0 + k / params.k0_for_sigma as f32).sqrt();
                let sig_log2 = sig_cents / 1200.0;

                // Dedup by μ; prefer smaller complexity.
                let code = (mu0 * quant).round() as i64;
                if let Some((idx, best_c)) = chosen.get(&code).cloned() {
                    if cmplx < best_c {
                        mu[idx] = mu0;
                        w[idx] = w_all;
                        sg[idx] = sig_log2;
                        chosen.insert(code, (idx, cmplx));
                    }
                } else {
                    let idx = mu.len();
                    mu.push(mu0);
                    w.push(w_all);
                    sg.push(sig_log2);
                    chosen.insert(code, (idx, cmplx));
                }
            }
        }

        (mu, w, sg)
    }

    /// Build centered kernel samples over Δlog2 grid.
    fn build_kernel_multi_oct(
        bins_per_oct: u32,
        span_oct: f32,
        mu: &[f32],
        w: &[f32],
        sig: &[f32],
        normalize: bool,
    ) -> (Vec<f32>, usize) {
        let step = 1.0 / bins_per_oct as f32;
        let m = (2.0 * span_oct / step).round() as usize + 1;
        let center = m / 2;

        let mut k = vec![0.0f32; m];
        for i in 0..m {
            let d = (i as isize - center as isize) as f32 * step; // Δlog2
            let mut acc = 0.0f32;
            for j in 0..mu.len() {
                let dd = d - mu[j];
                let two_s2 = 2.0 * sig[j] * sig[j];
                acc += w[j] * (-(dd * dd) / two_s2).exp();
            }
            k[i] = acc.max(0.0);
        }

        if normalize {
            if let Some(mx) = k.iter().cloned().reduce(f32::max) {
                if mx > 0.0 {
                    for v in &mut k {
                        *v /= mx;
                    }
                }
            }
        }
        (k, center)
    }

    /// Absolute-frequency gate (phase locking, ERB).
    #[inline]
    fn absfreq_gate(f_hz: f32, p: &HarmonicityParams) -> f32 {
        // TFS roll-off
        let g_pl = 1.0 / (1.0 + (f_hz / p.tfs_f_pl_hz).powf(p.tfs_eta.max(0.1)));
        g_pl.clamp(0.0, 1.0)
    }

    pub fn potential_h_from_log2_spectrum(
        &self,
        envelope: &[f32],
        space: &Log2Space,
    ) -> (Vec<f32>, f32) {
        assert_eq!(space.bins_per_oct, self.bins_per_oct);
        assert_eq!(space.n_bins(), envelope.len());

        let y_full = crate::core::fft::linear_convolve_fft(envelope, &self.kernel);
        let start = self.center_idx;
        let end = start + envelope.len();
        assert!(
            y_full.len() >= end,
            "linear_convolve_fft must return full length (N+M-1)"
        );

        let mut y = y_full[start..end].to_vec();

        // level invariance
        let denom = envelope.iter().sum::<f32>().max(1e-12);
        let norm = 1.0 / denom;
        let p = self.params;
        if p.freq_gate {
            for (i, v) in y.iter_mut().enumerate() {
                let gate = Self::absfreq_gate(space.freq_of_index(i), &p);
                *v *= norm * gate;
            }
        } else {
            for v in &mut y {
                *v *= norm;
            }
        }
        (y, denom)
    }

    /// Kernel accessor.
    pub fn kernel(&self) -> &[f32] {
        &self.kernel
    }

    /// Debug: (μ_log2, weights, σ_log2).
    pub fn ratios_debug(&self) -> (&[f32], &[f32], &[f32]) {
        (
            &self.ratio_mu_log2,
            &self.ratio_weights,
            &self.ratio_sigmas_log2,
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::log2space::Log2Space;
    use plotters::prelude::*;
    use std::fs::File;
    use std::path::Path;

    #[test]
    fn kernel_is_centered_and_nonnegative() {
        let space = Log2Space::new(110.0, 3520.0, 48);
        let hk = HarmonicityKernel::new(&space, HarmonicityParams::default());
        let k = hk.kernel();
        assert!(k.len() % 2 == 1);
        assert!(k.iter().all(|&v| v >= 0.0));
        if hk.params.normalize_kernel {
            let mx = k.iter().fold(0.0, |a: f32, &b| a.max(b));
            assert!((mx - 1.0).abs() < 1e-4);
        }
    }

    #[test]
    fn delta_input_reproduces_kernel_shape_same_mode() {
        let space = Log2Space::new(110.0, 3520.0, 48);
        let mut p = HarmonicityParams::default();
        p.freq_gate = false;
        let hk = HarmonicityKernel::new(&space, p);
        let mut env = vec![0.0f32; space.n_bins()];
        let mid = space.n_bins() / 2;
        env[mid] = 1.0;

        let (y, denom) = hk.potential_h_from_log2_spectrum(&env, &space);
        assert!((denom - 1.0f32).abs() < 1e-6);

        // Around the impulse, y should look like the centered kernel.
        let k = hk.kernel();
        let c = hk.center_idx;
        let win = (k.len() / 2).min(32);
        for d in 0..win {
            let i = mid + d;
            let j = mid - d;
            if i < y.len() {
                assert!((y[i] - k[c + d]).abs() < 1e-3);
            }
            if j < y.len() {
                assert!((y[j] - k[c - d]).abs() < 1e-3);
            }
        }
    }

    #[test]
    fn ratio_set_contains_common_intervals() {
        let space = Log2Space::new(55.0, 3520.0, 48);
        let hk = HarmonicityKernel::new(&space, HarmonicityParams::default());
        let (mu, _w, _s) = hk.ratios_debug();
        let targets = [1.0, 3.0 / 2.0, 4.0 / 3.0, 5.0 / 4.0, 6.0 / 5.0, 5.0 / 3.0];
        for r in targets {
            let m = log2f(r);
            let ok = mu
                .iter()
                .any(|&u| (u - m).abs() < 1e-6 || (u + m).abs() < 1e-6);
            assert!(ok, "missing ratio for log2({:.5})", r);
        }
    }

    #[test]
    fn tfs_gate_expected_values() {
        let mut p = HarmonicityParams::default();
        p.freq_gate = true;
        p.tfs_f_pl_hz = 4500.0;
        p.tfs_eta = 4.0;

        let g1 = super::HarmonicityKernel::absfreq_gate(4500.0, &p);
        let g2 = super::HarmonicityKernel::absfreq_gate(9000.0, &p);

        assert!((g1 - 0.5).abs() < 1e-6); // knee = 0.5
        assert!(g2 < 0.07); // 9kHz≈1/(1+16)=0.0588
    }

    #[test]
    fn freq_gate_reduces_high_freq_when_enabled() {
        let mut p = HarmonicityParams::default();
        p.freq_gate = true;
        let space = Log2Space::new(50.0, 8000.0, 48);
        let hk = HarmonicityKernel::new(&space, p);

        let mut lo = vec![0.0f32; space.n_bins()];
        lo[space.index_of_freq(440.0).unwrap()] = 1.0;
        let peak_lo = hk
            .potential_h_from_log2_spectrum(&lo, &space)
            .0
            .iter()
            .cloned()
            .fold(0.0, f32::max);

        let mut hi = vec![0.0f32; space.n_bins()];
        hi[space.index_of_freq(5000.0).unwrap()] = 1.0;
        let peak_hi = hk
            .potential_h_from_log2_spectrum(&hi, &space)
            .0
            .iter()
            .cloned()
            .fold(0.0, f32::max);

        assert!(peak_hi < peak_lo);
    }

    // ---------- Plot tests (ignored by default) ----------

    #[test]
    #[ignore]
    fn plot_kernel_shape_png() {
        // Plot K(Δlog2) over the designed span.
        let space = Log2Space::new(20.0, 8000.0, 200);
        let hk = HarmonicityKernel::new(&space, HarmonicityParams::default());
        let k = hk.kernel().to_vec();
        let step = 1.0 / hk.bins_per_oct as f32;
        let d_log2: Vec<f32> = (0..k.len())
            .map(|i| (i as i32 - hk.center_idx as i32) as f32 * step)
            .collect();

        let out_path = Path::new("target/test_h_kernel_shape.png");
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let maxy = k.iter().cloned().fold(0.0, f32::max) * 1.1;
        let mut chart = ChartBuilder::on(&root)
            .caption("Harmonicity Kernel K(Δlog2)", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(d_log2[0]..d_log2[d_log2.len() - 1], 0.0f32..maxy)
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("Δlog2 (octaves)")
            .y_desc("Amplitude")
            .draw()
            .unwrap();

        chart
            .draw_series(LineSeries::new(
                d_log2.iter().zip(k.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))
            .unwrap();

        root.present().unwrap();
        assert!(File::open(out_path).is_ok());
    }

    #[test]
    #[ignore]
    fn compare_build_kernel_and_eval_kernel_shape() -> Result<(), Box<dyn std::error::Error>> {
        // Compare discrete samples with analytic sum of Gaussians from (μ,w,σ).
        let space = Log2Space::new(20.0, 8000.0, 200);
        let hk = HarmonicityKernel::new(&space, HarmonicityParams::default());
        let k_discrete = hk.kernel().to_vec();
        let (mu, w, sig) = hk.ratios_debug();
        let step = 1.0 / hk.bins_per_oct as f32;

        let d_log2: Vec<f32> = (0..k_discrete.len())
            .map(|i| (i as i32 - hk.center_idx as i32) as f32 * step)
            .collect();
        let mut k_eval = vec![0.0f32; d_log2.len()];
        for (i, &x) in d_log2.iter().enumerate() {
            let mut acc = 0.0f32;
            for j in 0..mu.len() {
                let dd = x - mu[j];
                let two_s2 = 2.0 * sig[j] * sig[j];
                acc += w[j] * (-(dd * dd) / two_s2).exp();
            }
            k_eval[i] = acc;
        }

        // Normalize and compute MAE.
        let s1: f32 = k_discrete.iter().sum();
        let s2: f32 = k_eval.iter().sum();
        let g1: Vec<f32> = k_discrete.iter().map(|&v| v / s1).collect();
        let g2: Vec<f32> = k_eval.iter().map(|&v| v / s2).collect();
        let mae = g1
            .iter()
            .zip(g2.iter())
            .map(|(a, b)| (a - b).abs())
            .sum::<f32>()
            / g1.len() as f32;
        assert!(mae < 1e-6, "MAE={}", mae);

        // Plot overlay.
        let out_path = "target/test_h_kernel_build_vs_eval.png";
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE)?;
        let maxy = g1
            .iter()
            .cloned()
            .fold(0.0, f32::max)
            .max(g2.iter().cloned().fold(0.0, f32::max))
            * 1.1;
        let mut chart = ChartBuilder::on(&root)
            .caption("Discrete K vs Analytic Sum", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(
                d_log2.first().copied().unwrap()..d_log2.last().copied().unwrap(),
                0.0f32..maxy,
            )?;
        chart
            .configure_mesh()
            .x_desc("Δlog2 (octaves)")
            .y_desc("Normalized amplitude")
            .draw()?;
        chart
            .draw_series(LineSeries::new(
                d_log2.iter().zip(g1.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))?
            .label("discrete")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &BLUE));
        chart
            .draw_series(LineSeries::new(
                d_log2.iter().zip(g2.iter()).map(|(&x, &y)| (x, y)),
                &RED,
            ))?
            .label("analytic")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &RED));
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()?;
        root.present()?;
        assert!(Path::new(out_path).exists());
        Ok(())
    }

    #[test]
    #[ignore]
    fn plot_freq_gate_gain_curve_png() -> Result<(), Box<dyn std::error::Error>> {
        use plotters::prelude::*;
        use std::fs::File;
        use std::path::Path;

        let space = Log2Space::new(20.0, 10_000.0, 96);

        // gate OFF
        let mut p_off = HarmonicityParams::default();
        p_off.freq_gate = false;
        let hk_off = HarmonicityKernel::new(&space, p_off);

        // gate ON
        let mut p_on = HarmonicityParams::default();
        p_on.freq_gate = true;
        let hk_on = HarmonicityKernel::new(&space, p_on);

        let n = space.n_bins();
        let mut env = vec![0.0f32; n];

        let mut xs_hz = Vec::with_capacity(n);
        let mut y_off = Vec::with_capacity(n);
        let mut y_on = Vec::with_capacity(n);

        for i in 0..n {
            env.iter_mut().for_each(|x| *x = 0.0);
            env[i] = 1.0;

            let (h0, _) = hk_off.potential_h_from_log2_spectrum(&env, &space);
            let (h1, _) = hk_on.potential_h_from_log2_spectrum(&env, &space);

            xs_hz.push(space.freq_of_index(i));
            y_off.push(h0[i]);
            y_on.push(h1[i]);
        }

        let out_path = "target/test_h_freq_gate_curve.png";
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE)?;
        let max_y = y_off.iter().chain(y_on.iter()).copied().fold(0.0, f32::max) * 1.1;

        let mut chart = ChartBuilder::on(&root)
            .caption(
                "Abs-frequency Gate Curve (center response)",
                ("sans-serif", 30),
            )
            .margin(10)
            .build_cartesian_2d(xs_hz[0]..xs_hz[xs_hz.len() - 1], 0.0f32..max_y)?;

        chart
            .configure_mesh()
            .x_desc("Frequency [Hz]")
            .y_desc("Center response")
            .draw()?;

        chart
            .draw_series(LineSeries::new(
                xs_hz.iter().zip(y_off.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))?
            .label("freq_gate = false")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &BLUE));

        chart
            .draw_series(LineSeries::new(
                xs_hz.iter().zip(y_on.iter()).map(|(&x, &y)| (x, y)),
                &RED,
            ))?
            .label("freq_gate = true")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &RED));

        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()?;
        root.present()?;
        assert!(File::open(out_path).is_ok());
        Ok(())
    }

    #[test]
    #[ignore]
    fn plot_potential_h_from_log2_spectrum_delta_input() -> Result<(), Box<dyn std::error::Error>> {
        // δ input should reproduce the kernel shape in "same" mode.
        let space = Log2Space::new(20.0, 8000.0, 200);
        let mut p = HarmonicityParams::default();
        p.freq_gate = false; // ensure no gating
        let hk = HarmonicityKernel::new(&space, p);
        let mut env = vec![0.0f32; space.n_bins()];
        let mid = env.len() / 2;
        env[mid] = 1.0;

        let (h_vec, _) = hk.potential_h_from_log2_spectrum(&env, &space);

        let step = 1.0 / hk.bins_per_oct as f32;
        let d_log2_field: Vec<f32> = (0..env.len())
            .map(|i| (i as i32 - mid as i32) as f32 * step)
            .collect();

        // Normalize to compare shapes.
        let max_h = h_vec.iter().cloned().fold(0.0, f32::max);
        let h_norm: Vec<f32> = h_vec.iter().map(|&v| v / max_h).collect();

        let k = hk.kernel();
        let d_log2_kern: Vec<f32> = (0..k.len())
            .map(|i| (i as i32 - hk.center_idx as i32) as f32 * step)
            .collect();
        let max_k = k.iter().cloned().fold(0.0, f32::max);
        let k_norm: Vec<f32> = k.iter().map(|&v| v / max_k).collect();

        let out_path = "target/test_h_potential_from_log2_delta.png";
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE)?;
        let mut chart = ChartBuilder::on(&root)
            .caption(
                "Potential H from Log2 Spectrum (δ input)",
                ("sans-serif", 30),
            )
            .margin(10)
            .build_cartesian_2d(
                d_log2_field[d_log2_field.len() / 2 - 800]
                    ..d_log2_field[d_log2_field.len() / 2 + 800],
                0.0f32..1.05f32,
            )?;
        chart
            .configure_mesh()
            .x_desc("Δlog2 (octaves)")
            .y_desc("Normalized amplitude")
            .draw()?;
        chart
            .draw_series(LineSeries::new(
                d_log2_field
                    .iter()
                    .zip(h_norm.iter())
                    .map(|(&x, &y)| (x, y)),
                &BLUE,
            ))?
            .label("H(log2 δ)")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &BLUE));
        chart
            .draw_series(LineSeries::new(
                d_log2_kern.iter().zip(k_norm.iter()).map(|(&x, &y)| (x, y)),
                &GREEN,
            ))?
            .label("Kernel K(Δlog2)")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &GREEN));
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()?;
        root.present()?;
        assert!(Path::new(out_path).exists());
        Ok(())
    }
}
</file>

<file path="src/synth/engine.rs">
use rustfft::num_complex::Complex32;

use crate::core::fft::{ISTFT, bin_freqs_hz};

#[derive(Clone, Debug)]
pub struct SynthConfig {
    pub fs: f32,
    pub fft_size: usize,
    pub hop: usize,
    pub n_bins: usize,
}

pub struct SynthEngine {
    cfg: SynthConfig,
    istft: ISTFT,
    phase: Vec<f32>, // phase accumulator per bin
    bin_freqs: Vec<f32>,
}

impl SynthEngine {
    pub fn new(cfg: SynthConfig) -> Self {
        let istft = ISTFT::new(cfg.fft_size, cfg.hop);
        let phase = vec![0.0f32; cfg.n_bins];
        let bin_freqs = bin_freqs_hz(cfg.fs, cfg.fft_size);
        Self {
            cfg,
            istft,
            phase,
            bin_freqs,
        }
    }

    pub fn bin_freqs_hz(&self) -> Vec<f32> {
        self.bin_freqs.clone()
    }

    /// Render one hop of audio from magnitude spectrum (amps per bin).
    pub fn render_hop(&mut self, amps: &[f32]) -> Vec<f32> {
        let n_half = self.cfg.n_bins;
        let hop_t = self.cfg.hop as f32 / self.cfg.fs;

        let mut half_spec = vec![Complex32::new(0.0, 0.0); n_half];
        for k in 0..n_half {
            // advance phase
            let omega = 2.0 * std::f32::consts::PI * self.bin_freqs[k];
            self.phase[k] = (self.phase[k] + omega * hop_t) % (2.0 * std::f32::consts::PI);

            // magnitude to complex using current phase
            let (s, c) = self.phase[k].sin_cos();
            half_spec[k] = Complex32::new(c * amps[k], s * amps[k]);
        }
        // iSTFT overlap-add
        self.istft.process(&half_spec)
    }
}
</file>

<file path="src/ui/viewdata.rs">
use crate::core::landscape::LandscapeFrame;


#[derive(Clone, Debug, Default)]
pub struct WaveFrame {
    pub fs: f32,
    pub samples: Vec<f32>,
}

#[derive(Clone, Debug, Default)]
pub struct SpecFrame {
    pub spec_hz: Vec<f32>,
    pub amps: Vec<f32>,
}

#[derive(Clone, Debug, Default)]
pub struct UiFrame {
    pub wave: WaveFrame,
    pub spec: SpecFrame,
    pub landscape: LandscapeFrame,
}
</file>

<file path="src/core/nsgt_fft.rs">
//! core/nsgt_fft.rs — Log2-axis NSGT (FFT-batched analysis version)
//!
//! Faster constant-Q analysis using FFT batches grouped by window length.
//! Compatible with `NsgtLog2` output format (for downstream roughness/consonance).

use crate::core::log2space::Log2Space;
use crate::core::nsgt::{BandCoeffs, NsgtLog2Config};
use rustfft::{FftPlanner, num_complex::Complex32};
use std::sync::Arc;

// =====================================================
// Internal structs
// =====================================================

#[derive(Clone, Debug)]
struct BandInfo {
    f_hz: f32,
    log2_hz: f32,
    bin: usize,
}

#[derive(Clone)]
struct BandGroup {
    win_len: usize,
    hop: usize,
    window: Vec<f32>,
    bands: Vec<BandInfo>,
    fft: Arc<dyn rustfft::Fft<f32>>,
}

// =====================================================
// Main struct
// =====================================================

#[derive(Clone)]
pub struct NsgtFftLog2 {
    cfg: NsgtLog2Config,
    space: Log2Space,
    groups: Vec<BandGroup>,
}

// =====================================================
// Implementation
// =====================================================

impl NsgtFftLog2 {
    /// Construct FFT-batched NSGT analyzer grouped by octave.
    /// Each group's window length L is decided at the group's f_min,
    /// so that f* = Q fs / L <= f_min and the inflection never falls inside.
    pub fn new(cfg: NsgtLog2Config, space: Log2Space) -> Self {
        let fs = cfg.fs;
        let bpo = space.bins_per_oct as f32;
        let q = 1.0 / (2f32.powf(1.0 / bpo) - 1.0);

        // ← 必要なら false にして非2冪L（さらに滑らか、やや遅い）
        let use_pow2 = true;

        use std::collections::BTreeMap;
        let mut by_oct: BTreeMap<i32, Vec<(f32, f32)>> = BTreeMap::new();
        for (&f, &log2f) in space.centers_hz.iter().zip(space.centers_log2.iter()) {
            by_oct
                .entry(log2f.floor() as i32)
                .or_default()
                .push((f, log2f));
        }

        let mut groups = Vec::new();
        for (_oct, mut bins) in by_oct {
            bins.sort_by(|a, b| a.0.partial_cmp(&b.0).unwrap());
            let f_min = bins.first().unwrap().0;

            // 決定式： L_g = ceil(Q fs / f_min)
            let mut Lg = (q * fs / f_min).ceil() as usize;
            Lg = Lg.max(32);
            if use_pow2 {
                Lg = Lg.next_power_of_two();
            }

            let hop = ((1.0 - cfg.overlap) * Lg as f32).round().max(1.0) as usize;
            let window = hann_periodic(Lg);

            let mut planner = FftPlanner::<f32>::new();
            let fft = planner.plan_fft_forward(Lg);

            let bands: Vec<_> = bins
                .into_iter()
                .map(|(f, log2f)| {
                    let bin = (f * Lg as f32 / fs).round() as usize;
                    BandInfo {
                        f_hz: f,
                        log2_hz: log2f,
                        bin,
                    }
                })
                .collect();

            groups.push(BandGroup {
                win_len: Lg,
                hop,
                window,
                bands,
                fft,
            });
        }

        Self { cfg, space, groups }
    }

    //impl NsgtFftLog2 {
    // pub fn new(cfg: NsgtLog2Config, space: Log2Space) -> Self {
    //     let fs = cfg.fs;
    //     let bpo = space.bins_per_oct as f32;
    //     let q = 1.0 / (2f32.powf(1.0 / bpo) - 1.0);

    //     let mut bands_all: Vec<(f32, f32, usize)> = space
    //         .centers_hz
    //         .iter()
    //         .zip(&space.centers_log2)
    //         .map(|(&f, &log2_f)| {
    //             let L = (q * fs / f).ceil() as usize;
    //             let L_pow2 = L.next_power_of_two().max(32);
    //             (f, log2_f, L_pow2)
    //         })
    //         .collect();

    //     use itertools::Itertools;
    //     let mut groups = Vec::new();
    //     for (L_pow2, subset) in &bands_all.into_iter().group_by(|(_, _, L)| *L) {
    //         let hop = ((1.0 - cfg.overlap) * L_pow2 as f32).round().max(1.0) as usize;
    //         let window = hann_periodic(L_pow2);
    //         let mut planner = FftPlanner::<f32>::new();
    //         let fft = planner.plan_fft_forward(L_pow2);
    //         let bands: Vec<_> = subset
    //             .map(|(f, log2_f, _)| {
    //                 let bin = (f * L_pow2 as f32 / fs).round() as usize;
    //                 BandInfo {
    //                     f_hz: f,
    //                     log2_hz: log2_f,
    //                     bin,
    //                 }
    //             })
    //             .collect();
    //         groups.push(BandGroup {
    //             win_len: L_pow2,
    //             hop,
    //             window,
    //             bands,
    //             fft,
    //         });
    //     }

    //     Self { cfg, space, groups }
    // }

    // pub fn new(cfg: NsgtLog2Config, space: Log2Space) -> Self {
    //     let fs = cfg.fs;
    //     let bpo = space.bins_per_oct as f32;
    //     let q = 1.0 / (2f32.powf(1.0 / bpo) - 1.0);

    //     let mut bands_all: Vec<(f32, f32, usize)> = space
    //         .centers_hz
    //         .iter()
    //         .zip(&space.centers_log2)
    //         .map(|(&f, &log2_f)| {
    //             let L = (q * fs / f).ceil() as usize;
    //             let L_pow2 = L.next_power_of_two().max(32);
    //             (f, log2_f, L_pow2)
    //         })
    //         .collect();

    //     use itertools::Itertools;
    //     let mut groups = Vec::new();
    //     for (L_pow2, subset) in &bands_all.into_iter().group_by(|(_, _, L)| *L) {
    //         let hop = ((1.0 - cfg.overlap) * L_pow2 as f32).round().max(1.0) as usize;
    //         let window = hann_periodic(L_pow2);
    //         let mut planner = FftPlanner::<f32>::new();
    //         let fft = planner.plan_fft_forward(L_pow2);
    //         let bands: Vec<_> = subset
    //             .map(|(f, log2_f, _)| {
    //                 let bin = (f * L_pow2 as f32 / fs).round() as usize;
    //                 BandInfo {
    //                     f_hz: f,
    //                     log2_hz: log2_f,
    //                     bin,
    //                 }
    //             })
    //             .collect();
    //         groups.push(BandGroup {
    //             win_len: L_pow2,
    //             hop,
    //             window,
    //             bands,
    //             fft,
    //         });
    //     }

    //     Self { cfg, space, groups }
    // }

    pub fn analyze(&self, x: &[f32]) -> Vec<BandCoeffs> {
        let fs = self.cfg.fs;
        let mut results = Vec::new();

        for g in &self.groups {
            let L = g.win_len;
            let hop = g.hop;
            if x.len() < L {
                continue;
            }

            let n_frames = (x.len() - L) / hop + 1;

            let U = (g.window.iter().map(|v| v * v).sum::<f32>()).sqrt();

            let mut buf = vec![Complex32::default(); L];
            let mut fft_out = vec![Complex32::default(); L];

            let mut group_results: Vec<BandCoeffs> = g
                .bands
                .iter()
                .map(|b| BandCoeffs {
                    coeffs: Vec::with_capacity(n_frames),
                    t_sec: Vec::with_capacity(n_frames),
                    f_hz: b.f_hz,
                    log2_hz: b.log2_hz,
                    win_len: L,
                    hop,
                })
                .collect();

            for frame_idx in 0..n_frames {
                let start = frame_idx * hop;
                for i in 0..L {
                    let xi = if start + i < x.len() {
                        x[start + i]
                    } else {
                        0.0
                    };
                    buf[i] = Complex32::new(xi * g.window[i] / U, 0.0);
                }

                g.fft.process(&mut buf);
                fft_out.copy_from_slice(&buf);

                for (b_idx, band) in g.bands.iter().enumerate() {
                    let bin = band.bin.min(L - 1);
                    let val = fft_out[bin];
                    group_results[b_idx].coeffs.push(val);
                    group_results[b_idx].t_sec.push((start + L / 2) as f32 / fs);
                }
            }

            results.extend(group_results);
        }

        results
    }

    //     pub fn analyze(&self, x: &[f32]) -> Vec<BandCoeffs> {
    //     let fs = self.cfg.fs;
    //     let mut results = Vec::new();

    //     for g in &self.groups {
    //         let L = g.win_len;
    //         let hop = g.hop;
    //         let U = (g.window.iter().map(|v| v * v).sum::<f32>()).sqrt();

    //         if x.len() < L {
    //             continue;
    //         }
    //         let n_frames = (x.len() - L) / hop + 1;
    //         let mut buf = vec![Complex32::default(); L];
    //         let mut fft_out = vec![Complex32::default(); L];

    //         let mut group_results: Vec<BandCoeffs> = g
    //             .bands
    //             .iter()
    //             .map(|b| BandCoeffs {
    //                 coeffs: Vec::with_capacity(n_frames),
    //                 t_sec: Vec::with_capacity(n_frames),
    //                 f_hz: b.f_hz,
    //                 log2_hz: b.log2_hz,
    //                 win_len: L,
    //                 hop,
    //             })
    //             .collect();

    //         for frame_idx in 0..n_frames {
    //             let start = frame_idx * hop;
    //             for i in 0..L {
    //                 let xi = if start + i < x.len() {
    //                     x[start + i]
    //                 } else {
    //                     0.0
    //                 };
    //                 buf[i] = Complex32::new(xi * g.window[i] / U, 0.0);
    //             }

    //             g.fft.process(&mut buf);
    //             fft_out.copy_from_slice(&buf);

    //             for (b_idx, band) in g.bands.iter().enumerate() {
    //                 let bin = band.bin.min(L - 1);
    //                 let val = fft_out[bin];
    //                 group_results[b_idx].coeffs.push(val);
    //                 group_results[b_idx].t_sec.push((start + L / 2) as f32 / fs);
    //             }
    //         }

    //         results.extend(group_results);
    //     }

    //     results
    // }

    pub fn analyze_envelope(&self, signal: &[f32]) -> Vec<f32> {
        let bands = self.analyze(signal);
        bands
            .iter()
            .map(|b| {
                if b.coeffs.is_empty() {
                    0.0
                } else {
                    b.coeffs.iter().map(|z| z.norm()).sum::<f32>() / b.coeffs.len() as f32
                }
            })
            .collect()
    }

    pub fn analyze_psd(&self, signal: &[f32]) -> Vec<f32> {
        let bands = self.analyze(signal);
        let fs = self.cfg.fs;
        bands
            .iter()
            .map(|b| {
                if b.coeffs.is_empty() {
                    0.0
                } else {
                    let mean_pow =
                        b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / b.coeffs.len() as f32;
                    let bw = b.f_hz * (2f32.powf(1.0 / self.space.bins_per_oct as f32) - 1.0);
                    mean_pow / bw.max(1e-9)
                }
            })
            .collect()
    }

    pub fn space(&self) -> &Log2Space {
        &self.space
    }
}

fn hann_periodic(n: usize) -> Vec<f32> {
    (0..n)
        .map(|i| 0.5 * (1.0 - (2.0 * std::f32::consts::PI * (i as f32) / n as f32).cos()))
        .collect()
}

// =====================================================
// Tests (移植版)
// =====================================================

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;
    use plotters::prelude::*;
    use rand::Rng;
    use scirs2_signal::waveforms::{brown_noise, pink_noise};

    fn mk_sine(fs: f32, f: f32, secs: f32) -> Vec<f32> {
        let n = (fs * secs).round() as usize;
        (0..n)
            .map(|i| (2.0 * std::f32::consts::PI * f * (i as f32) / fs).sin())
            .collect()
    }

    #[test]
    fn pure_tone_hits_right_band() {
        let fs = 48_000.0;
        let nsgt = NsgtFftLog2::new(
            NsgtLog2Config { fs, overlap: 0.5 },
            Log2Space::new(20.0, 8000.0, 48),
        );
        let sig = mk_sine(fs, 440.0, 1.0);
        let bands = nsgt.analyze(&sig);
        let (mut best_f, mut best_val) = (0.0, 0.0);
        for b in &bands {
            let p =
                b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / (b.coeffs.len().max(1) as f32);
            if p > best_val {
                best_val = p;
                best_f = b.f_hz;
            }
        }
        let cents = 1200.0 * (((best_f / 440.0_f32).log2()).abs());
        assert!(
            cents < 60.0,
            "440Hz peak band off by {:.1} cents (f={:.2})",
            cents,
            best_f
        );
    }

    #[test]
    fn window_len_monotonic_vs_freq() {
        let nsgt = NsgtFftLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 48));
        let mut winlens = nsgt
            .groups
            .iter()
            .flat_map(|g| g.bands.iter().map(move |_| g.win_len))
            .collect::<Vec<_>>();
        for w in winlens.windows(2) {
            assert!(w[0] >= w[1]);
        }
    }

    #[test]
    fn empty_signal_returns_empty() {
        let nsgt = NsgtFftLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 48));
        let out = nsgt.analyze(&[]);
        assert!(out.is_empty());
    }

    #[test]
    fn low_vs_high_freq_energy_scaling() {
        let fs = 48000.0;
        let nsgt = NsgtFftLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig_low = mk_sine(fs, 220.0, 10.0);
        let sig_high = mk_sine(fs, 1760.0, 10.0);
        let p_low = nsgt
            .analyze(&sig_low)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let p_high = nsgt
            .analyze(&sig_high)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let ratio = p_high / p_low;
        assert_relative_eq!(ratio, 1.0, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn amplitude_linearity() {
        let fs = 48000.0;
        let nsgt = NsgtFftLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig1 = mk_sine(fs, 440.0, 1.0);
        let sig2: Vec<f32> = sig1.iter().map(|v| v * 2.0).collect();
        let e1 = nsgt
            .analyze(&sig1)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let e2 = nsgt
            .analyze(&sig2)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        assert_relative_eq!(e2 / e1, 4.0, epsilon = 0.1, max_relative = 0.1);
    }

    #[test]
    fn time_invariance_of_magnitude() {
        let fs = 48000.0;
        let nsgt = NsgtFftLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig = mk_sine(fs, 440.0, 1.0);
        let shift = (0.1 * fs) as usize;
        let mut sig_shifted = vec![0.0; shift];
        sig_shifted.extend_from_slice(&sig);
        let amp1 = nsgt.analyze_envelope(&sig);
        let amp2 = nsgt.analyze_envelope(&sig_shifted);
        let corr: f32 = amp1.iter().zip(&amp2).map(|(a, b)| a * b).sum::<f32>()
            / (amp1.iter().map(|a| a * a).sum::<f32>().sqrt()
                * amp2.iter().map(|b| b * b).sum::<f32>().sqrt());
        assert!(
            corr > 0.95,
            "Magnitude envelope correlation should be high (corr={corr:.3})"
        );
    }

    #[test]
    fn hop_size_stability() {
        let fs = 48000.0;
        let space = Log2Space::new(20.0, 8000.0, 96);
        let sig = mk_sine(fs, 440.0, 1.0);
        let e_mean = |overlap: f32| {
            let nsgt = NsgtFftLog2::new(NsgtLog2Config { fs, overlap }, space.clone());
            let out = nsgt.analyze(&sig);
            let sum_e: f32 = out
                .iter()
                .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
                .sum();
            let n_frames: usize = out.iter().map(|b| b.coeffs.len()).max().unwrap_or(1);
            sum_e / n_frames as f32
        };
        let e_half = e_mean(0.5);
        let e_75 = e_mean(0.75);
        assert_relative_eq!(e_half, e_75, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn band_count_matches_space() {
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtFftLog2::new(NsgtLog2Config::default(), space.clone());
        let count_space = space.centers_hz.len();
        let count_total: usize = nsgt.groups.iter().map(|g| g.bands.len()).sum();
        assert_eq!(count_space, count_total);
    }

    #[test]
    #[ignore]
    fn plot_nsgt_spectrum() {
        let fs = 48000.0;
        let nsgt = NsgtFftLog2::new(
            NsgtLog2Config { fs, overlap: 0.5 },
            Log2Space::new(20.0, 8000.0, 96),
        );
        let sig = mk_sine(fs, 440.0, 10.0);
        let bands = nsgt.analyze(&sig);
        let points: Vec<(f32, f32)> = bands
            .iter()
            .map(|b| {
                let p = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                    / (b.coeffs.len().max(1) as f32);
                (b.log2_hz, p)
            })
            .collect();
        let root =
            BitMapBackend::new("target/nsgt_fft_spectrum.png", (1500, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let mut chart = ChartBuilder::on(&root)
            .caption("FFT NSGT Spectrum (pure 440Hz)", ("sans-serif", 30))
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(50)
            .build_cartesian_2d(
                (20f32.log2())..(8000f32.log2()),
                0f32..points.iter().map(|(_, p)| *p).fold(0.0f32, f32::max) * 1.1,
            )
            .unwrap();
        chart
            .configure_mesh()
            .x_desc("log2(frequency) [oct]")
            .y_desc("mean power")
            .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
            .draw()
            .unwrap();
        chart
            .draw_series(LineSeries::new(points.iter().cloned(), &BLUE))
            .unwrap();
        root.present().unwrap();
    }

    #[test]
    #[ignore]
    fn plot_nsgt_log2_noise_response() {
        let fs = 48_000.0;
        let secs = 10.0;
        let n = (fs * secs) as usize;
        let nsgt = NsgtFftLog2::new(
            NsgtLog2Config { fs, overlap: 0.5 },
            Log2Space::new(35.0, 24_000.0, 50),
        );
        let mut rng = rand::rng();
        let white: Vec<f32> = (0..n).map(|_| rng.random_range(-1.0f32..1.0)).collect();
        let pink: Vec<f32> = pink_noise(n, Some(42))
            .unwrap()
            .iter()
            .map(|&v| v as f32)
            .collect();
        let brown: Vec<f32> = brown_noise(n, Some(42))
            .unwrap()
            .iter()
            .map(|&v| v as f32)
            .collect();
        let psd_norm = |bands: &[BandCoeffs]| -> Vec<f32> {
            bands
                .iter()
                .map(|b| {
                    let mean_pow = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                        / (b.coeffs.len().max(1) as f32);
                    let bw = nsgt
                        .space()
                        .delta_hz_at(b.f_hz)
                        .unwrap_or(fs / (b.win_len as f32));
                    mean_pow / bw.max(1e-9)
                })
                .collect()
        };

        let bands_w = nsgt.analyze(&white);
        let bands_p = nsgt.analyze(&pink);
        let bands_b = nsgt.analyze(&brown);
        let to_db =
            |x: &[f32]| -> Vec<f32> { x.iter().map(|v| 10.0 * v.max(1e-20).log10()).collect() };
        let white_db = to_db(&psd_norm(&bands_w));
        let pink_db = to_db(&psd_norm(&bands_p));
        let brown_db = to_db(&psd_norm(&bands_b));
        let log2x = nsgt.space().centers_log2.clone();
        let root = BitMapBackend::new("target/nsgt_fft_noise_psd_db.png", (1500, 1000))
            .into_drawing_area();
        root.fill(&WHITE).unwrap();
        let y_min = white_db
            .iter()
            .chain(&pink_db)
            .chain(&brown_db)
            .cloned()
            .fold(f32::INFINITY, f32::min);
        let y_max = white_db
            .iter()
            .chain(&pink_db)
            .chain(&brown_db)
            .cloned()
            .fold(f32::NEG_INFINITY, f32::max);
        let mut chart = ChartBuilder::on(&root)
            .caption(
                "FFT NSGT PSD (White / Pink / Brown Noise)",
                ("sans-serif", 18),
            )
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(60)
            .build_cartesian_2d(
                (20f32.log2())..(24_000f32.log2()),
                (y_min - 10.0)..(y_max + 10.0),
            )
            .unwrap();
        chart
            .configure_mesh()
            .x_desc("log2(frequency) [oct]")
            .y_desc("Power Spectral Density [dB re 1/Hz]")
            .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
            .draw()
            .unwrap();
        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(white_db.iter().cloned()),
                &BLUE,
            ))
            .unwrap()
            .label("White");
        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(pink_db.iter().cloned()),
                &RED,
            ))
            .unwrap()
            .label("Pink");
        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(brown_db.iter().cloned()),
                &GREEN,
            ))
            .unwrap()
            .label("Brown");
        root.present().unwrap();
    }
}
</file>

<file path=".gitignore">
/target
/debug

*~
\#*\#
.\#*
*.bak
a.wav
</file>

<file path="src/core/erb.rs">
//! core/erb.rs — ERB scale utilities and ErbSpace definition.

use std::f32::consts::LN_10;

/// Converts frequency [Hz] to ERB-rate value.
#[inline]
pub fn hz_to_erb(f_hz: f32) -> f32 {
    // 21.4 * log10(4.37e-3 * f + 1)
    21.4 * ((4.37e-3 * f_hz + 1.0).ln() / LN_10)
}

/// Converts ERB-rate value to frequency [Hz].
#[inline]
pub fn erb_to_hz(e: f32) -> f32 {
    // (10^(e/21.4) - 1) / 4.37e-3
    (((e / 21.4) * LN_10).exp() - 1.0) / 4.37e-3
}

/// Returns ERB bandwidth in Hz (Glasberg & Moore 1990)
#[inline]
pub fn erb_bw_hz(f_hz: f32) -> f32 {
    24.7 * (4.37e-3 * f_hz + 1.0)
}

/// Represents a frequency axis linearly spaced in ERB domain.
#[derive(Clone, Debug)]
pub struct ErbSpace {
    pub f_min: f32,
    pub f_max: f32,
    pub erb_step: f32,
    pub erb_min: f32,
    pub erb_max: f32,
    pub freqs_hz: Vec<f32>,
}

impl ErbSpace {
    /// Create a new ERB-space axis.
    ///
    /// # Arguments
    /// * `f_min` - lowest frequency [Hz]
    /// * `f_max` - highest frequency [Hz]
    /// * `erb_step` - ERB step (smaller → denser sampling)
    pub fn new(f_min: f32, f_max: f32, erb_step: f32) -> Self {
        let erb_min = hz_to_erb(f_min);
        let erb_max = hz_to_erb(f_max);

        let n_points = ((erb_max - erb_min) / erb_step).floor() as usize + 1;

        let mut freqs_hz = Vec::with_capacity(n_points);
        for i in 0..n_points {
            let e = erb_min + i as f32 * erb_step;
            freqs_hz.push(erb_to_hz(e));
        }

        Self {
            f_min,
            f_max,
            erb_step,
            erb_min,
            erb_max,
            freqs_hz,
        }
    }

    /// Convert frequency [Hz] to ERB coordinate.
    #[inline]
    pub fn to_erb(&self, f_hz: f32) -> f32 {
        hz_to_erb(f_hz)
    }

    /// Convert ERB coordinate to frequency [Hz].
    #[inline]
    pub fn to_hz(&self, e: f32) -> f32 {
        erb_to_hz(e)
    }

    /// Return number of ERB bins.
    #[inline]
    pub fn len(&self) -> usize {
        self.freqs_hz.len()
    }

    /// Return reference to frequency vector [Hz].
    #[inline]
    pub fn freqs_hz(&self) -> &[f32] {
        &self.freqs_hz
    }

    pub fn index_of_freq(&self, f_hz: f32) -> usize {
        self.freqs_hz
            .iter()
            .position(|&f| f >= f_hz)
            .unwrap_or(self.freqs_hz.len() - 1)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    /// Round-trip test of hz_to_erb ↔ erb_to_hz conversions.
    #[test]
    fn test_erb_conversion_roundtrip() {
        // ERB変換の往復精度を複数点で確認
        for f in [20.0, 100.0, 1000.0, 4000.0, 8000.0, 16000.0] {
            let e = hz_to_erb(f);
            let f2 = erb_to_hz(e);
            let rel_err = (f - f2).abs() / f;
            assert!(
                rel_err < 1e-4,
                "roundtrip mismatch: f={f}, f2={f2}, rel_err={rel_err}"
            );
        }
    }

    /// Check monotonicity and range of ErbSpace.
    #[test]
    fn test_erbspace_creation() {
        let space = ErbSpace::new(50.0, 8000.0, 0.5);
        // ERB stepが0.5でも10点以上はあるはず
        assert!(
            space.freqs_hz.len() > 10,
            "too few bins: {}",
            space.freqs_hz.len()
        );
        assert!(space.freqs_hz[0] >= 50.0);
        assert!(
            *space.freqs_hz.last().unwrap() <= 8000.0 + 1e-3 * 8000.0,
            "max freq exceeded"
        );

        // 周波数は単調増加していること
        let diffs: Vec<f32> = space.freqs_hz.windows(2).map(|w| w[1] - w[0]).collect();
        assert!(diffs.iter().all(|&d| d > 0.0), "non-monotonic freqs");
    }

    /// Validate that hz_to_erb is monotonic and increasing.
    #[test]
    fn test_hz_to_erb_monotonic() {
        let f: Vec<f32> = (1..20).map(|i| i as f32 * 500.0).collect();
        let e: Vec<f32> = f.iter().map(|&x| hz_to_erb(x)).collect();
        assert!(
            e.windows(2).all(|w| w[1] > w[0]),
            "hz_to_erb not strictly increasing"
        );
    }

    /// Verify erb_bw_hz matches Glasberg & Moore expected scaling.
    #[test]
    fn test_erb_bw_reference_values() {
        let bw_1k = erb_bw_hz(1000.0);
        let bw_4k = erb_bw_hz(4000.0);
        // 理論値に近いこと（132.6Hz程度と500Hz程度）
        assert!((bw_1k - 132.6).abs() < 1.0, "bw(1kHz) mismatch: {bw_1k}");
        assert!((bw_4k - 456.4).abs() < 1.0, "bw(4kHz) mismatch: {bw_4k}");
        assert!(bw_4k > bw_1k);
    }

    /// Extreme range test (very wide band)
    #[test]
    fn test_erbspace_extreme_range() {
        let space = ErbSpace::new(20.0, 20000.0, 0.25);
        let n = space.len();
        assert!(n > 100, "unexpectedly few bins for wide band: {n}");
        // ERB最小・最大が整合していること
        let e_min = hz_to_erb(20.0);
        let e_max = hz_to_erb(20000.0);
        assert!(
            (space.erb_min - e_min).abs() < 1e-4 && (space.erb_max - e_max).abs() < 1e-4,
            "erb range mismatch: min {} vs {}, max {} vs {}",
            space.erb_min,
            e_min,
            space.erb_max,
            e_max
        );
    }

    #[test]
    fn delta_erb_mapping_matches_exact() {
        use super::*;
        // 1 kHz 近傍で複数の周波数差をチェック
        let fi = 1000.0f32;
        let steps_hz = [
            -300.0, -150.0, -75.0, -30.0, -15.0, 0.0, 15.0, 30.0, 75.0, 150.0, 300.0,
        ];

        for df_hz in steps_hz {
            let fj = (fi + df_hz).max(1.0);
            let d_exact = hz_to_erb(fj) - hz_to_erb(fi);
            let bw_mid = erb_bw_hz(0.5 * (fi + fj));
            let d_approx = (fj - fi) / bw_mid;

            // 誤差（相対）: ±3% 以内なら OK とする
            let denom = d_exact.abs().max(1e-6);
            let rel_err = (d_exact - d_approx).abs() / denom;
            assert!(
                rel_err < 0.03,
                "ΔERB approx mismatch at df={df_hz}: exact={d_exact}, approx={d_approx}, rel_err={rel_err}"
            );
        }
    }
}
</file>

<file path="src/main.rs">
// Entry point: launches the egui/eframe app and spawns worker threads.
mod app;
mod audio;
mod config;
mod core;
mod life;
mod synth;
mod ui;

use clap::Parser;
use std::sync::{
    Arc,
    atomic::{AtomicBool, Ordering},
};

/// Parse a comma-separated list like "440:0.8,880:0.5"
fn parse_tones(s: &str) -> Vec<(f32, f32)> {
    s.split(',')
        .filter_map(|pair| {
            let mut parts = pair.split(':');
            let f = parts.next()?.trim().parse::<f32>().ok()?;
            let a = parts
                .next()
                .map(|x| x.trim().parse::<f32>().unwrap_or(100.))
                .unwrap_or(100.);
            Some((f, a))
        })
        .collect()
}

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Args {
    /// Play audio in realtime
    #[arg(long, default_value_t = true)]
    play: bool,

    /// Write audio to wav file
    #[arg(long)]
    wav: Option<String>,

    /// Input tones in the form f1:amp,f2:amp,...
    #[arg(long)]
    tones: Option<String>,
}

fn main() -> eframe::Result<()> {
    let args = Args::parse();

    // Parse tones argument (default 440 Hz @ amp=1.0)
    let tones_parsed = args
        .tones
        .as_deref()
        .map(parse_tones)
        .unwrap_or_else(|| vec![(440.0, 500.0)]);

    println!("Using tones: {:?}", tones_parsed);

    let stop_flag = Arc::new(AtomicBool::new(false));
    let stop_flag_for_ctrlc = stop_flag.clone();

    ctrlc::set_handler(move || {
        stop_flag_for_ctrlc.store(true, Ordering::SeqCst);
    })
    .expect("Error setting Ctrl-C handler");

    let native_options = eframe::NativeOptions {
        viewport: egui::ViewportBuilder::default().with_inner_size([1200.0, 1200.0]),
        ..Default::default()
    };

    eframe::run_native(
        "Conchordal",
        native_options,
        Box::new(|cc| {
            Ok(Box::new(app::App::new(
                cc,
                args,
                stop_flag.clone(),
                tones_parsed,
            )))
        }),
    )
}
</file>

<file path="src/ui/plots.rs">
use crate::core::landscape::LandscapeFrame;
use egui_plot::{Bar, BarChart, GridInput, GridMark, Line, Plot, PlotPoints, log_grid_spacer};

/// log2 軸で周波数を描画するヒストグラム（自動幅調整版）
pub fn log2_hist_hz(
    ui: &mut egui::Ui,
    title: &str,
    xs_hz: &[f32],
    ys: &[f32],
    y_label: &str,
    y_min: f64,
    y_max: f64,
) {
    assert_eq!(xs_hz.len(), ys.len());
    if xs_hz.is_empty() {
        return;
    }

    // 各ビンごとに棒の幅を決める
    let mut bars: Vec<Bar> = Vec::with_capacity(xs_hz.len());
    for i in 0..xs_hz.len() {
        let f = xs_hz[i].max(1.0); // 0Hz対策
        let f_left = if i > 0 { xs_hz[i - 1].max(1.0) } else { f };
        let f_right = if i + 1 < xs_hz.len() {
            xs_hz[i + 1].max(1.0)
        } else {
            f
        };

        // log2 軸上の幅を近傍から推定
        let left = (f_left.log2() + f.log2()) * 0.5;
        let right = (f_right.log2() + f.log2()) * 0.5;
        let width = (right - left).abs().max(0.001);

        bars.push(
            Bar::new(f.log2() as f64, ys[i] as f64)
                .width(width as f64)
                .fill(egui::Color32::DARK_RED)
                .stroke(egui::Stroke::NONE),
        );
    }

    let chart = BarChart::new(y_label, bars);

    let min_x = xs_hz.iter().cloned().fold(f32::MAX, f32::min).max(1.0);
    let max_x = xs_hz.iter().cloned().fold(f32::MIN, f32::max);

    Plot::new(title)
        .height(150.0)
        .allow_scroll(false)
        .allow_drag(false)
        .include_y(y_min)
        .include_y(y_max)
        .include_x((min_x as f64).log2())
        .include_x((max_x as f64).log2())
        .x_axis_formatter(|mark, _range| {
            let hz = 2f64.powf(mark.value);
            if hz < 1000.0 {
                format!("{:.0} Hz", hz)
            } else {
                format!("{:.1} kHz", hz / 1000.0)
            }
        })
        .y_axis_formatter(|mark, _| format!("{:.2}", mark.value))
        .show(ui, |plot_ui| {
            plot_ui.bar_chart(chart);
        });
}

/// log₂スケールで周波数を描画する汎用プロット関数
pub fn log2_plot_hz(
    ui: &mut egui::Ui,
    title: &str,
    xs_hz: &[f32],
    ys: &[f32],
    y_label: &str,
    y_min: f64,
    y_max: f64,
) {
    assert_eq!(
        xs_hz.len(),
        ys.len(),
        "x/y length mismatch: {} vs {}",
        xs_hz.len(),
        ys.len()
    );

    // === X軸を log2(Hz) に変換 ===
    let points: PlotPoints = xs_hz
        .iter()
        .zip(ys.iter())
        .map(|(&xx, &yy)| [xx.log2() as f64, yy as f64])
        .collect();

    // === egui_plot用 Line オブジェクト ===
    let line = Line::new(y_label, points);

    // === X軸範囲（20〜20kHz）を log2に変換 ===
    let x_min = (10.0f64).log2();
    //let x_min = 1.0;
    let x_max = (24_000.0f64).log2();

    // === 描画 ===
    Plot::new(title)
        .height(160.0)
        .allow_scroll(false)
        .allow_drag(false)
        .include_x(x_min)
        .include_x(x_max)
        .include_y(y_min)
        .include_y(y_max)
        .x_grid_spacer(log_grid_spacer(10))
        .x_axis_formatter(|mark, _range| {
            let hz = 2f64.powf(mark.value);
            format!("{:.0}", hz)
        })
        .y_axis_formatter(|mark, _range| format!("{:.2}", mark.value))
        .show(ui, |plot_ui| {
            plot_ui.line(line);

            // === 任意: 半音ガイドライン ===
            // for note in 21..=108 {
            //     let f = 440.0 * 2f32.powf((note as f32 - 69.0) / 12.0);
            //     if (20.0..=20_000.0).contains(&f) {
            //         let x = (f as f64).log2();
            //         plot_ui.vline(egui_plot::VLine::new(x).color(egui::Color32::DARK_GRAY));
            //     }
            // }
        });
}

/// 波形表示（時間軸）
pub fn time_plot(ui: &mut egui::Ui, title: &str, fs: f64, samples: &[f32]) {
    let points: PlotPoints = samples
        .iter()
        .enumerate()
        .map(|(i, s)| [i as f64 / fs, *s as f64])
        .collect();
    let line = Line::new("wave", points);

    ui.vertical(|ui| {
        //ui.label(title);

        Plot::new(title)
            .height(150.0)
            .allow_scroll(false)
            .allow_drag(false)
            .x_axis_formatter(|mark, _| format!("{:.3} s", mark.value))
            .y_axis_formatter(|mark, _| format!("{:.2}", mark.value))
            .show(ui, |plot_ui| {
                plot_ui.line(line);
            });
    });
}
</file>

<file path="src/core/nsgt_rt.rs">
//! core/nsgt_rt.rs — Real-time NSGT with per-hop exponential smoothing
//!
//! Design
//! -----
//! - 1 hop = 1 FFT update. A ring buffer (length = nfft) holds the latest samples.
//! - Uses NsgtKernelLog2’s sparse frequency-domain kernels (no per-hop heap alloc).
//! - Per-band exponential integrator: y[n] = (1−α)x[n] + α y[n−1], α = exp(−dt/τ(f)).
//! - τ(f) is mapped low→slow, high→fast via simple f-dependent rule.
//!
//! Notes
//! -----
//! - Instantaneous measure can be raw power |C_k|^2 or one-sided PSD (~power/Hz).
//! - `process_hop()` accepts ≤ hop samples (short reads are zero-padded) or
//!   > hop (multiple hops processed); returns the last envelope slice.
//! - No per-hop allocations; FFT and scratch buffers are reused.

use crate::core::log2space::Log2Space;
use crate::core::nsgt_kernel::{KernelBand, NsgtKernelLog2};
use rustfft::{FftPlanner, num_complex::Complex32};
use std::sync::Arc;

/// Instantaneous measure used before smoothing.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum InstMeasure {
    /// Instantaneous band power: |C_k|^2 (no per-Hz normalization).
    RawPower,
    /// One-sided PSD-like measure: 2 * (|C_k|^2 / ENBW), ENBW for periodic Hann ≈ 1.5 * fs / L_k.
    PsdOneSided,
}

/// Smoothing configuration and instantaneous measure selection.
#[derive(Clone, Copy, Debug)]
pub struct RtConfig {
    /// τ at high frequencies [s].
    pub tau_min: f32,
    /// τ at low frequencies [s].
    pub tau_max: f32,
    /// Reference frequency for mapping τ(f) [Hz].
    pub f_ref: f32,
    /// Instantaneous measure type.
    pub measure: InstMeasure,
}

impl Default for RtConfig {
    fn default() -> Self {
        Self {
            tau_min: 0.03,
            tau_max: 0.30,
            f_ref: 200.0,
            measure: InstMeasure::RawPower,
        }
    }
}

/// Per-band persistent state.
#[derive(Clone, Debug)]
pub struct BandState {
    /// Center frequency [Hz].
    pub f_hz: f32,
    /// Time constant [s].
    pub tau: f32,
    /// α = exp(−dt/τ).
    pub alpha: f32,
    /// ENBW [Hz] (periodic Hann ≈ 1.5*fs/Lk).
    pub enbw_hz: f32,
    /// Smoothed envelope (running state).
    pub smooth: f32,
}

/// Real-time kernel analyzer with per-hop update and leaky integration.
#[derive(Clone)]
pub struct RtNsgtKernelLog2 {
    // analysis core
    nsgt: NsgtKernelLog2,
    fs: f32,
    nfft: usize,
    hop: usize,
    dt: f32,

    // runtime buffers (no per-hop alloc)
    ring: Vec<f32>,
    write_pos: usize, // next position to write
    fft: Arc<dyn rustfft::Fft<f32>>,
    fft_buf: Vec<Complex32>,

    // per-band states & cached meta
    bands_state: Vec<BandState>,
    out_env: Vec<f32>,

    // settings
    measure: InstMeasure,
}

impl RtNsgtKernelLog2 {
    /// Construct with default RtConfig.
    pub fn new(nsgt: NsgtKernelLog2) -> Self {
        Self::with_config(nsgt, RtConfig::default())
    }

    /// Construct with explicit RtConfig.
    pub fn with_config(nsgt: NsgtKernelLog2, cfg: RtConfig) -> Self {
        let fs = nsgt.cfg.fs;
        let nfft = nsgt.nfft();
        let hop = nsgt.hop();
        let dt = hop as f32 / fs;

        // Our own FFT plan (no per-hop allocation; same size as nsgt).
        let mut planner = FftPlanner::<f32>::new();
        let fft = planner.plan_fft_forward(nfft);

        // Build band states (τ mapping and ENBW precompute).
        let bands_state = nsgt
            .bands()
            .iter()
            .map(|b| {
                let f = b.f_hz.max(1e-6); // guard for f=0
                let ratio = (cfg.f_ref / f).clamp(0.0, 1.0);
                let mut tau = cfg.tau_min + (cfg.tau_max - cfg.tau_min) * ratio;
                tau = tau.clamp(cfg.tau_min, cfg.tau_max);
                let alpha = (-dt / tau).exp();
                let enbw_hz = 1.5_f32 * fs / (b.win_len as f32);
                BandState {
                    f_hz: b.f_hz,
                    tau,
                    alpha,
                    enbw_hz,
                    smooth: 0.0,
                }
            })
            .collect::<Vec<_>>();

        Self {
            nsgt,
            fs,
            nfft,
            hop,
            dt,
            ring: vec![0.0; nfft],
            write_pos: 0,
            fft,
            fft_buf: vec![Complex32::new(0.0, 0.0); nfft],
            out_env: vec![0.0; bands_state.len()],
            bands_state,
            measure: cfg.measure,
        }
    }

    /// Push one hop of audio and return the smoothed envelope slice.
    ///
    /// - If `hop_in.len() == hop()`: normal per-hop update.
    /// - If shorter: zero-padded and still one update.
    /// - If longer: processes multiple hops internally; returns the last envelope.
    pub fn process_hop(&mut self, hop_in: &[f32]) -> &[f32] {
        if hop_in.len() <= self.hop {
            self.write_hop_zero_padded(hop_in);
            self.analyze_one_and_update();
            &self.out_env
        } else {
            // Process multiple hops
            let mut i = 0usize;
            while i + self.hop <= hop_in.len() {
                self.write_hop(&hop_in[i..i + self.hop]);
                self.analyze_one_and_update();
                i += self.hop;
            }
            if i < hop_in.len() {
                self.write_hop_zero_padded(&hop_in[i..]);
                self.analyze_one_and_update();
            }
            &self.out_env
        }
    }

    /// Process an arbitrary block and emit per-hop envelopes via callback.
    pub fn process_block_emit<F: FnMut(&[f32])>(&mut self, block: &[f32], mut emit: F) {
        let mut i = 0usize;
        while i + self.hop <= block.len() {
            self.write_hop(&block[i..i + self.hop]);
            self.analyze_one_and_update();
            emit(&self.out_env);
            i += self.hop;
        }
        if i < block.len() {
            self.write_hop_zero_padded(&block[i..]);
            self.analyze_one_and_update();
            emit(&self.out_env);
        }
    }

    /// Current smoothed envelope without processing new samples.
    #[inline]
    pub fn current_envelope(&self) -> &[f32] {
        &self.out_env
    }

    /// Accessors
    #[inline]
    pub fn hop(&self) -> usize {
        self.hop
    }
    #[inline]
    pub fn dt(&self) -> f32 {
        self.dt
    }
    #[inline]
    pub fn fs(&self) -> f32 {
        self.fs
    }
    #[inline]
    pub fn nfft(&self) -> usize {
        self.nfft
    }
    /// Center frequencies [Hz].
    pub fn freqs(&self) -> Vec<f32> {
        self.nsgt.bands().iter().map(|b| b.f_hz).collect()
    }
    /// Underlying log2 space.
    #[inline]
    pub fn space(&self) -> &Log2Space {
        self.nsgt.space()
    }

    /// Change measure (raw power / PSD) on the fly.
    pub fn set_measure(&mut self, m: InstMeasure) {
        self.measure = m;
    }

    /// Reconfigure τ mapping and recompute α (no allocation).
    pub fn reconfigure_smoothing(&mut self, tau_min: f32, tau_max: f32, f_ref: f32) {
        let tau_min = tau_min.max(1e-6);
        let tau_max = tau_max.max(tau_min);
        for (b, st) in self.nsgt.bands().iter().zip(self.bands_state.iter_mut()) {
            let f = b.f_hz.max(1e-6);
            let ratio = (f_ref / f).clamp(0.0, 1.0);
            let mut tau = tau_min + (tau_max - tau_min) * ratio;
            tau = tau.clamp(tau_min, tau_max);
            st.tau = tau;
            st.alpha = (-self.dt / tau).exp();
        }
    }

    /// Reset smoothing states and ring buffer.
    pub fn reset(&mut self) {
        for st in &mut self.bands_state {
            st.smooth = 0.0;
        }
        for x in &mut self.ring {
            *x = 0.0;
        }
        self.write_pos = 0;
        for z in &mut self.fft_buf {
            *z = Complex32::new(0.0, 0.0);
        }
        for y in &mut self.out_env {
            *y = 0.0;
        }
    }

    // ---- internal helpers ----

    #[inline]
    fn write_hop(&mut self, hop_in: &[f32]) {
        debug_assert_eq!(hop_in.len(), self.hop);
        let n = self.nfft;
        let mut wp = self.write_pos;
        // write hop samples into the ring
        for &s in hop_in {
            self.ring[wp] = s;
            wp += 1;
            if wp == n {
                wp = 0;
            }
        }
        self.write_pos = wp;
    }

    #[inline]
    fn write_hop_zero_padded(&mut self, hop_in: &[f32]) {
        let n = self.nfft;
        let mut wp = self.write_pos;
        let mut i = 0usize;
        // copy provided samples
        while i < hop_in.len() {
            self.ring[wp] = hop_in[i];
            wp += 1;
            if wp == n {
                wp = 0;
            }
            i += 1;
        }
        // zero-pad the remainder
        while i < self.hop {
            self.ring[wp] = 0.0;
            wp += 1;
            if wp == n {
                wp = 0;
            }
            i += 1;
        }
        self.write_pos = wp;
    }

    /// Build contiguous FFT frame from ring, run FFT, accumulate bands, and update smoothing.
    fn analyze_one_and_update(&mut self) {
        // Reassemble latest nfft samples: [write_pos..end) then [0..write_pos)
        let n = self.nfft;
        let left = n - self.write_pos;

        // Fill fft_buf with real input (imag=0), then FFT.
        for i in 0..left {
            let s = self.ring[self.write_pos + i];
            self.fft_buf[i] = Complex32::new(s, 0.0);
        }
        for i in 0..self.write_pos {
            let s = self.ring[i];
            self.fft_buf[left + i] = Complex32::new(s, 0.0);
        }

        self.fft.process(&mut self.fft_buf);

        // Sparse inner products (same math as NsgtKernelLog2::analyze)
        let bands = self.nsgt.bands();
        for (bi, band) in bands.iter().enumerate() {
            let mut acc = Complex32::new(0.0, 0.0);
            // Σ X[k] * conj(K_k[k]) (already phase-compensated & conj in spec_conj_sparse)
            for &(k, w) in &band.spec_conj_sparse {
                // Safety: kernels are built for the same nfft.
                debug_assert!(k < self.fft_buf.len());
                acc += self.fft_buf[k] * w;
            }
            acc = acc / (n as f32);

            // Instantaneous measure
            let p = match self.measure {
                InstMeasure::RawPower => acc.norm_sqr(),
                InstMeasure::PsdOneSided => {
                    // 2 * power / ENBW (one-sided)
                    let enbw = self.bands_state[bi].enbw_hz.max(1e-12);
                    2.0 * (acc.norm_sqr() / enbw)
                }
            };

            // Exponential smoothing
            let st = &mut self.bands_state[bi];
            st.smooth = (1.0 - st.alpha) * p + st.alpha * st.smooth;
            self.out_env[bi] = st.smooth;
        }
    }
}
</file>

<file path="src/core/nsgt.rs">
//! core/nsgt.rs — Log2-axis Non-Stationary Gabor (analysis-only, Goertzel-based)
//!
//! Overview
//! --------
//! - Uses [`Log2Space`] grid between [fmin, fmax] with `bins_per_oct` resolution.
//! - Band-dependent window length: L_k = ceil(Q * fs / f_k), Q = 1/(2^(1/B)-1).
//! - Analysis via windowed Goertzel per band & frame.
//!
//! Notes
//! -----
//! - Analysis-only (no dual frames yet).
//! - Designed for Conchordal: downstream modules use log2-axis envelopes or analytic signals.
//! - Window: periodic Hann, overlap ≥ 50% recommended.
//!
//! Performance
//! -----------
//! - Goertzel avoids per-frame FFT overhead, efficient for sparse-band constant-Q.
//! - Dense or long-window use cases may prefer batched FFT (TODO).

use crate::core::log2space::Log2Space;
use rustfft::num_complex::Complex32;

// =====================================================
// Config structures
// =====================================================

/// NSGT configuration (log2-axis, analysis-only).
#[derive(Clone, Copy, Debug)]
pub struct NsgtLog2Config {
    /// Sampling rate [Hz]
    pub fs: f32,
    /// Overlap ratio in [0, 0.95). 0.5 = 50% overlap (default-good)
    pub overlap: f32,
}

impl Default for NsgtLog2Config {
    fn default() -> Self {
        Self {
            fs: 48_000.0,
            overlap: 0.5,
        }
    }
}

/// Band descriptor on log2 axis.
#[derive(Clone, Debug)]
pub struct NsgtBand {
    pub f_hz: f32,
    pub win_len: usize,
    pub hop: usize,
    pub window: Vec<f32>,
    pub log2_hz: f32,
    pub q: f32,
}

/// Analysis result for one band.
#[derive(Clone, Debug)]
pub struct BandCoeffs {
    pub coeffs: Vec<Complex32>,
    pub t_sec: Vec<f32>,
    pub f_hz: f32,
    pub log2_hz: f32,
    pub win_len: usize,
    pub hop: usize,
}

// =====================================================
// Analyzer core
// =====================================================

#[derive(Clone, Debug)]
pub struct NsgtLog2 {
    pub cfg: NsgtLog2Config,
    pub bands: Vec<NsgtBand>,
    pub space: Log2Space,
}

impl NsgtLog2 {
    /// Construct analyzer with log2-spaced bands and band-dependent windows.
    pub fn new(cfg: NsgtLog2Config, space: Log2Space) -> Self {
        assert!(
            cfg.overlap >= 0.0 && cfg.overlap < 0.95,
            "Overlap must be in [0,0.95)"
        );

        let fs = cfg.fs;
        let bpo = space.bins_per_oct as f32;
        let q = 1.0 / (2f32.powf(1.0 / bpo) - 1.0);

        // --- use given log2-space to define band centers
        let bands: Vec<NsgtBand> = space
            .centers_hz
            .iter()
            .zip(space.centers_log2.iter())
            .map(|(&f, &log2_f)| {
                let mut win_len = (q * fs / f).ceil() as usize;
                win_len = win_len.max(16);
                if win_len % 2 == 0 {
                    win_len += 1;
                }
                let hop = ((1.0 - cfg.overlap) * win_len as f32).round().max(1.0) as usize;
                let window = hann_periodic(win_len);
                NsgtBand {
                    f_hz: f,
                    win_len,
                    hop,
                    window,
                    log2_hz: log2_f,
                    q,
                }
            })
            .collect();

        Self {
            cfg,
            bands,
            space: space.clone(),
        }
    }

    pub fn bands(&self) -> &[NsgtBand] {
        &self.bands
    }

    pub fn space(&self) -> &Log2Space {
        &self.space
    }

    pub fn freqs_hz(&self) -> Vec<f32> {
        self.space.centers_hz.clone()
    }

    pub fn hop_s(&self) -> f32 {
        let mean_hop =
            self.bands.iter().map(|b| b.hop as f32).sum::<f32>() / self.bands.len().max(1) as f32;
        mean_hop / self.cfg.fs
    }

    /// Full NSGT analysis returning complex coefficients per band.
    pub fn analyze(&self, signal: &[f32]) -> Vec<BandCoeffs> {
        let n = signal.len();
        if n == 0 {
            return Vec::new();
        }
        let fs = self.cfg.fs;
        let mut out = Vec::with_capacity(self.bands.len());
        for b in &self.bands {
            let (coeffs, t_idx) = analyze_band_goertzel(signal, fs, b);
            let t_sec = t_idx.into_iter().map(|i| i as f32 / fs).collect();
            out.push(BandCoeffs {
                coeffs,
                t_sec,
                f_hz: b.f_hz,
                log2_hz: b.log2_hz,
                win_len: b.win_len,
                hop: b.hop,
            });
        }
        out
    }

    /// Mean envelope magnitude per band (for potential-R roughness kernels).
    pub fn analyze_envelope(&self, signal: &[f32]) -> Vec<f32> {
        let bands = self.analyze(signal);
        let amps: Vec<f32> = bands
            .iter()
            .map(|b| {
                if b.coeffs.is_empty() {
                    0.0
                } else {
                    b.coeffs.iter().map(|z| z.norm()).sum::<f32>() / b.coeffs.len() as f32
                }
            })
            .collect();
        amps
    }

    /// Representative analytic vector per band (for potential-C consonance kernels).
    pub fn analyze_flattened(&self, signal: &[f32]) -> Vec<Complex32> {
        self.analyze(signal)
            .iter()
            .filter_map(|b| b.coeffs.get(b.coeffs.len() / 2).copied())
            .collect()
    }

    /// Compute PSD-like estimate from an existing `analyze()` result.
    pub fn analyze_psd_from_bands(&self, bands: &[BandCoeffs]) -> Vec<f32> {
        if bands.is_empty() {
            return Vec::new();
        }

        let fs = self.cfg.fs;
        let mut psd_vals = Vec::with_capacity(bands.len());

        for b in bands {
            if b.coeffs.is_empty() {
                psd_vals.push(0.0);
                continue;
            }

            // (1) mean power
            let mean_pow =
                b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / (b.coeffs.len().max(1) as f32);

            // (2) bandwidth
            let bw_hz = self.space.bandwidth_hz(b.f_hz);

            // (3) moderate correction → multiply by sqrt(Δf)
            let psd_adj = mean_pow * bw_hz.sqrt();

            psd_vals.push(psd_adj);
        }

        psd_vals
    }

    /// Convenience version: run full analysis and return PSD directly.
    pub fn analyze_psd(&self, signal: &[f32]) -> Vec<f32> {
        let bands = self.analyze(signal);
        self.analyze_psd_from_bands(&bands)
    }
}

// =====================================================
// Internal utilities
// =====================================================

fn hann_periodic(n: usize) -> Vec<f32> {
    (0..n)
        .map(|i| 0.5 * (1.0 - (2.0 * std::f32::consts::PI * (i as f32) / n as f32).cos()))
        .collect()
}

// /// Windowed Goertzel per band across time.
fn analyze_band_goertzel(x: &[f32], fs: f32, band: &NsgtBand) -> (Vec<Complex32>, Vec<usize>) {
    let n = x.len();
    let L = band.win_len;
    let h = band.hop;
    let f = band.f_hz;
    let omega = 2.0 * std::f32::consts::PI * f / fs;

    let mut centers = Vec::new();
    let mut c = L / 2;
    while c + L / 2 <= n + (L / 2) {
        centers.push(c);
        c += h;
        if c == 0 {
            break;
        }
    }

    let mut coeffs = Vec::with_capacity(centers.len());
    for &c in &centers {
        let start = c.saturating_sub(L / 2);
        let mut acc_re = 0.0;
        let mut acc_im = 0.0;
        for i in 0..L {
            let xi = if start + i < n { x[start + i] } else { 0.0 };
            let w = band.window[i];
            let ph = omega * (start + i) as f32;
            acc_re += xi * w * ph.cos();
            acc_im -= xi * w * ph.sin();
        }
        let norm = (2.0 / L as f32).sqrt();
        coeffs.push(Complex32::new(acc_re * norm, acc_im * norm));
    }
    (coeffs, centers)
}

// =====================================================
// Tests
// =====================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::log2space::Log2Space;
    use approx::assert_relative_eq;

    fn mk_sine(fs: f32, f: f32, secs: f32) -> Vec<f32> {
        let n = (fs * secs).round() as usize;
        (0..n)
            .map(|i| (2.0 * std::f32::consts::PI * f * (i as f32) / fs).sin())
            .collect()
    }

    #[test]
    fn pure_tone_hits_right_band() {
        let fs = 48_000.0;
        let nsgt = NsgtLog2::new(
            NsgtLog2Config { fs, overlap: 0.5 },
            Log2Space::new(20.0, 8000.0, 48),
        );
        let sig = mk_sine(fs, 440.0, 1.0);
        let bands = nsgt.analyze(&sig);

        let (mut best_f, mut best_val) = (0.0, 0.0);
        for b in &bands {
            let p =
                b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / (b.coeffs.len().max(1) as f32);
            if p > best_val {
                best_val = p;
                best_f = b.f_hz;
            }
        }
        let cents = 1200.0 * ((best_f / 440.0).log2().abs());
        assert!(
            cents < 60.0,
            "440Hz peak band off by {:.1} cents (f={:.2})",
            cents,
            best_f
        );
    }

    #[test]
    fn window_len_monotonic_vs_freq() {
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 48));
        for w in nsgt.bands.windows(2) {
            if w[0].f_hz < w[1].f_hz {
                assert!(w[0].win_len >= w[1].win_len);
            }
        }
    }

    #[test]
    fn empty_signal_returns_empty() {
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 48));
        let out = nsgt.analyze(&[]);
        assert!(out.is_empty());
    }

    #[test]
    fn low_vs_high_freq_energy_scaling() {
        let fs = 48000.0;
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig_low = mk_sine(fs, 220.0, 1.0);
        let sig_high = mk_sine(fs, 1760.0, 1.0);
        let p_low = nsgt
            .analyze(&sig_low)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let p_high = nsgt
            .analyze(&sig_high)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let ratio = p_high / p_low;
        assert_relative_eq!(ratio, 1.0, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn amplitude_linearity() {
        let fs = 48000.0;
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig1 = mk_sine(fs, 440.0, 1.0);
        let sig2: Vec<f32> = sig1.iter().map(|v| v * 2.0).collect();

        let e1 = nsgt
            .analyze(&sig1)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        let e2 = nsgt
            .analyze(&sig2)
            .iter()
            .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
            .sum::<f32>();
        assert_relative_eq!(e2 / e1, 4.0, epsilon = 0.1, max_relative = 0.1);
    }
    #[test]
    fn time_invariance_of_magnitude() {
        let fs = 48000.0;
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let sig = mk_sine(fs, 440.0, 1.0);
        let shift = (0.1 * fs) as usize;
        let mut sig_shifted = vec![0.0; shift];
        sig_shifted.extend_from_slice(&sig);

        let amp1 = nsgt.analyze_envelope(&sig);
        let amp2 = nsgt.analyze_envelope(&sig_shifted);
        let corr: f32 = amp1.iter().zip(&amp2).map(|(a, b)| a * b).sum::<f32>()
            / (amp1.iter().map(|a| a * a).sum::<f32>().sqrt()
                * amp2.iter().map(|b| b * b).sum::<f32>().sqrt());
        assert!(
            corr > 0.95,
            "Magnitude envelope correlation should be high (corr={corr:.3})"
        );
    }

    #[test]
    fn hop_size_stability() {
        let fs = 48000.0;
        let space = Log2Space::new(20.0, 8000.0, 96);
        let sig = mk_sine(fs, 440.0, 1.0);

        let e_mean = |overlap: f32| {
            let nsgt = NsgtLog2::new(NsgtLog2Config { fs, overlap }, space.clone());
            let out = nsgt.analyze(&sig);
            let sum_e: f32 = out
                .iter()
                .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
                .sum();
            let n_frames: usize = out.iter().map(|b| b.coeffs.len()).max().unwrap_or(1);
            sum_e / n_frames as f32
        };

        let e_half = e_mean(0.5);
        let e_75 = e_mean(0.75);

        assert_relative_eq!(e_half, e_75, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn band_count_matches_space() {
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtLog2::new(NsgtLog2Config::default(), space.clone());
        assert_eq!(
            nsgt.bands().len(),
            space.centers_hz.len(),
            "Band count must match Log2Space bin count"
        );
    }

    // #[test]
    // #[ignore]
    // fn plot_nsgt_spectrum() {
    //     use plotters::prelude::*;

    //     let fs = 48000.0;
    //     let nsgt = NsgtLog2::new(
    //         NsgtLog2Config { fs, overlap: 0.5 },
    //         Log2Space::new(20.0, 8000.0, 96),
    //     );

    //     // === 1. テスト信号（純音440Hz） ===
    //     let sig = mk_sine(fs, 440.0, 1.0);

    //     // === 2. NSGT解析 ===
    //     let bands = nsgt.analyze(&sig);

    //     // === 3. 各バンドの平均エネルギーをlog2軸で取得 ===
    //     let points: Vec<(f32, f32)> = bands
    //         .iter()
    //         .map(|b| {
    //             let p = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
    //                 / (b.coeffs.len().max(1) as f32);
    //             (b.log2_hz, p)
    //         })
    //         .collect();

    //     // === 4. 出力先 ===
    //     let root = BitMapBackend::new("target/nsgt_spectrum.png", (1500, 1000)).into_drawing_area();
    //     root.fill(&WHITE).unwrap();
    //     let mut chart = ChartBuilder::on(&root)
    //         .caption("NSGT Spectrum (pure 440Hz)", ("sans-serif", 18))
    //         .margin(10)
    //         .x_label_area_size(40)
    //         .y_label_area_size(50)
    //         .build_cartesian_2d(
    //             (20f32.log2())..(8000f32.log2()),
    //             0f32..points.iter().map(|(_, p)| *p).fold(0.0f32, f32::max) * 1.1,
    //         )
    //         .unwrap();

    //     chart
    //         .configure_mesh()
    //         .x_desc("log2(frequency) [oct]")
    //         .y_desc("mean power")
    //         .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
    //         .draw()
    //         .unwrap();

    //     chart
    //         .draw_series(LineSeries::new(points.iter().cloned(), &BLUE))
    //         .unwrap()
    //         .label("power")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &BLUE));

    //     chart
    //         .configure_series_labels()
    //         .border_style(&BLACK)
    //         .draw()
    //         .unwrap();
    //     root.present().unwrap();

    //     println!("Saved plot to target/nsgt_spectrum.png");
    // }

    // #[test]
    // #[ignore]
    // fn plot_nsgt_log2_noise_response() {
    //     use plotters::prelude::*;
    //     use rand::Rng;
    //     use scirs2_signal::waveforms::{brown_noise, pink_noise};

    //     let fs = 48_000.0;
    //     let secs = 4.0;
    //     let n = (fs * secs) as usize;

    //     // === 1. NSGT設定 ===
    //     let nsgt = NsgtLog2::new(
    //         NsgtLog2Config { fs, overlap: 0.5 },
    //         Log2Space::new(35.0, 24_000.0, 96),
    //     );

    //     // === 2. ノイズ生成 ===
    //     let mut rng = rand::rng();
    //     let white: Vec<f32> = (0..n).map(|_| rng.random_range(-1.0f32..1.0)).collect();
    //     let pink: Vec<f32> = pink_noise(n, Some(42))
    //         .unwrap()
    //         .iter()
    //         .map(|&v| v as f32)
    //         .collect();
    //     let brown: Vec<f32> = brown_noise(n, Some(42))
    //         .unwrap()
    //         .iter()
    //         .map(|&v| v as f32)
    //         .collect();

    //     // === 3. フル解析 ===
    //     let bands_w = nsgt.analyze(&white);
    //     let bands_p = nsgt.analyze(&pink);
    //     let bands_b = nsgt.analyze(&brown);

    //     // === 4. PSD正規化処理 (power per Hz) ===
    //     let psd_norm = |bands: &[BandCoeffs]| -> Vec<f32> {
    //         bands
    //             .iter()
    //             .map(|b| {
    //                 let mean_pow = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
    //                     / (b.coeffs.len().max(1) as f32);
    //                 let bw = nsgt
    //                     .space()
    //                     .delta_hz_at(b.f_hz)
    //                     .unwrap_or(fs / (b.win_len as f32));
    //                 mean_pow / bw.max(1e-9)
    //             })
    //             .collect()
    //     };

    //     let psd_w = psd_norm(&bands_w);
    //     let psd_p = psd_norm(&bands_p);
    //     let psd_b = psd_norm(&bands_b);

    //     // === 5. 対数化 [dB re power/Hz] ===
    //     let to_db =
    //         |x: &[f32]| -> Vec<f32> { x.iter().map(|v| 10.0 * v.max(1e-20).log10()).collect() };
    //     let white_db = to_db(&psd_w);
    //     let pink_db = to_db(&psd_p);
    //     let brown_db = to_db(&psd_b);
    //     let log2x = nsgt.space().centers_log2.clone();

    //     // === 6. 出力 ===
    //     let root =
    //         BitMapBackend::new("target/nsgt_noise_psd_db.png", (1500, 1000)).into_drawing_area();
    //     root.fill(&WHITE).unwrap();

    //     let y_min = white_db
    //         .iter()
    //         .chain(&pink_db)
    //         .chain(&brown_db)
    //         .cloned()
    //         .fold(f32::INFINITY, f32::min);
    //     let y_max = white_db
    //         .iter()
    //         .chain(&pink_db)
    //         .chain(&brown_db)
    //         .cloned()
    //         .fold(f32::NEG_INFINITY, f32::max);

    //     let mut chart = ChartBuilder::on(&root)
    //         .caption("NSGT PSD (White / Pink / Brown Noise)", ("sans-serif", 18))
    //         .margin(10)
    //         .x_label_area_size(40)
    //         .y_label_area_size(60)
    //         .build_cartesian_2d(
    //             (20f32.log2())..(24_000f32.log2()),
    //             (y_min - 10.0)..(y_max + 10.0),
    //         )
    //         .unwrap();

    //     chart
    //         .configure_mesh()
    //         .x_desc("log2(frequency) [oct]")
    //         .y_desc("Power Spectral Density [dB re 1/Hz]")
    //         .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
    //         .draw()
    //         .unwrap();

    //     // === 7. プロット ===
    //     chart
    //         .draw_series(LineSeries::new(
    //             log2x.iter().cloned().zip(white_db.iter().cloned()),
    //             &BLUE,
    //         ))
    //         .unwrap()
    //         .label("White")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &BLUE));

    //     chart
    //         .draw_series(LineSeries::new(
    //             log2x.iter().cloned().zip(pink_db.iter().cloned()),
    //             &RED,
    //         ))
    //         .unwrap()
    //         .label("Pink")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &RED));

    //     chart
    //         .draw_series(LineSeries::new(
    //             log2x.iter().cloned().zip(brown_db.iter().cloned()),
    //             &GREEN,
    //         ))
    //         .unwrap()
    //         .label("Brown")
    //         .legend(|(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], &GREEN));

    //     chart
    //         .configure_series_labels()
    //         .border_style(&BLACK)
    //         .background_style(&WHITE.mix(0.8))
    //         .draw()
    //         .unwrap();

    //     root.present().unwrap();
    //     println!("Saved plot to target/nsgt_noise_psd_db.png");
    // }
}
</file>

<file path="src/core/fft.rs">
use rustfft::{FftPlanner, num_complex::Complex32};

/// Symmetric Hann window (offline/filter design)
/// w[i] = 0.5 * (1 - cos(2πi/(N-1)))
#[inline]
pub fn hann_window_symmetric(n: usize) -> Vec<f32> {
    match n {
        0 => Vec::new(),
        1 => vec![1.0],
        _ => {
            let two_pi = std::f32::consts::PI * 2.0;
            let denom = (n - 1) as f32;
            let mut w = Vec::with_capacity(n);
            for i in 0..n {
                let phi = two_pi * i as f32 / denom;
                w.push(0.5 * (1.0 - phi.cos()));
            }
            w
        }
    }
}

/// Periodic Hann window (for FFT/STFT, COLA)
/// w[i] = 0.5 * (1 - cos(2πi/N))
#[inline]
pub fn hann_window_periodic(n: usize) -> Vec<f32> {
    match n {
        0 => Vec::new(),
        1 => vec![1.0],
        _ => {
            let two_pi = std::f32::consts::PI * 2.0;
            let n_f = n as f32;
            let mut w = Vec::with_capacity(n);
            for i in 0..n {
                let phi = two_pi * i as f32 / n_f;
                w.push(0.5 * (1.0 - phi.cos()));
            }
            w
        }
    }
}

/// Apply Hann window to a real buffer.
/// Returns U = mean(w²) ≈ 3/8 for normalization.
pub fn apply_hann_window_real(buf: &mut [f32]) -> f32 {
    let n = buf.len();
    if n <= 1 {
        return 1.0;
    }

    let win = hann_window_periodic(n);
    let mut sum_sq = 0.0;
    for (x, &w) in buf.iter_mut().zip(&win) {
        *x *= w;
        sum_sq += w * w;
    }
    sum_sq / n as f32
}

/// Apply Hann window to a complex buffer.
/// Returns Welch factor U = Σw² / N.
pub fn apply_hann_window_complex(buf: &mut [Complex32]) -> f32 {
    let n = buf.len();
    if n <= 1 {
        return 1.0;
    }
    let win = hann_window_periodic(n);
    let mut sum_sq = 0.0;
    for (x, &w) in buf.iter_mut().zip(&win) {
        *x *= w;
        sum_sq += w * w;
    }
    sum_sq / n as f32
}

// ======================================================================
// Inverse STFT (OLA-based)
// ======================================================================

pub struct ISTFT {
    pub n: usize,
    pub hop: usize,
    pub window: Vec<f32>,
    ifft: std::sync::Arc<dyn rustfft::Fft<f32>>,
    tmp: Vec<Complex32>,
    ola_buffer: Vec<f32>,
    write_pos: usize,
}

impl ISTFT {
    pub fn new(n: usize, hop: usize) -> Self {
        assert!(hop == n / 2);
        let mut planner = FftPlanner::<f32>::new();
        let ifft = planner.plan_fft_inverse(n);
        let window = hann_window_periodic(n);

        Self {
            n,
            hop,
            window,
            ifft,
            tmp: vec![Complex32::new(0.0, 0.0); n],
            ola_buffer: vec![0.0; n],
            write_pos: 0,
        }
    }

    pub fn process(&mut self, spec_half: &[Complex32]) -> Vec<f32> {
        let n = self.n;
        assert_eq!(spec_half.len(), n / 2 + 1);

        // Reconstruct Hermitian symmetry
        for k in 0..=n / 2 {
            self.tmp[k] = spec_half[k];
        }
        for k in 1..n / 2 {
            self.tmp[n - k] = self.tmp[k].conj();
        }

        // IFFT
        self.ifft.process(&mut self.tmp);
        let inv_n = 1.0 / n as f32;

        // Apply window
        let mut win_frame = vec![0.0f32; n];
        for i in 0..n {
            win_frame[i] = self.tmp[i].re * inv_n * self.window[i];
        }

        // Overlap-add
        for i in 0..n {
            let idx = (self.write_pos + i) % n;
            self.ola_buffer[idx] += win_frame[i];
        }
        self.write_pos = (self.write_pos + self.hop) % n;

        // Output next hop
        let mut out = vec![0.0; self.hop];
        for i in 0..self.hop {
            let idx = (self.write_pos + i) % n;
            out[i] = self.ola_buffer[idx];
            self.ola_buffer[idx] = 0.0;
        }
        out
    }
}

// ======================================================================
// FFT-based convolution ("same" mode)
// ======================================================================

/// FFT convolution with "same" output length (SciPy-compatible).
pub fn fft_convolve_same(x: &[f32], h: &[f32]) -> Vec<f32> {
    let nx = x.len();
    let nh = h.len();
    if nx == 0 || nh == 0 {
        return Vec::new();
    }

    // Use direct convolution for small signals
    let direct_limit: usize = 16_384;
    if nx.saturating_mul(nh) <= direct_limit {
        return conv_same_direct(x, h);
    }

    // Linear convolution via FFT
    let n_full = nx + nh - 1;
    let n_fft = n_full.next_power_of_two();

    let mut xa = vec![Complex32::new(0.0, 0.0); n_fft];
    let mut hb = vec![Complex32::new(0.0, 0.0); n_fft];

    for (i, &v) in x.iter().enumerate() {
        xa[i].re = v;
    }
    for (i, &v) in h.iter().enumerate() {
        hb[i].re = v;
    }

    let mut planner = FftPlanner::<f32>::new();
    let fft = planner.plan_fft_forward(n_fft);
    let ifft = planner.plan_fft_inverse(n_fft);

    fft.process(&mut xa);
    fft.process(&mut hb);

    // Multiply spectra
    for i in 0..n_fft {
        xa[i] = xa[i] * hb[i];
    }

    // IFFT and scale
    ifft.process(&mut xa);
    let scale = 1.0 / n_fft as f32;

    let mut y_full = vec![0.0f32; n_full];
    for i in 0..n_full {
        y_full[i] = xa[i].re * scale;
    }

    // Crop "same" segment
    let start = (nh - 1) / 2;
    y_full[start..start + nx].to_vec()
}

#[inline]
fn conv_same_direct(x: &[f32], h: &[f32]) -> Vec<f32> {
    let nx = x.len();
    let nh = h.len();
    let n_full = nx + nh - 1;
    let mut y_full = vec![0.0f32; n_full];

    for i in 0..nx {
        let xi = x[i];
        for j in 0..nh {
            y_full[i + j] += xi * h[j];
        }
    }

    let start = (nh - 1) / 2;
    y_full[start..start + nx].to_vec()
}

pub fn linear_convolve_fft(a: &[f32], k: &[f32]) -> Vec<f32> {
    use rustfft::{FftPlanner, num_complex::Complex32};
    let n = a.len();
    let m = k.len();
    let l = (n + m - 1).next_power_of_two();
    let mut planner = FftPlanner::<f32>::new();
    let fft = planner.plan_fft_forward(l);
    let ifft = planner.plan_fft_inverse(l);

    let mut aspec = vec![Complex32::new(0.0, 0.0); l];
    let mut kspec = vec![Complex32::new(0.0, 0.0); l];
    for i in 0..n {
        aspec[i].re = a[i];
    }
    for i in 0..m {
        kspec[i].re = k[i];
    }

    fft.process(&mut aspec);
    fft.process(&mut kspec);
    for i in 0..l {
        aspec[i] *= kspec[i];
    }
    ifft.process(&mut aspec);

    let scale = 1.0 / (l as f32);
    let mut y = vec![0.0f32; n + m - 1];
    for i in 0..y.len() {
        y[i] = aspec[i].re * scale;
    }
    y
}

/// Compute analytic signal (Hilbert transform).
/// Returns complex output: real=input, imag=Hilbert(x).
pub fn hilbert(x: &[f32]) -> Vec<Complex32> {
    let n = x.len().next_power_of_two();
    let mut buf: Vec<Complex32> = x.iter().map(|&v| Complex32::new(v, 0.0)).collect();
    buf.resize(n, Complex32::new(0.0, 0.0));

    let mut planner = FftPlanner::new();
    let fft = planner.plan_fft_forward(n);
    let ifft = planner.plan_fft_inverse(n);

    // Forward FFT
    fft.process(&mut buf);

    // Frequency-domain multiplier
    let mut h = vec![Complex32::new(0.0, 0.0); n];
    if n > 0 {
        h[0] = Complex32::new(1.0, 0.0);
        if n % 2 == 0 {
            h[n / 2] = Complex32::new(1.0, 0.0);
            for k in 1..(n / 2) {
                h[k] = Complex32::new(2.0, 0.0);
            }
        } else {
            for k in 1..((n + 1) / 2) {
                h[k] = Complex32::new(2.0, 0.0);
            }
        }
    }

    // Apply H and inverse FFT
    for (z, &w) in buf.iter_mut().zip(&h) {
        *z *= w;
    }
    ifft.process(&mut buf);

    // Normalize
    let scale = 1.0 / n as f32;
    buf.iter_mut().for_each(|z| *z *= scale);

    buf
}

// ======================================================================
// Utility
// ======================================================================

pub fn bin_freqs_hz(fs: f32, n: usize) -> Vec<f32> {
    (0..=n / 2).map(|k| k as f32 * fs / n as f32).collect()
}

// ======================================================================
// Tests
// ======================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;
    use rustfft::num_complex::Complex32;

    // ----- helpers -----

    // Reference "same" via explicit linear convolution then crop.
    fn same_ref(x: &[f32], h: &[f32]) -> Vec<f32> {
        let n = x.len();
        let m = h.len();
        let mut full = vec![0.0f32; n + m - 1];
        for i in 0..n {
            let xi = x[i];
            for j in 0..m {
                full[i + j] += xi * h[j];
            }
        }
        let start = (m - 1) / 2;
        full[start..start + n].to_vec()
    }

    // ==============================
    // Hann window: symmetric/periodic
    // ==============================

    #[test]
    fn test_hann_window_symmetric_sum() {
        let n = 1024;
        let w = hann_window_symmetric(n);
        assert!(w.iter().all(|&v| v >= 0.0));

        // Endpoints ~0 (allow small FP drift)
        assert!(w.first().unwrap().abs() < 1e-5, "first sample not ~0");
        assert!(w.last().unwrap().abs() < 1e-5, "last sample not ~0");

        // Energy check: mean(w^2) ≈ 3/8
        let u: f32 = w.iter().map(|&x| x * x).sum::<f32>() / n as f32;
        assert!((u - 0.375).abs() < 1e-3, "mean-square mismatch: {u}");
    }

    #[test]
    fn hann_window_periodic_props() {
        use std::f32::consts::PI;
        let n = 1024;
        let w = hann_window_periodic(n);

        // Non-negative; first sample ~0
        assert!(w.iter().all(|&v| v >= 0.0));
        assert!(w[0].abs() < 1e-5, "first sample not ~0");

        // Last sample close to closed-form value
        let last_expected = 0.5 * (1.0 - (2.0 * PI * ((n as f32 - 1.0) / n as f32)).cos());
        assert!(
            (w[n - 1] - last_expected).abs() < 1e-4,
            "last sample diff too large: got {}, expected {}",
            w[n - 1],
            last_expected
        );

        // Welch power normalization U ≈ 3/8
        let u: f32 = w.iter().map(|&x| x * x).sum::<f32>() / n as f32;
        assert!(
            (u - 0.375).abs() < 0.001,
            "mean-square mismatch: {} (expected ~0.375)",
            u
        );

        // COLA (hop=N/2): overlap-add is ~flat
        let hop = n / 2;
        let mut sum = vec![0.0f32; n + hop];
        for i in 0..n {
            sum[i] += w[i];
            sum[i + hop] += w[i];
        }
        let mid = n / 2;
        let avg = sum[mid - 32..mid + 32].iter().sum::<f32>() / 64.0;
        assert!((avg - 1.0).abs() < 0.01, "OLA not flat enough: avg={avg}");
    }

    #[test]
    fn hann_window_periodic_mean_is_half() {
        // For the periodic Hann, mean(w) = 0.5 exactly in discrete-time.
        let n = 1024;
        let w = hann_window_periodic(n);
        let mean = w.iter().sum::<f32>() / n as f32;
        assert!((mean - 0.5).abs() < 1e-6, "mean={}", mean);
    }

    #[test]
    fn hann_window_periodic_pairwise_sum_is_one() {
        // For hop = N/2, w[i] + w[i+N/2] = 1 for all i (up to FP).
        let n = 1024;
        let hop = n / 2;
        let w = hann_window_periodic(n);
        let mut max_err = 0.0f32;
        for i in 0..hop {
            let err = (w[i] + w[i + hop] - 1.0).abs();
            if err > max_err {
                max_err = err;
            }
        }
        assert!(max_err < 1e-6, "max_err={}", max_err);
    }

    #[test]
    fn hann_window_small_n_edges() {
        // N=1 policy in this codebase: return [1.0]
        assert_eq!(hann_window_symmetric(1), vec![1.0]);
        assert_eq!(hann_window_periodic(1), vec![1.0]);

        // N=2: symmetric=[0,0]; periodic=[0,1]
        assert_eq!(hann_window_symmetric(2), vec![0.0, 0.0]);
        let w2p = hann_window_periodic(2);
        assert!(w2p[0].abs() < 1e-7);
        assert!((w2p[1] - 1.0).abs() < 1e-7);
    }

    // ==============================
    // Window application
    // ==============================

    #[test]
    fn apply_hann_window_complex_props() {
        let n = 1024usize;

        // Input: linear ramp in the real part
        let mut buf: Vec<Complex32> = (0..n)
            .map(|i| Complex32::new(i as f32 / n as f32, 0.0))
            .collect();

        // Recreate the same periodic Hann
        let w: Vec<f32> = (0..n)
            .map(|i| 0.5 * (1.0 - (2.0 * std::f32::consts::PI * i as f32 / n as f32).cos()))
            .collect();

        // Reference U = mean(w^2)
        let u_ref: f32 = w.iter().map(|&v| v * v).sum::<f32>() / n as f32;

        // Apply and get U
        let u = apply_hann_window_complex(&mut buf);
        assert!((u - u_ref).abs() < 1e-3, "U mismatch: got {u}, ref {u_ref}");

        // Compare mean square to exact discrete expectation
        let expected_mean_sq: f32 = (0..n)
            .map(|i| {
                let x = i as f32 / n as f32;
                (x * w[i]).powi(2)
            })
            .sum::<f32>()
            / n as f32;

        let mean_sq: f32 = buf.iter().map(|z| z.re * z.re).sum::<f32>() / n as f32;
        let rel_err = (mean_sq - expected_mean_sq).abs() / expected_mean_sq.max(1e-12);
        assert!(
            rel_err < 5e-3,
            "mean_sq={mean_sq}, expected={expected_mean_sq}, rel_err={rel_err:.3e}"
        );

        // Endpoints
        let last_expected = ((n - 1) as f32 / n as f32) * w[n - 1];
        assert!(buf[0].re.abs() < 1e-7, "start not ~0: {}", buf[0].re);
        let diff_end = (buf[n - 1].re - last_expected).abs();
        assert!(
            diff_end < 1e-5 || buf[n - 1].re == 0.0,
            "end mismatch: got {}, expected {}, diff={diff_end}",
            buf[n - 1].re,
            last_expected
        );

        // Hann is non-negative
        assert!(
            buf.iter().all(|z| z.re >= 0.0),
            "Negative real samples found"
        );
    }

    #[test]
    fn apply_hann_window_real_returns_mean_square() {
        // For a buffer of ones, mean(x·w)^2 equals mean(w^2) = U.
        let n = 2048;
        let mut ones = vec![1.0f32; n];
        let u = apply_hann_window_real(&mut ones);
        let mean_sq: f32 = ones.iter().map(|&v| v * v).sum::<f32>() / n as f32;
        assert!((mean_sq - u).abs() < 1e-6, "mean_sq={}, U={}", mean_sq, u);
        assert!((u - 0.375).abs() < 1e-3);
    }

    // ==============================
    // FFT-based convolution ("same")
    // ==============================

    #[test]
    fn fft_convolve_same_impulse() {
        let x = vec![1.0, 0.0, 0.0, 0.0];
        let h = vec![0.0, 1.0, 0.0, 0.0];
        let y = fft_convolve_same(&x, &h);

        // Sum preserved (simple sanity)
        let sum_x: f32 = x.iter().sum();
        let sum_y: f32 = y.iter().sum();
        assert_relative_eq!(sum_x, sum_y, epsilon = 1e-6);

        // One peak, same length
        assert_eq!(y.len(), x.len());
        let max_i = y
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.total_cmp(b.1))
            .unwrap()
            .0;
        assert!(max_i < y.len());
    }

    #[test]
    fn fft_convolve_same_identity_with_centered_odd_kernel() {
        // With h = [0,1,0] (centered odd), "same" must equal x.
        let n = 64;
        let x: Vec<f32> = (0..n).map(|i| ((i as f32) * 0.1).sin()).collect();
        let h = vec![0.0, 1.0, 0.0];
        let y = fft_convolve_same(&x, &h);
        for (a, b) in y.iter().zip(x.iter()) {
            assert!((a - b).abs() < 1e-6);
        }
    }

    #[test]
    fn fft_convolve_same_matches_reference_small() {
        // Small sizes choose direct path; must match reference exactly.
        let n = 64;
        let m = 31; // odd
        let x: Vec<f32> = (0..n).map(|i| ((i as f32) * 0.013).sin()).collect();
        let h: Vec<f32> = (0..m).map(|i| ((i as f32) * 0.07).cos()).collect();

        let y = fft_convolve_same(&x, &h);
        let y_ref = same_ref(&x, &h);

        assert_eq!(y.len(), n);
        let max_err = y
            .iter()
            .zip(y_ref.iter())
            .map(|(a, b)| (a - b).abs())
            .fold(0.0, f32::max);
        assert!(max_err < 1e-6, "max_err={}", max_err);
    }

    #[test]
    fn fft_convolve_same_matches_reference_even_kernel() {
        // Even-length kernel; "same" cropping must still match reference.
        let n = 256;
        let m = 4; // even
        let x: Vec<f32> = (0..n).map(|i| ((i as f32) * 0.02).sin()).collect();
        let h = vec![0.25f32; m]; // simple box
        let y = fft_convolve_same(&x, &h);
        let y_ref = same_ref(&x, &h);

        let mae = y
            .iter()
            .zip(y_ref.iter())
            .map(|(a, b)| (a - b).abs())
            .sum::<f32>()
            / (n as f32);
        assert!(mae < 2e-6, "mae={}", mae);
    }

    #[test]
    fn fft_convolve_same_gaussian() {
        let n = 128;
        let mut g = vec![0.0; n];
        for i in 0..n {
            let x = (i as f32 - n as f32 / 2.0) / 10.0;
            g[i] = (-x * x).exp();
        }
        let y = fft_convolve_same(&g, &g);
        assert!(y[n / 2] > y[n / 4]); // center peak larger
    }

    #[test]
    fn fft_convolve_same_rect() {
        let x = vec![1.0; 32];
        let h = vec![1.0; 32];
        let y = fft_convolve_same(&x, &h);
        assert!(y.iter().all(|&v| v >= 0.0));
        let mid = y[y.len() / 2];
        assert!(mid > 10.0);
    }

    fn conv_naive(a: &[f32], b: &[f32]) -> Vec<f32> {
        let n = a.len();
        let m = b.len();
        let mut y = vec![0.0f32; n + m - 1];
        for i in 0..n {
            for j in 0..m {
                y[i + j] += a[i] * b[j];
            }
        }
        y
    }

    fn assert_close(a: &[f32], b: &[f32], tol: f32) {
        assert_eq!(
            a.len(),
            b.len(),
            "length mismatch: {} vs {}",
            a.len(),
            b.len()
        );
        for (i, (u, v)) in a.iter().zip(b.iter()).enumerate() {
            let d = (u - v).abs();
            assert!(
                d <= tol,
                "idx {} diff {} exceeds tol {}; u={}, v={}",
                i,
                d,
                tol,
                u,
                v
            );
        }
    }

    fn seq(len: usize, w1: f32, w2: f32) -> Vec<f32> {
        // deterministic, diverse values without RNG
        (0..len)
            .map(|i| {
                let x = i as f32;
                (x * w1).sin() + 0.25 * (x * w2).cos() + 0.1 * (x * (w1 + w2)).sin()
            })
            .collect()
    }

    #[test]
    fn length_and_values_match_naive_small_cases() {
        let cases = [
            (1usize, 1usize),
            (2, 3),
            (3, 2),
            (5, 5),
            (8, 13),
            (16, 7),
            (31, 9),
            (64, 33),
        ];
        for (n, m) in cases {
            let a = seq(n, 0.13, 0.07);
            let b = seq(m, 0.21, 0.05);
            let y_fft = linear_convolve_fft(&a, &b);
            let y_nv = conv_naive(&a, &b);
            assert_eq!(y_fft.len(), n + m - 1);
            assert_close(&y_fft, &y_nv, 1e-5);
        }
    }

    #[test]
    fn commutativity_holds() {
        let a = seq(37, 0.17, 0.11);
        let b = seq(23, 0.09, 0.06);
        let y_ab = linear_convolve_fft(&a, &b);
        let y_ba = linear_convolve_fft(&b, &a);
        assert_close(&y_ab, &y_ba, 1e-5);
    }

    #[test]
    fn impulse_and_shift() {
        // delta at 0 -> identity
        let b = seq(19, 0.12, 0.03);
        let y = linear_convolve_fft(&[1.0], &b);
        assert_close(&y, &b, 1e-6);

        // delta at index j -> right shift by j
        let j = 7usize;
        let mut a = vec![0.0f32; j + 1];
        a[j] = 1.0;
        let y = linear_convolve_fft(&a, &b);
        assert_eq!(y.len(), a.len() + b.len() - 1);
        // y[0..j] == 0
        assert!(y[..j].iter().all(|&v| v.abs() < 1e-6));
        // y[j..j+b.len()] == b
        assert_close(&y[j..j + b.len()], &b, 1e-6);
    }

    #[test]
    fn ones_rectangular_triangle() {
        // ones * ones -> triangle with plateau when lengths differ
        let a = vec![1.0f32; 5];
        let b = vec![1.0f32; 3];
        let y = linear_convolve_fft(&a, &b);
        let expected = vec![1.0, 2.0, 3.0, 3.0, 3.0, 2.0, 1.0];
        assert_close(&y, &expected, 1e-6);
    }

    #[test]
    fn primes_non_power_of_two_lengths_match_naive() {
        // hard case for FFT sizing and zero-padding
        let a = seq(97, 0.131, 0.071);
        let b = seq(113, 0.083, 0.047);
        let y_fft = linear_convolve_fft(&a, &b);
        let y_nv = conv_naive(&a, &b);
        assert_eq!(y_fft.len(), a.len() + b.len() - 1);
        assert_close(&y_fft, &y_nv, 2e-5);
    }

    #[test]
    fn zeros_propagate() {
        let a = vec![0.0f32; 17];
        let b = seq(9, 0.2, 0.15);
        let y = linear_convolve_fft(&a, &b);
        assert!(y.iter().all(|&v| v.abs() < 1e-7));
    }

    // ==============================
    // Hilbert transform
    // ==============================

    #[test]
    fn hilbert_signal_cosine() {
        use std::f32::consts::PI;

        let n = 1024; // power-of-two to match current implementation
        let freq = 5.0;
        let dt = 0.01;
        let signal: Vec<f32> = (0..n)
            .map(|i| (2.0 * PI * freq * i as f32 * dt).cos())
            .collect();

        let analytic = hilbert(&signal);
        assert_eq!(analytic.len(), signal.len());

        // Real part ≈ input
        let mse_real: f32 = signal
            .iter()
            .zip(analytic.iter())
            .map(|(a, b)| (a - b.re).powi(2))
            .sum::<f32>()
            / n as f32;
        assert!(mse_real < 1e-6, "Real part mismatch too large: {mse_real}");

        // Envelope ≈ 1 in the central region
        let start = n / 4;
        let end = 3 * n / 4;
        let avg_mag: f32 = analytic[start..end]
            .iter()
            .map(|c| (c.re.powi(2) + c.im.powi(2)).sqrt())
            .sum::<f32>()
            / (end - start) as f32;
        assert!((avg_mag - 1.0).abs() < 0.05, "Average magnitude {avg_mag}");
    }

    // ==============================
    // Utility
    // ==============================

    #[test]
    fn bin_freqs_hz_props() {
        let fs = 48000.0f32;
        let n = 1024usize;
        let f = bin_freqs_hz(fs, n);
        assert_eq!(f.len(), n / 2 + 1);
        assert!(f.windows(2).all(|w| w[1] > w[0]));
        assert!((f[0] - 0.0).abs() < 1e-12);
        assert!((f.last().unwrap() - fs / 2.0).abs() < 1e-6);
    }

    // ==============================
    // ISTFT (OLA)
    // ==============================

    #[test]
    fn istft_ola_dc_reconstruction_after_warmup() {
        // Feed pure-DC spectra; after one hop warmup, output should be ~1.0.
        let n = 1024;
        let hop = n / 2;
        let mut istft = ISTFT::new(n, hop);

        let mut out_all = Vec::new();
        for _ in 0..4 {
            let mut spec_half = vec![Complex32::new(0.0, 0.0); n / 2 + 1];
            // DC bin amplitude = n so that IFFT (1/n scaling) yields 1.0 samples.
            spec_half[0] = Complex32::new(n as f32, 0.0);
            out_all.extend(istft.process(&spec_half));
        }

        // Drop the first hop as warmup
        let steady = &out_all[hop..];
        let max_dev = steady.iter().map(|&v| (v - 1.0).abs()).fold(0.0, f32::max);
        assert!(max_dev < 2e-3, "max_dev={}", max_dev);
    }
}
</file>

<file path="Cargo.toml">
[package]
name = "conchordal"
version = "0.1.0"
edition = "2024"

[profile.dev]
opt-level = 1
debug = true
overflow-checks = true
incremental = true

[profile.release]
opt-level = 3
lto = true
#debug = true


[dependencies]
anyhow = "1.0"

itertools = "0.12"
clap = { version = "4.5", features = ["derive"]}
ctrlc = "3.4"

# GUI
eframe = "0.33"
egui = "0.33"
egui_plot = "0.34"

# Concurrency
rayon = "1.10"
crossbeam-channel = "0.5"

# DSP / Math
rustfft = "6"
ndarray = "0.15"
wide = "0.8"
rand = "0.9"

# Serde for future config
serde = { version = "1.0", features = ["derive"] }
ron = "0.8"

# Logging / tracing (optional)
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["fmt", "env-filter"] }

# Audio I/O
cpal = "0.15"
hound = "3.5"

ringbuf = "0.4"
approx = "0.5"

[dev-dependencies]
plotters = "0.3"
</file>

<file path="src/core/harmonicity_kernel.rs">
//! core/harmonicity_kernel.rs
//! Common Root (Sibling) Harmonicity Kernel on Log2Space.
//!
//! This implementation generates a consonance landscape based on the physiological
//! mechanism of "Common Root" detection (approximating autocorrelation).
//!
//! Algorithm: "Sibling Projection"
//! 1. **Downward Projection (Root Search)**:
//!    Estimate the "Virtual Root" spectrum from the environment.
//!    If energy exists at f, it implies potential roots at f/2, f/3...
//!    (e.g., Env 200Hz -> Roots at 100Hz, 66Hz...)
//!
//! 2. **Upward Projection (Harmonic Resonance)**:
//!    From the estimated roots, project their natural harmonics.
//!    (e.g., Root 100Hz -> Stability at 100Hz, 200Hz, 300Hz, 400Hz...)
//!
//! Result:
//! An input of 200Hz naturally creates stability peaks at:
//! - 100Hz (Subharmonic)
//! - 400Hz (Octave)
//! - 300Hz (Perfect 5th via 100Hz root)
//! - 500Hz (Major 3rd via 100Hz root)
//! ...without using any hardcoded ratio templates.

//! core/harmonicity_kernel.rs
//! Optimized Sibling Harmonicity Kernel.
//!
//! Uses a "Shift-and-Add" approach with pre-calculated bounds
//! to ensure O(N) efficiency and SIMD-friendly loops.

use crate::core::log2space::Log2Space;

#[derive(Clone, Copy, Debug)]
pub struct HarmonicityParams {
    pub num_subharmonics: u32,
    pub num_harmonics: u32,
    pub rho_sub: f32,
    pub rho_harm: f32,
    pub sigma_cents: f32,
    pub normalize_output: bool,
    pub freq_gate: bool,
    pub tfs_f_pl_hz: f32,
    pub tfs_eta: f32,
}

impl Default for HarmonicityParams {
    fn default() -> Self {
        Self {
            num_subharmonics: 12,
            num_harmonics: 12,
            rho_sub: 0.75,
            rho_harm: 0.5,
            sigma_cents: 2.0, // Sharp precision for phase locking
            normalize_output: true,
            freq_gate: false,
            tfs_f_pl_hz: 4500.0,
            tfs_eta: 4.0,
        }
    }
}

#[derive(Clone, Debug)]
pub struct HarmonicityKernel {
    pub bins_per_oct: u32,
    pub params: HarmonicityParams,
    smooth_kernel: Vec<f32>,
    pad_bins: usize, // Internal padding size
}

impl HarmonicityKernel {
    pub fn new(space: &Log2Space, params: HarmonicityParams) -> Self {
        // 1. Pre-calculate smoothing kernel
        let sigma_bins = params.sigma_cents / 1200.0 * space.bins_per_oct as f32;
        let half_width = (2.5 * sigma_bins).ceil() as usize;
        let width = 2 * half_width + 1;
        let mut k = vec![0.0f32; width];
        let mut sum = 0.0;
        for i in 0..width {
            let x = (i as isize - half_width as isize) as f32;
            k[i] = (-0.5 * (x / sigma_bins).powi(2)).exp();
            sum += k[i];
        }
        for v in &mut k {
            *v /= sum;
        }

        // 2. Pre-calculate necessary padding
        // How many bins down do we need to store the deepest root?
        let max_sub_oct = (params.num_subharmonics as f32).log2();
        let pad_bins = (max_sub_oct * space.bins_per_oct as f32).ceil() as usize;

        Self {
            bins_per_oct: space.bins_per_oct,
            params,
            smooth_kernel: k,
            pad_bins,
        }
    }

    /// The core function: Env -> Roots -> Landscape
    pub fn potential_h_from_log2_spectrum(
        &self,
        envelope: &[f32],
        space: &Log2Space,
    ) -> (Vec<f32>, f32) {
        let n_bins = envelope.len();
        let bins_per_oct = self.bins_per_oct as f32;

        // Step 0: Smooth Input (O(N))
        let smeared_env = self.convolve_smooth(envelope);

        // Buffer for Virtual Roots
        // Size = N + Padding (to hold roots below f_min)
        let mut root_spectrum = vec![0.0f32; n_bins + self.pad_bins];

        // Step 1: Downward Projection (Scatter Env into Roots)
        // Env[i] implies Root at Env[i - shift]
        // Since Root buffer has padding, Env[0] maps to Root[pad_bins].
        // So Env[i] maps to Root[pad_bins + i - shift].
        // Target Offset = pad_bins - shift.
        for k in 1..=self.params.num_subharmonics {
            let shift_bins = (k as f32).log2() * bins_per_oct;
            let weight = 1.0 / (k as f32).powf(self.params.rho_sub);

            // "Add smeared_env into root_spectrum at offset"
            let offset = self.pad_bins as f32 - shift_bins;
            Self::accumulate_shifted(&smeared_env, &mut root_spectrum, offset, weight);
        }

        // Step 2: Upward Projection (Gather Roots into Landscape)
        // Root[j] implies Harmonic at Root[j + shift]
        // Landscape[i] corresponds to Root[pad_bins + i].
        // So Landscape[i] gets energy from Root[pad_bins + i - shift].
        // Read Offset (in Root) = pad_bins - shift.
        // Or view it as: Shift Root buffer RIGHT by `shift`, then map to Landscape.
        // Let's use the Scatter view again for consistency:
        // We take the WHOLE root_spectrum and add it to Landscape? No, sizes differ.
        // It's cleaner to say: Landscape[i] += Root[pad_bins + i - shift].
        // This is equivalent to: Add `root_spectrum` into `landscape` with offset `- (pad_bins - shift)`.
        // Wait, easier: "Add Root into Landscape with offset `shift - pad_bins`".

        let mut landscape = vec![0.0f32; n_bins];

        for m in 1..=self.params.num_harmonics {
            let shift_bins = (m as f32).log2() * bins_per_oct;
            let weight = 1.0 / (m as f32).powf(self.params.rho_harm);

            // Mapping: Root[x] -> Land[x + shift - pad_bins]
            // We want to add `root_spectrum` into `landscape`.
            // The 0-th element of root_spectrum corresponds to frequency f_min / 2^pad.
            // The 0-th element of landscape corresponds to f_min.
            // The relative shift is: `shift - pad_bins`.
            let offset = shift_bins - self.pad_bins as f32;
            Self::accumulate_shifted(&root_spectrum, &mut landscape, offset, weight);
        }

        // Step 3: Post-processing
        let mut max_val = 1e-12;
        let do_gate = self.params.freq_gate;
        let do_norm = self.params.normalize_output;

        // Combined loop for gating and max-finding (Auto-vectorized)
        for i in 0..n_bins {
            let v = &mut landscape[i];
            if do_gate {
                *v *= Self::absfreq_gate(space.freq_of_index(i), &self.params);
            }
            if *v > max_val {
                max_val = *v;
            }
        }

        if do_norm {
            let scale = 1.0 / max_val;
            for v in &mut landscape {
                *v *= scale;
            }
            max_val = 1.0;
        }

        (landscape, max_val)
    }
    /// Optimized Shift-and-Add with safe bounds checking.
    /// dst[i + offset] += src[i] * weight
    fn accumulate_shifted(src: &[f32], dst: &mut [f32], offset: f32, weight: f32) {
        let offset_i = offset.floor() as isize;
        let frac = offset - offset_i as f32;
        let w0 = weight * (1.0 - frac);
        let w1 = weight * frac;

        // Calculate valid iteration range for 'i' (index in src)
        // Constraints:
        // 1. 0 <= i < src.len()
        // 2. 0 <= i + offset_i < dst.len() - 1 (Need space for w1 interpolation)

        // Lower bound: i >= 0 AND i >= -offset_i
        let start_i = 0.max(-offset_i);

        // Upper bound (exclusive): i < src.len() AND i < dst.len() - 1 - offset_i
        let end_i = (src.len() as isize).min(dst.len() as isize - 1 - offset_i);

        // If range is invalid/empty, do nothing
        if start_i >= end_i {
            return;
        }

        let start = start_i as usize;
        let len = (end_i - start_i) as usize;

        // Destination start index
        // Since start >= -offset_i, (start + offset_i) is guaranteed >= 0
        let dst_start = (start as isize + offset_i) as usize;

        // Create slices for the hot loop (avoids bounds check inside loop)
        let src_slice = &src[start..start + len];
        let dst_slice = &mut dst[dst_start..dst_start + len + 1];

        for (k, &val) in src_slice.iter().enumerate() {
            // Unsafe get_unchecked could be used here for max speed,
            // but standard indexing is safe and fast enough due to slice bounds.
            dst_slice[k] += val * w0;
            dst_slice[k + 1] += val * w1;
        }
    }

    fn convolve_smooth(&self, input: &[f32]) -> Vec<f32> {
        // Convolution is heavy, but here kernel is small.
        // Optimization: Use separate loop for the main part to avoid boundary checks.
        let n = input.len();
        let mut output = vec![0.0; n];
        let k_len = self.smooth_kernel.len();
        let half = k_len / 2;

        // Naive but clear implementation.
        // For very large N, FFT conv is better, but here N ~ 200-4000, kernel ~ 5-10.
        // Direct convolution is faster.
        for i in 0..n {
            let mut acc = 0.0;
            let start_k = if i < half { half - i } else { 0 };
            let end_k = if i + half >= n {
                k_len - (i + half - n + 1)
            } else {
                k_len
            };

            for j in start_k..end_k {
                let input_idx = i + j - half;
                acc += input[input_idx] * self.smooth_kernel[j];
            }
            output[i] = acc;
        }
        output
    }

    #[inline]
    fn absfreq_gate(f_hz: f32, p: &HarmonicityParams) -> f32 {
        1.0 / (1.0 + (f_hz / p.tfs_f_pl_hz).powf(p.tfs_eta))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::log2space::Log2Space;
    use plotters::prelude::*;
    use std::fs::File;
    use std::path::Path;

    #[test]
    fn test_sibling_consonance_creation() {
        // Input: 200Hz.
        // We expect peaks at:
        // - 100Hz (Root)
        // - 400Hz (Octave)
        // - 300Hz (Perfect 5th via 100Hz root)

        let space = Log2Space::new(50.0, 800.0, 200);
        let params = HarmonicityParams::default();

        let hk = HarmonicityKernel::new(&space, params);

        let mut env = vec![0.0; space.n_bins()];
        let idx_200 = space.index_of_freq(200.0).unwrap();
        env[idx_200] = 1.0;

        let (landscape, _) = hk.potential_h_from_log2_spectrum(&env, &space);

        let idx_300 = space.index_of_freq(300.0).unwrap();
        let idx_283 = space.index_of_freq(283.0).unwrap(); // Dissonant (Tritone-ish)

        // 300Hz should be stable because:
        // 200 -> Root 100.
        // Root 100 -> Harmonic 300.
        assert!(
            landscape[idx_300] > 0.2,
            "300Hz (Perfect 5th) should be a peak"
        );
        assert!(
            landscape[idx_300] > landscape[idx_283] * 1.5,
            "5th should be much more stable than tritone"
        );
    }

    #[test]
    fn test_complex_ratios_detection() {
        // Test: Can we detect 7:4 (Harmonic 7th) and 6:5 (Minor 3rd)?

        let space = Log2Space::new(20.0, 1600.0, 100);
        let params = HarmonicityParams::default();

        let hk = HarmonicityKernel::new(&space, params);

        let mut env = vec![0.0; space.n_bins()];
        let f_input = 400.0;
        if let Some(idx) = space.index_of_freq(f_input) {
            env[idx] = 1.0;
        }

        let (landscape, _) = hk.potential_h_from_log2_spectrum(&env, &space);

        let idx_m3 = space.index_of_freq(400.0 * 1.2).unwrap(); // 6:5
        let idx_h7 = space.index_of_freq(400.0 * 1.75).unwrap(); // 7:4

        // Tritone (approx 1.414).
        // Note: This is close to 7:5 (1.40), so it will have significant potential!
        let idx_tritone = space.index_of_freq(400.0 * 1.414).unwrap();

        println!("Potential at 6:5 (m3): {}", landscape[idx_m3]);
        println!("Potential at 7:4 (h7): {}", landscape[idx_h7]);
        println!("Potential at Tritone:  {}", landscape[idx_tritone]);

        assert!(
            landscape[idx_m3] > landscape[idx_tritone] * 1.1,
            "6:5 should be more stable than tritone"
        );
        assert!(
            landscape[idx_h7] > landscape[idx_tritone] * 1.1,
            "7:4 should be more stable than tritone"
        );
    }

    #[test]
    #[ignore]
    fn plot_sibling_landscape_png() {
        let space = Log2Space::new(20.0, 8000.0, 200);

        let p = HarmonicityParams::default();
        let hk = HarmonicityKernel::new(&space, p);

        let mut env = vec![0.0; space.n_bins()];
        let f_input = 440.0;
        if let Some(idx) = space.index_of_freq(f_input) {
            env[idx] = 1.0;
        }

        let (y, _) = hk.potential_h_from_log2_spectrum(&env, &space);
        let xs: Vec<f32> = (0..space.n_bins())
            .map(|i| space.freq_of_index(i))
            .collect();

        let out_path = Path::new("target/test_sibling_landscape.png");
        let root = BitMapBackend::new(out_path, (1200, 600)).into_drawing_area();
        root.fill(&WHITE).unwrap();

        let mut chart = ChartBuilder::on(&root)
            .caption(
                format!("Sibling Landscape (Input: {}Hz)", f_input),
                ("sans-serif", 20),
            )
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(40)
            .build_cartesian_2d(20.0f32..8000.0f32, 0.0f32..1.05f32)
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("Frequency [Hz]")
            .y_desc("Potential (0.0 - 1.0)")
            .y_labels(10)
            .draw()
            .unwrap();

        chart
            .draw_series(LineSeries::new(
                xs.iter().zip(y.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))
            .unwrap();

        // Mark expected mergent ratios
        let markers = vec![
            (f_input * 1.5, "3:2", RED),
            (f_input * 1.25, "5:4", MAGENTA),
            (f_input * 0.5, "1:2", GREEN),
            (f_input * 2.0, "2:1", GREEN),
        ];

        for (freq, _label, color) in markers {
            chart
                .draw_series(std::iter::once(PathElement::new(
                    vec![(freq, 0.0), (freq, 1.0)],
                    color.mix(0.5),
                )))
                .unwrap();
        }

        root.present().unwrap();
        assert!(File::open(out_path).is_ok());
    }
}
</file>

<file path="src/core/nsgt_kernel.rs">
//! core/nsgt_kernel.rs — Log2-axis NSGT (kernel-based, one-FFT-per-frame)
//!
//! Overview
//! -----
//! - For each band k, we precompute a time-domain kernel h_k[n] = w_k[n] * e^{-j 2π f_k n / fs},
//!   zero-pad it to length Nfft, center it, and take FFT → K_k[ν] (frequency-domain kernel).
//! - For each frame, compute X[ν] = FFT{x_frame} only once, and obtain C_k = (1/Nfft) Σ_ν X[ν] * conj(K_k[ν]).
//! - K_k is **sparsified** by thresholding: we store only (index, weight) of nonzero bins for fast accumulation.
//!
//! Design Notes
//! -----
//! - Frame length is fixed to Nfft. hop is a single global value based on overlap (shared across all bands).
//! - Use a periodic Hann window for each band with length L_k. Normalization by /U_k is already applied.
//! - Complex linear interpolation is unnecessary (the kernel itself represents the continuous frequency).

use crate::core::log2space::Log2Space;
use rustfft::{FftPlanner, num_complex::Complex32};
use std::sync::Arc;

// =====================================================
// Config structures
// =====================================================

/// NSGT configuration (log2-axis, analysis-only).
#[derive(Clone, Copy, Debug)]
pub struct NsgtLog2Config {
    /// Sampling rate [Hz]
    pub fs: f32,
    /// Overlap ratio in [0, 0.95). 0.5 = 50% overlap (default-good)
    pub overlap: f32,
    pub nfft_override: Option<usize>,
}

impl Default for NsgtLog2Config {
    fn default() -> Self {
        Self {
            fs: 48_000.0,
            overlap: 0.5,
            nfft_override: None,
        }
    }
}

/// Band descriptor on log2 axis.
#[derive(Clone, Debug)]
pub struct NsgtBand {
    pub f_hz: f32,
    pub win_len: usize,
    pub hop: usize,
    pub window: Vec<f32>,
    pub log2_hz: f32,
    pub q: f32,
}

/// Analysis result for one band.
#[derive(Clone, Debug)]
pub struct BandCoeffs {
    pub coeffs: Vec<Complex32>,
    pub t_sec: Vec<f32>,
    pub f_hz: f32,
    pub log2_hz: f32,
    pub win_len: usize,
    pub hop: usize,
}

#[derive(Clone, Debug)]
pub struct KernelBand {
    pub f_hz: f32,
    pub log2_hz: f32,
    pub win_len: usize, // L_k
    // frequency-domain kernel (sparse): store (bin index, conj(K_k[bin])) for computation (multiplication-only)
    pub spec_conj_sparse: Vec<(usize, Complex32)>,
}

#[derive(Clone)]
pub struct NsgtKernelLog2 {
    pub cfg: NsgtLog2Config,
    pub space: Log2Space,
    nfft: usize,
    hop: usize,
    fft: Arc<dyn rustfft::Fft<f32>>,
    bands: Vec<KernelBand>,
}

impl NsgtKernelLog2 {
    /// Kernel-based NSGT
    ///
    /// - Nfft is set to the next power of two of max(L_k) (multiplied by `zpad_pow2`, default=2).
    /// - hop is based on Nfft (shared across all bands): hop = round((1-overlap)*Nfft)
    pub fn new(cfg: NsgtLog2Config, space: Log2Space) -> Self {
        assert!(
            cfg.overlap >= 0.0 && cfg.overlap < 0.95,
            "Overlap must be in [0,0.95)"
        );

        let fs = cfg.fs;
        let bpo = space.bins_per_oct as f32;
        let raw_q = 1.0 / (2f32.powf(1.0 / bpo) - 1.0);
        let q = raw_q.clamp(5.0, 80.0); // prevent excessive window size

        // Calculate L_k for each band
        let mut Lks: Vec<usize> = space
            .centers_hz
            .iter()
            .map(|&f| ((q * fs / f).round() as usize).max(16)) // or ceil?
            .collect();

        // Nfft determination: next power of two based on max L_k (zero-padding to sharpen the kernel)
        let zpad_pow2: usize = 2;
        let max_L = *Lks.iter().max().unwrap_or(&1024);

        let mut nfft = if let Some(n) = cfg.nfft_override {
            n
        } else {
            (max_L * zpad_pow2).next_power_of_two().max(1024)
        };

        // upper limit for practical use (to avoid excessively large FFT)
        if nfft > 1 << 18 {
            nfft = 1 << 18;
        }

        let hop = ((1.0 - cfg.overlap) * nfft as f32).round().max(1.0) as usize;

        let mut planner = FftPlanner::<f32>::new();
        let fft = planner.plan_fft_forward(nfft);

        // Precompute kernels for each band (frequency domain, conjugated and sparsified)
        let mut bands: Vec<KernelBand> = Vec::with_capacity(space.centers_hz.len());
        for ((&f, &log2_f), &Lk) in space
            .centers_hz
            .iter()
            .zip(space.centers_log2.iter())
            .zip(Lks.iter())
        {
            let mut Lk_req = Lk;

            if Lk_req >= nfft {
                Lk_req = nfft - 1;
            }
            if Lk_req % 2 == 0 {
                Lk_req -= 1;
            }

            Lk_req = Lk_req.max(3);

            let window = hann_periodic(Lk_req);
            let sum_w = window.iter().copied().sum::<f32>().max(1e-12);

            // circularly shifted kernel h_k[n] = w[n]*e^{-j2π f n/fs} (zero-padded to nfft)
            let mut h = vec![Complex32::new(0.0, 0.0); nfft];
            let center = Lk_req / 2;
            let shift = (nfft / 2 + nfft - center) % nfft; // place kernel center at NFFT/2
            for i in 0..Lk_req {
                let w = window[i] / sum_w;
                let ph = 2.0 * std::f32::consts::PI * f * (i as f32) / fs;
                let cplx = Complex32::new(ph.cos(), -ph.sin()) * w;
                let idx = (i + shift) % nfft;
                h[idx] = cplx;
            }

            // K_k = FFT{h_k}
            let mut H = h.clone();
            fft.process(&mut H);

            // 疎化（最大値に対して相対しきい値を掛ける）
            let mut max_mag = 0.0f32;
            for z in &H {
                let m = z.norm_sqr();
                if m > max_mag {
                    max_mag = m;
                }
            }
            let tol = 1e-6 * max_mag.sqrt();
            //            let tol = (1e-5f32).max(1e-6 * max_mag.sqrt()); // 実用的な下限
            let mut sparse: Vec<(usize, Complex32)> = Vec::new();
            let two_pi_over_n = 2.0 * std::f32::consts::PI / (nfft as f32);
            let shift_f = shift as f32;
            for (k, &z) in H.iter().enumerate() {
                if z.norm() >= tol {
                    // --- phase compensation --
                    // time shift in h[n] -> linear phase exp(-j 2π k * shift / N) in H[k]
                    // To undo that (so that inner product is lag=0), multiply conj(H[k]) by exp(-j 2π k * shift / N)
                    let theta = two_pi_over_n * (k as f32) * shift_f;
                    let rot_back = Complex32::new(theta.cos(), -theta.sin());

                    // store conj(H[k]) * rot_back
                    sparse.push((k, z.conj() * rot_back));
                }
            }

            bands.push(KernelBand {
                f_hz: f,
                log2_hz: log2_f,
                win_len: Lk_req,
                spec_conj_sparse: sparse,
            });
        }

        Self {
            cfg,
            space,
            nfft,
            hop,
            fft,
            bands,
        }
    }

    pub fn space(&self) -> &Log2Space {
        &self.space
    }
    pub fn nfft(&self) -> usize {
        self.nfft
    }
    pub fn hop(&self) -> usize {
        self.hop
    }
    pub fn bands(&self) -> &[KernelBand] {
        &self.bands
    }

    /// 解析：各フレームで X を一回だけ計算し、全バンドの C_k を周波数領域の疎内積で同時計算
    pub fn analyze(&self, x: &[f32]) -> Vec<BandCoeffs> {
        let fs = self.cfg.fs;
        if x.is_empty() {
            return Vec::new();
        }

        let nfft = self.nfft;
        let hop = self.hop;

        let n_frames = if x.len() < nfft {
            1
        } else {
            (x.len() - nfft) / hop + 1
        };

        // 出力スロット
        let mut out: Vec<BandCoeffs> = self
            .bands
            .iter()
            .map(|b| BandCoeffs {
                coeffs: Vec::with_capacity(n_frames),
                t_sec: Vec::with_capacity(n_frames),
                f_hz: b.f_hz,
                log2_hz: b.log2_hz,
                win_len: b.win_len,
                hop,
            })
            .collect();

        let mut buf = vec![Complex32::new(0.0, 0.0); nfft];

        for frame_idx in 0..n_frames {
            // フレーミング（矩形。カーネル側に窓が含まれるためここで追加窓は不要）
            let start = frame_idx * hop;
            for i in 0..nfft {
                let xi = if start + i < x.len() {
                    x[start + i]
                } else {
                    0.0
                };
                buf[i] = Complex32::new(xi, 0.0);
            }

            // X = FFT{x}
            self.fft.process(&mut buf);

            // 各バンドの疎内積： C_k = (1/Nfft) Σ X[ν] * conj(K_k[ν])
            for (b_idx, b) in self.bands.iter().enumerate() {
                let mut acc = Complex32::new(0.0, 0.0);
                for &(k, w) in &b.spec_conj_sparse {
                    acc += buf[k] * w;
                }
                acc = acc / (nfft as f32); // 1/Nfft スケーリング（rustfftの正規化に対応）
                out[b_idx].coeffs.push(acc);
                out[b_idx].t_sec.push((start + nfft / 2) as f32 / fs);
            }
        }

        out
    }

    /// 平均振幅（envelope的）。/L・per-Hz正規化はしない（利用側で定義）
    pub fn analyze_envelope(&self, x: &[f32]) -> Vec<f32> {
        let bands = self.analyze(x);
        bands
            .into_iter()
            .map(|b| {
                let m = b.coeffs.len();
                if m == 0 {
                    0.0
                } else {
                    // 端部1フレームずつ除外（エッジ効果の影響を消す）
                    let (start, end) = if m > 2 { (1, m - 1) } else { (0, m) };
                    let slice = &b.coeffs[start..end];
                    if slice.is_empty() {
                        0.0
                    } else {
                        slice.iter().map(|z| z.norm()).sum::<f32>() / (slice.len() as f32)
                    }
                }
            })
            .collect()
    }

    /// Hann窓用 ENBW 補正を含む Power Spectral Density [power/Hz] (**one-sided**)
    pub fn analyze_psd(&self, x: &[f32]) -> Vec<f32> {
        let fs = self.cfg.fs;
        self.analyze(x)
            .iter()
            .map(|b| {
                let mean_pow = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                    / (b.coeffs.len().max(1) as f32);
                let enbw_hz = 1.5_f32 * fs / (b.win_len as f32);
                // two-sided -> one-sided
                2.0 * (mean_pow / enbw_hz.max(1e-12))
            })
            .collect()
    }
}

// ===== util =====

fn hann_periodic(n: usize) -> Vec<f32> {
    (0..n)
        .map(|i| 0.5 * (1.0 - (2.0 * std::f32::consts::PI * (i as f32) / n as f32).cos()))
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::utils::{brown_noise, pink_noise, white_noise};
    use approx::assert_relative_eq;

    fn mk_sine(fs: f32, f: f32, secs: f32) -> Vec<f32> {
        let n = (fs * secs).round() as usize;
        (0..n)
            .map(|i| (2.0 * std::f32::consts::PI * f * (i as f32) / fs).sin())
            .collect()
    }

    #[test]
    fn pure_tone_near_target() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                ..Default::default()
            },
            Log2Space::new(20.0, 8000.0, 200),
        );
        let sig = mk_sine(fs, 440.0, 1.0);
        let bands = nsgt.analyze(&sig);
        let (mut best_f, mut best_val) = (0.0, 0.0);
        for b in &bands {
            let p =
                b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>() / (b.coeffs.len().max(1) as f32);
            if p > best_val {
                best_val = p;
                best_f = b.f_hz;
            }
        }
        let cents = 1200.0 * (((best_f / 440.0_f32).log2()).abs());
        assert!(
            cents < 60.0,
            "peak off by {:.1} cents @ {:.2} Hz",
            cents,
            best_f
        );
    }

    #[test]
    fn multi_tone_localization() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        for f in [55.0, 110.0, 220.0, 440.0, 880.0, 1760.0] {
            let sig = mk_sine(fs, f, 1.0);
            let bands = nsgt.analyze(&sig);
            let (mut best_f, mut best_val) = (0.0, 0.0);
            for b in &bands {
                let p = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                    / (b.coeffs.len().max(1) as f32);
                if p > best_val {
                    best_val = p;
                    best_f = b.f_hz;
                }
            }
            let cents = 1200.0 * ((best_f / f).log2()).abs();
            assert!(
                cents < 60.0,
                "freq localization failed: input {f} → peak {best_f} ({cents:.1} cents)"
            );
        }
    }

    #[test]
    fn amplitude_linearity() {
        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let a = mk_sine(fs, 440.0, 1.0);
        let b: Vec<f32> = a.iter().map(|v| v * 2.0).collect();
        let e1: f32 = nsgt.analyze_psd(&a).iter().sum();
        let e2: f32 = nsgt.analyze_psd(&b).iter().sum();
        assert_relative_eq!(e2 / e1, 4.0, epsilon = 0.15, max_relative = 0.15);
    }

    #[test]
    fn win_len_decreases_with_freq() {
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 96));
        let lens: Vec<usize> = nsgt.bands().iter().map(|b| b.win_len).collect();
        for w in lens.windows(2) {
            assert!(w[0] >= w[1], "win_len not monotonic: {} < {}", w[0], w[1]);
        }
    }

    #[test]
    fn log2_space_linear_check() {
        let space = Log2Space::new(20.0, 8000.0, 48);
        let diffs: Vec<f32> = space.centers_log2.windows(2).map(|x| x[1] - x[0]).collect();
        let mean = diffs.iter().sum::<f32>() / diffs.len() as f32;
        let var = diffs
            .iter()
            .map(|d| (d - mean).abs() / mean)
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap();
        assert!(var < 1e-3, "log2 spacing nonuniform >0.1%");
    }

    #[test]
    fn empty_signal_returns_empty() {
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), Log2Space::new(20.0, 8000.0, 48));
        let out = nsgt.analyze(&[]);
        assert!(out.is_empty());
    }

    #[test]
    fn low_vs_high_freq_energy_scaling() {
        // 周波数によらず全体のエネルギーが概ね一定であることを確認
        let fs = 48_000.0;
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), space.clone());

        let sig_low = mk_sine(fs, 220.0, 1.0);
        let sig_high = mk_sine(fs, 1760.0, 1.0);

        let integrate_psd = |x: &[f32]| -> f32 {
            let psd = nsgt.analyze_psd(x);
            let freqs = &space.centers_hz;
            let mut total = 0.0;
            for i in 0..freqs.len() - 1 {
                let df = (freqs[i + 1] - freqs[i]).max(1e-9);
                total += psd[i] * df;
            }
            total
        };

        let p_low = integrate_psd(&sig_low);
        let p_high = integrate_psd(&sig_high);
        let ratio = p_high / p_low;

        assert_relative_eq!(ratio, 1.0, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn parseval_consistency() {
        let fs = 48_000.0;
        let f0 = 880.0;
        let sig = (0..(fs as usize))
            .map(|i| (2.0 * std::f32::consts::PI * f0 * i as f32 / fs).sin())
            .collect::<Vec<_>>();

        let space = Log2Space::new(20.0, 8000.0, 200);
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), space.clone());

        let e_time = sig.iter().map(|x| x * x).sum::<f32>() / sig.len() as f32;
        let psd = nsgt.analyze_psd(&sig);

        let e_freq = psd
            .iter()
            .zip(space.centers_hz.windows(2))
            .map(|(p, f)| p * (f[1] - f[0]))
            .sum::<f32>();

        assert_relative_eq!(e_freq / e_time, 1.0, epsilon = 0.1);
    }

    #[test]
    fn hop_size_stability() {
        let fs = 48_000.0;
        let space = Log2Space::new(20.0, 8000.0, 96);
        let sig = mk_sine(fs, 440.0, 1.0);

        let e_mean = |overlap: f32| {
            let nsgt = NsgtKernelLog2::new(
                NsgtLog2Config {
                    fs,
                    overlap,
                    ..Default::default()
                },
                space.clone(),
            );
            let out = nsgt.analyze(&sig);
            let sum_e: f32 = out
                .iter()
                .map(|b| b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>())
                .sum();
            let n_frames: usize = out.iter().map(|b| b.coeffs.len()).max().unwrap_or(1);
            if n_frames > 0 {
                sum_e / n_frames as f32
            } else {
                0.0
            }
        };

        let e_half = e_mean(0.5);
        let e_75 = e_mean(0.75);
        assert_relative_eq!(e_half, e_75, epsilon = 0.3, max_relative = 0.3);
    }

    #[test]
    fn band_count_matches_space() {
        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), space.clone());
        assert_eq!(
            nsgt.bands().len(),
            space.centers_hz.len(),
            "Band count must match Log2Space bin count"
        );
    }

    #[test]
    fn single_tone_peak_shape() {
        let fs = 48_000.0;
        let f0 = 1000.0;
        let space = Log2Space::new(100.0, 5000.0, 200);
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), space.clone());
        let sig = (0..(fs as usize))
            .map(|i| (2.0 * std::f32::consts::PI * f0 * i as f32 / fs).sin())
            .collect::<Vec<_>>();

        let psd = nsgt.analyze_psd(&sig);
        let freqs = &space.centers_hz;
        let (i_peak, &p_peak) = psd
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .unwrap();
        let f_peak = freqs[i_peak];

        // ピーク位置が ±1/12oct 以内
        let cents = 1200.0 * ((f_peak / f0).log2()).abs();
        assert!(
            cents < 100.0,
            "peak off by {:.1} cents @ {:.2} Hz",
            cents,
            f_peak
        );

        // --- 主ローブ外側のみでフランクを評価する ---
        // Hann の 1st zero は概ね |Δf| = 2/T,  T = Lk / fs
        let Lk = nsgt.bands()[i_peak].win_len as f32; // Lk_req
        let T = Lk / fs;
        let df_zero = 2.0 / T; // [Hz]

        let mut flank_max = 0.0f32;
        let mut flank_count = 0usize;
        for (i, &p) in psd.iter().enumerate() {
            let df = (freqs[i] - f_peak).abs();
            if df >= df_zero {
                flank_max = flank_max.max(p);
                flank_count += 1;
            }
        }
        assert!(
            flank_count > 0,
            "no bins outside main lobe to evaluate flank"
        );

        // 主ローブ外では少なくとも ≈10×（>10.0）下がっていることを期待（約10.8 dB）
        assert!(
            p_peak / flank_max > 10.0,
            "peak too broad or flat: peak={}, flank_max={}, df_zero={:.2} Hz, Lk={}",
            p_peak,
            flank_max,
            df_zero,
            Lk as usize
        );
    }

    #[test]
    fn amplitude_scaling_quadratic() {
        let fs = 48_000.0;
        let f0 = 440.0;
        let sig1: Vec<f32> = (0..(fs as usize))
            .map(|i| (2.0 * std::f32::consts::PI * f0 * i as f32 / fs).sin())
            .collect();
        let sig2: Vec<f32> = sig1.iter().map(|x| x * 2.0).collect();

        let space = Log2Space::new(20.0, 8000.0, 96);
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), space);
        let e1: f32 = nsgt.analyze_psd(&sig1).iter().sum();
        let e2: f32 = nsgt.analyze_psd(&sig2).iter().sum();

        assert_relative_eq!(e2 / e1, 4.0, epsilon = 0.1);
    }

    #[test]
    fn overlap_independence() {
        let fs = 48_000.0;
        let f0 = 880.0;
        let sig = (0..(fs as usize))
            .map(|i| (2.0 * std::f32::consts::PI * f0 * i as f32 / fs).sin())
            .collect::<Vec<_>>();
        let space = Log2Space::new(20.0, 8000.0, 96);

        let energies: Vec<f32> = [0.25, 0.5, 0.75]
            .iter()
            .map(|&ov| {
                let nsgt = NsgtKernelLog2::new(
                    NsgtLog2Config {
                        fs,
                        overlap: ov,
                        ..Default::default()
                    },
                    space.clone(),
                );
                nsgt.analyze_psd(&sig).iter().sum::<f32>()
            })
            .collect();

        let mean = energies.iter().sum::<f32>() / energies.len() as f32;
        for &e in &energies {
            assert_relative_eq!(e / mean, 1.0, epsilon = 0.2);
        }
    }

    #[test]
    fn noise_slope_accuracy() {
        let fs = 48_000.0;
        let n = (fs * 4.0) as usize;

        let white: Vec<f32> = white_noise(n, 1).iter().map(|&v| v as f32).collect();
        let pink: Vec<f32> = pink_noise(n, 1).iter().map(|&v| v as f32).collect();
        let brown: Vec<f32> = brown_noise(n, 1).iter().map(|&v| v as f32).collect();

        let space = Log2Space::new(50.0, 8000.0, 150);
        let nsgt = NsgtKernelLog2::new(NsgtLog2Config::default(), space.clone());

        let psd_white = nsgt.analyze_psd(&white);
        let psd_pink = nsgt.analyze_psd(&pink);
        let psd_brown = nsgt.analyze_psd(&brown);

        let slope = |psd: &[f32]| {
            let y: Vec<f32> = psd.iter().map(|v| 10.0 * v.max(1e-20).log10()).collect();
            let x = &space.centers_log2;
            let (sx, sy, sxx, sxy, n) = x.iter().zip(&y).fold(
                (0.0, 0.0, 0.0, 0.0, 0.0),
                |(sx, sy, sxx, sxy, n), (xv, yv)| {
                    (
                        sx + *xv,
                        sy + *yv,
                        sxx + *xv * *xv,
                        sxy + *xv * *yv,
                        n + 1.0,
                    )
                },
            );
            (n * sxy - sx * sy) / (n * sxx - sx * sx)
        };

        let s_white = slope(&psd_white);
        let s_pink = slope(&psd_pink);
        let s_brown = slope(&psd_brown);

        assert!(s_white.abs() < 0.8, "white slope {s_white}");
        assert!((s_pink + 3.0).abs() < 1.0, "pink slope {s_pink}");
        assert!((s_brown + 6.0).abs() < 1.5, "brown slope {s_brown}");
    }

    // ==============================
    // 可視化（プロット用）: cargo test -- --ignored
    // ==============================

    #[test]
    #[ignore]
    fn plot_nsgt_spectrum_kernel() {
        use plotters::prelude::*;

        let fs = 48_000.0;
        let nsgt = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                ..Default::default()
            },
            Log2Space::new(20.0, 8000.0, 200),
        );
        let sig = mk_sine(fs, 440.0, 1.0);
        let bands = nsgt.analyze(&sig);

        let points: Vec<(f32, f32)> = bands
            .iter()
            .map(|b| {
                let p = b.coeffs.iter().map(|z| z.norm_sqr()).sum::<f32>()
                    / (b.coeffs.len().max(1) as f32);
                (b.log2_hz, p)
            })
            .collect();

        let root =
            BitMapBackend::new("target/nsgt_kernel_spectrum.png", (1500, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let y_max = points.iter().map(|(_, p)| *p).fold(0.0f32, f32::max) * 1.1;

        let mut chart = ChartBuilder::on(&root)
            .caption("NSGT Kernel Spectrum (pure 440Hz)", ("sans-serif", 18))
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(50)
            .build_cartesian_2d((20f32.log2())..(8000f32.log2()), 0f32..y_max)
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("log2(frequency) [oct]")
            .y_desc("mean power")
            .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
            .draw()
            .unwrap();

        chart
            .draw_series(LineSeries::new(points.iter().cloned(), &BLUE))
            .unwrap();

        root.present().unwrap();
    }

    #[test]
    #[ignore]
    fn plot_nsgt_log2_noise_response_kernel() {
        use plotters::prelude::*;

        let fs = 48_000.0;
        let secs = 40.0;
        let n = (fs * secs) as usize;

        let nsgt = NsgtKernelLog2::new(
            NsgtLog2Config {
                fs,
                overlap: 0.5,
                ..Default::default()
            },
            Log2Space::new(35.0, 24_000.0, 100),
        );

        // --- ノイズ生成 ---
        let white: Vec<f32> = white_noise(n, 42).iter().map(|&v| v as f32).collect();
        let pink: Vec<f32> = pink_noise(n, 42).iter().map(|&v| v as f32).collect();
        let brown: Vec<f32> = brown_noise(n, 42).iter().map(|&v| v as f32).collect();

        // --- per-Hz正規化済み PSD を取得 ---
        let w_psd = nsgt.analyze_psd(&white);
        let p_psd = nsgt.analyze_psd(&pink);
        let b_psd = nsgt.analyze_psd(&brown);

        // dB換算
        let to_db =
            |v: &[f32]| -> Vec<f32> { v.iter().map(|x| 10.0 * x.max(1e-20).log10()).collect() };
        let w_db = to_db(&w_psd);
        let p_db = to_db(&p_psd);
        let b_db = to_db(&b_psd);

        let log2x = nsgt.space().centers_log2.clone();

        // --- 描画 ---
        let root = BitMapBackend::new("target/nsgt_kernel_noise_psd_db.png", (1500, 1000))
            .into_drawing_area();
        root.fill(&WHITE).unwrap();

        let y_min = w_db
            .iter()
            .chain(&p_db)
            .chain(&b_db)
            .cloned()
            .fold(f32::INFINITY, f32::min);
        let y_max = w_db
            .iter()
            .chain(&p_db)
            .chain(&b_db)
            .cloned()
            .fold(f32::NEG_INFINITY, f32::max);

        let mut chart = ChartBuilder::on(&root)
            .caption(
                "NSGT Kernel PSD (White / Pink / Brown Noise)",
                ("sans-serif", 18),
            )
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(60)
            .build_cartesian_2d(
                (35f32.log2())..(24_000f32.log2()),
                (y_min - 10.0)..(y_max + 10.0),
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("log2(frequency) [oct]")
            .y_desc("Power Spectral Density [dB re 1/Hz]")
            .x_label_formatter(&|v| format!("{:.0}", 2f32.powf(*v)))
            .draw()
            .unwrap();

        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(w_db.iter().cloned()),
                &BLUE,
            ))
            .unwrap()
            .label("White");

        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(p_db.iter().cloned()),
                &RED,
            ))
            .unwrap()
            .label("Pink");

        chart
            .draw_series(LineSeries::new(
                log2x.iter().cloned().zip(b_db.iter().cloned()),
                &GREEN,
            ))
            .unwrap()
            .label("Brown");

        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()
            .unwrap();

        root.present().unwrap();
    }
}
</file>

<file path="src/ui/windows.rs">
use crate::ui::plots::{log2_plot_hz, time_plot};
use crate::ui::viewdata::UiFrame;
use egui::{CentralPanel, TopBottomPanel, Vec2};
use egui_plot::{Line, Plot, PlotPoints};

use crate::core::landscape::LandscapeFrame;

use egui::epaint::{ColorImage, TextureHandle};
use egui::{Color32, Response, ScrollArea, Ui};
use egui_plot::{PlotImage, PlotPoint, PlotResponse};

/// === PLV heatmap ===
pub fn show_plv_heatmap(
    ui: &mut Ui,
    freqs_x: &[f32],
    freqs_y: &[f32],
    plv: &[Vec<f32>],
    tex: &mut Option<TextureHandle>,
) {
    let nx = freqs_x.len();
    let ny = freqs_y.len();
    if nx == 0 || ny == 0 {
        ui.label("PLV data empty.");
        return;
    }

    // --- build color pixels (flip vertically) ---
    let mut pixels = vec![Color32::BLACK; nx * ny];
    for j in 0..ny {
        let row = ny - 1 - j; // flip vertically (low freq bottom)
        for i in 0..nx {
            let v = plv
                .get(j)
                .and_then(|r| r.get(i))
                .copied()
                .unwrap_or(0.0)
                .clamp(0.0, 1.0);
            let r = (v * 255.0) as u8;
            let b = ((1.0 - v) * 255.0) as u8;
            pixels[row * nx + i] = Color32::from_rgb(r, 0, b);
        }
    }

    // --- upload texture ---
    let img = ColorImage::new([nx, ny], pixels);
    let texture = tex.get_or_insert_with(|| {
        ui.ctx()
            .load_texture("plv_heatmap", img.clone(), egui::TextureOptions::LINEAR)
    });
    texture.set(img, egui::TextureOptions::LINEAR);

    // --- coordinate ranges ---
    let fx_min = *freqs_x.first().unwrap();
    let fx_max = *freqs_x.last().unwrap();
    let fy_min = *freqs_y.first().unwrap();
    let fy_max = *freqs_y.last().unwrap();

    // --- draw plot ---
    let plot = Plot::new("plv_plot")
        .data_aspect(1.0)
        .allow_zoom(false)
        .allow_scroll(false)
        .include_x(fx_min as f64)
        .include_x(fx_max as f64)
        .include_y(fy_min as f64)
        .include_y(fy_max as f64);

    plot.show(ui, |plot_ui| {
        let center_x = (fx_min + fx_max) * 0.5;
        let center_y = (fy_min + fy_max) * 0.5;
        let size_x = fx_max - fx_min;
        let size_y = fy_max - fy_min;

        let img = PlotImage::new(
            "plv_img",
            texture.id(),
            PlotPoint::new(center_x, center_y),
            Vec2::new(size_x, size_y),
        );
        plot_ui.image(img);
    });
}

/// === Main window ===
pub fn main_window(ctx: &egui::Context, frame: &UiFrame) {
    TopBottomPanel::top("top").show(ctx, |ui| {
        ui.heading("Conchordal — NSGT Landscape Viewer");
        ui.label("Wave + Landscape (log₂-space R, PLV-based C)");
    });

    CentralPanel::default().show(ctx, |ui| {
        ui.horizontal(|ui| {
            // === Waveform ===
            ui.vertical(|ui| {
                ui.heading("Waveform");
                ui.allocate_ui_with_layout(
                    Vec2::new(500.0, 180.0),
                    egui::Layout::top_down(egui::Align::LEFT),
                    |ui| {
                        time_plot(
                            ui,
                            "Current Hop Wave",
                            frame.wave.fs as f64,
                            &frame.wave.samples,
                        );
                    },
                );
            });

            ui.separator();
            eprintln!(
                "DEBUG: len(freqs)={}, len(R)={}, len(C)={}, len(K)={}",
                frame.landscape.space.n_bins(),
                frame.landscape.r_last.len(),
                frame.landscape.h_last.len(),
                frame.landscape.c_last.len()
            );

            // === Spectrum ===
            ui.vertical(|ui| {
                ui.heading("Synth Spectrum");
                if frame.spec.spec_hz.len() > 1 && frame.spec.amps.len() > 1 {
                    let max_amp = frame.spec.amps.iter().cloned().fold(0.0, f32::max);
                    crate::ui::plots::log2_hist_hz(
                        ui,
                        "Amplitude Spectrum",
                        &frame.spec.spec_hz[1..],
                        &frame.spec.amps[1..],
                        "A[k]",
                        0.0,
                        (max_amp * 1.05) as f64,
                    );
                }
            });
        });

        ui.separator();
        ui.heading("Analytic");

        log2_plot_hz(
            ui,
            "NSGT envelope",
            &frame.landscape.space.centers_hz,
            &frame.landscape.amps_last,
            "NSGT",
            0.0,
            (1.05) as f64,
        );

        ui.separator();

        ui.separator();
        ui.heading("Landscape");

        let max_r = frame.landscape.r_last.iter().cloned().fold(0.0, f32::max);
        let min_c = frame.landscape.c_last.iter().cloned().fold(0.0, f32::min);
        let max_c = frame.landscape.c_last.iter().cloned().fold(0.0, f32::max);

        ui.columns(1, |cols| {
            let ui = &mut cols[0];

            // Roughness R
            log2_plot_hz(
                ui,
                "Roughness Landscape (R)",
                &frame.landscape.space.centers_hz,
                &frame.landscape.r_last,
                "R",
                0.0,
                (max_r * 1.05) as f64,
            );

            // Harmonicity H
            log2_plot_hz(
                ui,
                "Harmonicity Landscape (H)",
                &frame.landscape.space.centers_hz,
                &frame.landscape.h_last,
                "H",
                0.0,
                1.0,
            );

            // Combined Consonance C
            log2_plot_hz(
                ui,
                "Consonance potential",
                &frame.landscape.space.centers_hz,
                &frame.landscape.c_last,
                "C",
                (min_c * 1.1) as f64,
                (max_c * 1.1) as f64,
            );
        });
    });
}
</file>

<file path="src/core.rs">
pub mod erb;
pub mod fft;
pub mod harmonicity_kernel;
pub mod landscape;
pub mod log2space;
pub mod nsgt;
pub mod nsgt_kernel;
pub mod nsgt_rt;
pub mod roughness_kernel;
pub mod utils;
</file>

<file path="src/core/roughness_kernel.rs">
//! core/roughness_kernel.rs — Roughness R via ERB-domain kernel convolution.
//! Computes frequency-space roughness landscape by convolving the
//! envelope energy using an asymmetric kernel.

use crate::core::erb::{erb_bw_hz, hz_to_erb};
use crate::core::fft::{apply_hann_window_complex, hilbert};
use crate::core::log2space::Log2Space;
use rustfft::{FftPlanner, num_complex::Complex32};

// ======================================================================
// Kernel parameter definition (Plomp–Levelt inspired, ΔERB domain)
// ======================================================================

#[derive(Clone, Copy, Debug)]
pub struct KernelParams {
    // === Cochlear layer ===
    pub sigma_erb: f32,
    pub tau_erb: f32,
    pub mix_tail: f32,
    pub half_width_erb: f32,
    pub suppress_sigma_erb: f32,
    pub suppress_pow: f32,
    // === Neural layer ===
    pub sigma_neural_erb: f32,
    pub w_neural: f32,
}

impl Default for KernelParams {
    fn default() -> Self {
        Self {
            sigma_erb: 0.45,
            tau_erb: 1.0,
            mix_tail: 0.20,
            half_width_erb: 4.0,
            suppress_sigma_erb: 0.10,
            suppress_pow: 2.0,
            sigma_neural_erb: 1.0,
            w_neural: 0.3,
        }
    }
}

// ======================================================================
// Core kernel evaluation
// ======================================================================

#[inline]
pub fn eval_kernel_delta_erb(params: &KernelParams, d_erb: f32) -> f32 {
    let sigma = params.sigma_erb.max(1e-6);
    let tau = params.tau_erb.max(1e-6);
    let s_sup = params.suppress_sigma_erb.max(1e-6);
    let sig_n = params.sigma_neural_erb.max(1e-6);

    let desq = d_erb * d_erb;
    let g_gauss = (-desq / (2.0 * sigma * sigma)).exp();
    let g_tail = if d_erb >= 0.0 {
        (-d_erb / tau).exp()
    } else {
        0.0
    };
    let base = (1.0 - params.mix_tail) * g_gauss + params.mix_tail * g_tail;

    let suppress = (1.0 - (-desq / (2.0 * s_sup * s_sup)).exp()).clamp(0.0, 1.0);
    let g_coch = base * suppress.powf(params.suppress_pow);
    let g_neural = (-desq / (2.0 * sig_n * sig_n)).exp();
    (1.0 - params.w_neural) * g_coch + params.w_neural * g_neural
}

pub fn build_kernel_erbstep(params: &KernelParams, erb_step: f32) -> (Vec<f32>, usize) {
    let hw_erb = params.half_width_erb;
    let n_side = (hw_erb / erb_step).ceil() as usize;
    let len = 2 * n_side + 1;

    let mut g: Vec<f32> = (0..len)
        .map(|i| {
            let d = (i as i32 - n_side as i32) as f32 * erb_step;
            eval_kernel_delta_erb(params, d)
        })
        .collect();

    let sum = g.iter().sum::<f32>() * erb_step;
    if sum > 0.0 {
        let inv = 1.0 / sum;
        g.iter_mut().for_each(|v| *v *= inv);
    }
    (g, n_side)
}

#[inline]
fn lut_interp(lut: &[f32], step: f32, hw: usize, d_erb: f32) -> f32 {
    let t = d_erb / step + hw as f32;
    let i = t.floor();
    let i0 = i as isize;
    let i1 = i0 + 1;
    if i0 < 0 || (i1 as usize) >= lut.len() {
        return 0.0;
    }
    let frac = t - i;
    let a = lut[i0 as usize];
    let b = lut[i1 as usize];
    a + frac * (b - a)
}

fn local_du_from_grid(erb: &[f32]) -> Vec<f32> {
    let n = erb.len();
    let mut du = vec![0.0; n];
    if n == 0 {
        return du;
    }
    if n == 1 {
        return du;
    }
    du[0] = (erb[1] - erb[0]).max(0.0);
    du[n - 1] = (erb[n - 1] - erb[n - 2]).max(0.0);
    for i in 1..n - 1 {
        du[i] = 0.5 * (erb[i + 1] - erb[i - 1]).max(0.0);
    }
    du
}

// ======================================================================
// Roughness kernel (holds LUT, no global cache)
// ======================================================================

#[derive(Clone, Debug)]
pub struct RoughnessKernel {
    pub params: KernelParams,
    pub erb_step: f32,
    pub lut: Vec<f32>,
    pub hw: usize,
}

impl RoughnessKernel {
    /// Create a new kernel and precompute LUT.
    pub fn new(params: KernelParams, erb_step: f32) -> Self {
        let (lut, hw) = build_kernel_erbstep(&params, erb_step);
        Self {
            params,
            erb_step,
            lut,
            hw,
        }
    }

    // ------------------------------------------------------------------
    // Potential R from amplitude spectrum (linear frequency axis)
    // ------------------------------------------------------------------

    pub fn potential_r_from_spectrum(&self, amps_hz: &[f32], fs: f32) -> (Vec<f32>, f32) {
        let n = amps_hz.len();
        if n == 0 {
            return (vec![], 0.0);
        }

        let nfft = 2 * n;
        let df = fs / nfft as f32;

        let f: Vec<f32> = (0..n).map(|i| i as f32 * df).collect();
        let erb: Vec<f32> = f.iter().map(|&x| hz_to_erb(x)).collect();
        let half_width = self.params.half_width_erb;
        let du = local_du_from_grid(&erb);

        let mut r = vec![0.0f32; n];
        for i in 0..n {
            let fi_erb = erb[i];
            let mut sum = 0.0f32;

            let j_lo = erb.partition_point(|&x| x < fi_erb - half_width);
            let j_hi = erb.partition_point(|&x| x <= fi_erb + half_width);
            for j in j_lo..j_hi {
                let d = erb[j] - fi_erb;
                if d.abs() > half_width {
                    continue;
                }
                let w = lut_interp(&self.lut, self.erb_step, self.hw, d);
                sum += amps_hz[j] * w * du[j];
            }
            r[i] = sum;
        }

        // Integrate over ERB axis
        let r_total: f32 = r.iter().zip(du.iter()).map(|(ri, dui)| ri * dui).sum();

        (r, r_total)
    }

    // ------------------------------------------------------------------
    // Potential R from analytic (Hilbert) signal
    // ------------------------------------------------------------------

    pub fn potential_r_from_analytic(&self, analytic: &[Complex32], fs: f32) -> (Vec<f32>, f32) {
        if analytic.is_empty() {
            return (vec![], 0.0);
        }

        let n0 = analytic.len();
        let n = n0.next_power_of_two();
        let mut buf: Vec<Complex32> = Vec::with_capacity(n);
        buf.extend_from_slice(analytic);
        if n > n0 {
            buf.resize(n, Complex32::new(0.0, 0.0));
        }

        // Apply Hann window (complex)
        let U = apply_hann_window_complex(&mut buf);

        // FFT
        let mut planner = FftPlanner::new();
        let fft = planner.plan_fft_forward(n);
        fft.process(&mut buf);

        // Convert to amplitude spectrum
        let n_half = n / 2;
        let df = fs / n as f32;
        let base_scale = 1.0 / (fs * n as f32 * U);
        let amps: Vec<f32> = (0..n_half)
            .map(|i| (buf[i].norm_sqr() * base_scale * 2.0 * df).sqrt())
            .collect();

        self.potential_r_from_spectrum(&amps, fs)
    }

    /// Compute roughness potential R from log2-domain amplitude spectrum (NSGT).
    /// Input amplitudes are already perceptually normalized (subjective intensity),
    /// so no further compression is applied here.
    pub fn potential_r_from_log2_spectrum(
        &self,
        amps: &[f32],
        space: &Log2Space,
    ) -> (Vec<f32>, f32) {
        use crate::core::erb::{erb_to_hz, hz_to_erb};

        if amps.is_empty() || space.centers_hz.is_empty() {
            return (vec![], 0.0);
        }
        assert_eq!(
            amps.len(),
            space.centers_hz.len(),
            "amps and space length mismatch"
        );

        let n = amps.len();

        // (1) Map to ERB axis
        let erb: Vec<f32> = space.centers_hz.iter().map(|&f| hz_to_erb(f)).collect();

        // (2) Weight per ERB
        let du = local_du_from_grid(&erb);

        // (3) Convolution over ERB axis
        let half_width_erb = self.params.half_width_erb;
        let mut r = vec![0.0f32; n];

        for i in 0..n {
            let fi_erb = erb[i];
            let mut sum = 0.0f32;

            let lo_hz = erb_to_hz(fi_erb - half_width_erb);
            let hi_hz = erb_to_hz(fi_erb + half_width_erb);
            let j_lo = space.index_of_freq(lo_hz).unwrap_or(0);
            let j_hi = space.index_of_freq(hi_hz).unwrap_or(n - 1);

            for j in j_lo..j_hi {
                let d = erb[j] - fi_erb;
                let w = lut_interp(&self.lut, self.erb_step, self.hw, d);
                sum += amps[j] * w * du[j];
            }
            r[i] = sum;
        }

        // (4) Integration over ERB axis
        let r_total: f32 = r.iter().zip(du.iter()).map(|(ri, dui)| ri * dui).sum();

        (r, r_total)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::core::erb::{ErbSpace, erb_bw_hz, hz_to_erb};
    use plotters::prelude::*;
    use std::fs::File;
    use std::path::Path;

    const ERB_STEP: f32 = 0.005;

    fn make_kernel() -> RoughnessKernel {
        let p = KernelParams::default();
        RoughnessKernel::new(p, ERB_STEP)
    }

    // ------------------------------------------------------------
    // Basic kernel characteristics
    // ------------------------------------------------------------

    #[test]
    fn kernel_is_positive_and_centered() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        assert!(g.iter().all(|&v| v >= 0.0));
        assert_eq!(g.len(), 2 * hw + 1);
        let edge_mean = (g[0] + g[g.len() - 1]) * 0.5;

        let pos = (hw as f32 + 0.3 / ERB_STEP).round() as usize;
        let peak = g[pos].max(1e-12);
        assert!(
            edge_mean / peak < 5e-3,
            "edges should decay (edge/peak={})",
            edge_mean / peak
        );
    }

    #[test]
    fn kernel_center_is_suppressed_but_not_zero() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        let center = g[hw];

        // 近傍の代表ピークを取得（+0.3 ERB 付近）
        let pos = (hw as f32 + 0.3 / ERB_STEP).round() as usize;
        let peak = g[pos];

        assert!(center > 0.0, "center should be positive");
        // 抑圧されている＝ピークより十分小さい（閾値は経験的に 15–30% 程度）
        assert!(
            center < 0.5 * peak,
            "center suppression too weak: c/peak={}",
            center / peak
        );
    }

    #[test]
    fn kernel_has_peak_near_pm0p3_erb() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        let n = g.len();
        let d_erb: Vec<f32> = (0..n)
            .map(|i| (i as i32 - hw as i32) as f32 * ERB_STEP)
            .collect();

        let mut pos_peak = None;
        let mut neg_peak = None;
        for i in 1..n - 1 {
            if g[i] > g[i - 1] && g[i] > g[i + 1] {
                if d_erb[i] > 0.0 && pos_peak.is_none() {
                    pos_peak = Some((d_erb[i], g[i]));
                }
                if d_erb[i] < 0.0 && neg_peak.is_none() {
                    neg_peak = Some((d_erb[i], g[i]));
                }
            }
        }

        let (pos_x, pos_val) = pos_peak.expect("no positive-side peak");
        let (neg_x, _neg_val) = neg_peak.expect("no negative-side peak");
        assert!(
            pos_x > 0.2 && pos_x < 0.4,
            "positive peak near +0.3 ERB (got {:.2})",
            pos_x
        );
        assert!(
            neg_x < -0.2 && neg_x > -0.4,
            "negative peak near -0.3 ERB (got {:.2})",
            neg_x
        );
        assert!(pos_val > g[hw] * 1.5);
    }

    #[test]
    fn kernel_is_asymmetric() {
        let k = make_kernel();
        let g = &k.lut;
        let hw = k.hw;
        let pos = (hw as f32 + 0.3 / ERB_STEP).round() as usize;
        let neg = (hw as f32 - 0.3 / ERB_STEP).round() as usize;
        assert!(g[pos] > g[neg]);
    }

    #[test]
    fn kernel_l1_norm_is_one() {
        let k = make_kernel();
        let g = &k.lut;
        let sum: f32 = g.iter().sum();
        let sum_cont = sum * k.erb_step;
        assert!((sum_cont - 1.0).abs() < 1e-4, "L1 norm={}", sum_cont);
    }

    #[test]
    fn neural_layer_reduces_center_suppression() {
        let mut p1 = KernelParams::default();
        p1.w_neural = 0.0;
        let k1 = RoughnessKernel::new(p1, ERB_STEP);
        let c1 = k1.lut[k1.hw];

        let mut p2 = KernelParams::default();
        p2.w_neural = 0.4;
        let k2 = RoughnessKernel::new(p2, ERB_STEP);
        let c2 = k2.lut[k2.hw];

        assert!(c2 > c1);
    }

    #[test]
    fn kernel_stable_across_erbstep() {
        let p = KernelParams::default();
        let k1 = RoughnessKernel::new(p, ERB_STEP);
        let k2 = RoughnessKernel::new(p, 0.02);
        let g1 = &k1.lut;
        let g2 = &k2.lut;
        let hw1 = k1.hw;
        let hw2 = k2.hw;
        let ratio1 = g1[(hw1 as f32 + 0.3 / ERB_STEP).round() as usize] / g1[hw1];
        let ratio2 = g2[(hw2 as f32 + 0.3 / 0.02).round() as usize] / g2[hw2];
        assert!((ratio1 - ratio2).abs() < 0.1);
    }

    // ------------------------------------------------------------
    // δ-input and stability tests
    // ------------------------------------------------------------

    #[test]
    fn delta_input_reproduces_kernel_shape_when_du_constant() {
        let fs = 48_000.0;
        let nfft = 131072;
        let n = nfft / 2;
        let df = fs / nfft as f32;
        let f0 = 1000.0;
        let k0 = (f0 / df).round() as usize;

        let p = KernelParams::default();
        let k = RoughnessKernel::new(p, ERB_STEP);
        let g = &k.lut;
        let hw = k.hw;

        let mut e = vec![0.0f32; n];
        e[k0] = 1.0;

        let fi = k0 as f32 * df;
        let du_const = df / erb_bw_hz(fi).max(1e-12);

        let mut r = vec![0.0f32; n];
        for i in 0..n {
            if i == k0 {
                continue;
            }
            let fj = i as f32 * df;
            let d = hz_to_erb(fj) - hz_to_erb(fi);
            if d.abs() > p.half_width_erb {
                continue;
            }
            let w = eval_kernel_delta_erb(&p, d);
            r[i] = w * du_const;
        }

        let lo = k0.saturating_sub((p.half_width_erb / ERB_STEP).ceil() as usize);
        let hi = (k0 + (p.half_width_erb / ERB_STEP).ceil() as usize).min(n - 1);

        let mut r_on_erb = Vec::with_capacity(g.len());
        for kidx in 0..g.len() {
            let d_k = (kidx as i32 - hw as i32) as f32 * ERB_STEP;
            let f_target_erb = d_k + hz_to_erb(fi);
            let mut best_i = k0;
            let mut best_diff = f32::MAX;
            for i in lo..=hi {
                let fj = i as f32 * df;
                let erb_i = hz_to_erb(fj);
                let diff = (erb_i - f_target_erb).abs();
                if diff < best_diff {
                    best_diff = diff;
                    best_i = i;
                }
            }
            r_on_erb.push(r[best_i]);
        }

        let r_sum: f32 = r_on_erb.iter().sum();
        let g_sum: f32 = g.iter().sum();
        let r_norm: Vec<f32> = r_on_erb.iter().map(|&x| x / (r_sum + 1e-12)).collect();
        let g_norm: Vec<f32> = g.iter().map(|&x| x / (g_sum + 1e-12)).collect();

        let mae: f32 = r_norm
            .iter()
            .zip(g_norm.iter())
            .map(|(a, b)| (a - b).abs())
            .sum::<f32>()
            / g_norm.len() as f32;
        assert!(mae < 1e-2, "MAE={}", mae);
    }

    #[test]
    fn delta_input_reproduces_kernel_shape() {
        let params = KernelParams::default();
        let k = RoughnessKernel::new(params, ERB_STEP);
        let space = Log2Space::new(20.0, 8000.0, 500);

        let mut amps = vec![0.0f32; space.centers_hz.len()];
        let mid = amps.len() / 2;
        amps[mid] = 1.0;

        let (r_vec, _) = k.potential_r_from_log2_spectrum(&amps, &space);

        let g_ref = &k.lut;
        let hw = k.hw;
        let d_erb_kernel: Vec<f32> = (-(hw as i32)..=hw as i32)
            .map(|i| i as f32 * ERB_STEP)
            .collect();

        let f0_erb = hz_to_erb(space.centers_hz[mid]);
        let d_erb_vec: Vec<f32> = space
            .centers_hz
            .iter()
            .map(|&f| hz_to_erb(f) - f0_erb)
            .collect();

        let g_norm: Vec<f32> = g_ref
            .iter()
            .map(|&v| v / g_ref.iter().sum::<f32>())
            .collect();
        let r_norm: Vec<f32> = r_vec
            .iter()
            .map(|&v| v / r_vec.iter().sum::<f32>())
            .collect();

        let mut total_err = 0.0;
        let mut count = 0;
        for (de, rv) in d_erb_vec.iter().zip(r_norm.iter()) {
            if de.abs() < params.half_width_erb {
                let k_idx = ((de / ERB_STEP) + hw as f32).round() as isize;
                if k_idx >= 0 && (k_idx as usize) < g_norm.len() {
                    total_err += (rv - g_norm[k_idx as usize]).abs();
                    count += 1;
                }
            }
        }
        let mae = total_err / (count as f32).max(1.0);
        assert!(mae < 1e-3, "MAE too large: {:.4}", mae);
    }

    #[test]
    fn potential_r_stable_across_fs() {
        let p = KernelParams::default();
        let k = RoughnessKernel::new(p, ERB_STEP);
        let base = 1000.0;

        let fs1 = 48000.0;
        let n1 = 4096;
        let sig1: Vec<f32> = (0..n1)
            .map(|i| (2.0 * std::f32::consts::PI * base * i as f32 / fs1).sin())
            .collect();
        let (_r1, rtot1) = k.potential_r_from_analytic(&hilbert(&sig1), fs1);

        let fs2 = 96000.0;
        let n2 = 8192;
        let sig2: Vec<f32> = (0..n2)
            .map(|i| (2.0 * std::f32::consts::PI * base * i as f32 / fs2).sin())
            .collect();
        let (_r2, rtot2) = k.potential_r_from_analytic(&hilbert(&sig2), fs2);

        let rel_err = ((rtot2 - rtot1) / rtot1.abs()).abs();
        assert!(rel_err < 0.001, "R_total rel_err={rel_err}");
    }

    // ------------------------------------------------------------
    // Plot tests (unchanged, ignore for normal runs)
    // ------------------------------------------------------------

    #[test]
    #[ignore]
    fn plot_kernel_shape_png() {
        let k = make_kernel();
        let params = k.params;
        let erb_step = 0.02;
        let (g, _) = build_kernel_erbstep(&params, erb_step);
        let hw = (params.half_width_erb / erb_step).ceil() as i32;
        let d_erb: Vec<f32> = (-hw..=hw).map(|i| i as f32 * erb_step).collect();

        let out_path = Path::new("target/test_kernel_shape.png");
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let mut chart = ChartBuilder::on(&root)
            .caption("Asymmetric ERB-domain Kernel", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(
                d_erb[0]..d_erb[d_erb.len() - 1],
                0.0..g.iter().cloned().fold(0.0, f32::max) * 1.1,
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("Amplitude")
            .draw()
            .unwrap();
        chart
            .draw_series(LineSeries::new(
                d_erb.iter().zip(g.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))
            .unwrap();
        root.present().unwrap();
        assert!(File::open(out_path).is_ok());
    }

    #[test]
    #[ignore]
    fn compare_build_kernel_and_eval_kernel_shape() -> Result<(), Box<dyn std::error::Error>> {
        let params = KernelParams::default();
        let erb_step = 0.005;
        let k = RoughnessKernel::new(params, erb_step);
        let g_discrete = &k.lut;
        let hw = k.hw;

        let d_erb_vec: Vec<f32> = (-(hw as i32)..=hw as i32)
            .map(|i| i as f32 * erb_step)
            .collect();
        let g_eval: Vec<f32> = d_erb_vec
            .iter()
            .map(|&d| eval_kernel_delta_erb(&params, d))
            .collect();
        let sum1: f32 = g_discrete.iter().sum();
        let sum2: f32 = g_eval.iter().sum();
        let g1: Vec<f32> = g_discrete.iter().map(|&v| v / sum1).collect();
        let g2: Vec<f32> = g_eval.iter().map(|&v| v / sum2).collect();
        let mae = g1
            .iter()
            .zip(g2.iter())
            .map(|(a, b)| (a - b).abs())
            .sum::<f32>()
            / g1.len() as f32;
        assert!(mae < 1e-3, "MAE={}", mae);

        let out_path = "target/test_kernel_build_vs_eval.png";
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE)?;
        let mut chart = ChartBuilder::on(&root)
            .caption("build_kernel vs eval_kernel", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(
                -5.0f32..5.0f32,
                0.0f32..g1.iter().cloned().fold(0.0, f32::max) * 1.1,
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("Amplitude")
            .draw()?;
        chart
            .draw_series(LineSeries::new(
                d_erb_vec.iter().zip(g1.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))?
            .label("discrete")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &BLUE));
        chart
            .draw_series(LineSeries::new(
                d_erb_vec.iter().zip(g2.iter()).map(|(&x, &y)| (x, y)),
                &RED,
            ))?
            .label("eval()")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &RED));
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()?;
        root.present()?;
        Ok(())
    }

    #[test]
    #[ignore]
    fn plot_potential_r_from_signal_direct_erb() {
        let fs = 48000.0;
        let k = RoughnessKernel::new(KernelParams::default(), 0.005);
        let base = 440.0;
        let n = 16384;

        let mut sig1 = vec![0.0f32; n];
        for i in 0..n {
            let t = i as f32 / fs;
            sig1[i] = (2.0 * std::f32::consts::PI * base * t).sin();
        }
        let (r1, _) = k.potential_r_from_analytic(&hilbert(&sig1), fs);

        let mut sig2 = vec![0.0f32; n];
        let f2 = base * 1.2;
        for i in 0..n {
            let t = i as f32 / fs;
            sig2[i] = (2.0 * std::f32::consts::PI * base * t).sin()
                + (2.0 * std::f32::consts::PI * f2 * t).sin();
        }
        let (r2, _) = k.potential_r_from_analytic(&hilbert(&sig2), fs);

        let df = fs / n as f32;
        let f0_erb = hz_to_erb(base);
        let x_erb: Vec<f32> = (0..r1.len())
            .map(|i| hz_to_erb(i as f32 * df) - f0_erb)
            .collect();

        let out_path = "target/test_potential_r_signal_direct_erb.png";
        let root = BitMapBackend::new(out_path, (1600, 1000)).into_drawing_area();
        root.fill(&WHITE).unwrap();
        let mut chart = ChartBuilder::on(&root)
            .caption("Potential R from Signal (ΔERB axis)", ("sans-serif", 30))
            .margin(10)
            .build_cartesian_2d(
                -5.0f32..5.0f32,
                0.0f32..r2.iter().cloned().fold(0.0, f32::max) * 1.1,
            )
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("R(f)")
            .draw()
            .unwrap();
        chart
            .draw_series(LineSeries::new(
                x_erb.iter().zip(r1.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))
            .unwrap()
            .label("pure tone");
        chart
            .draw_series(LineSeries::new(
                x_erb.iter().zip(r2.iter()).map(|(&x, &y)| (x, y)),
                &RED,
            ))
            .unwrap()
            .label("two-tone ΔERB≈0.3");
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()
            .unwrap();
        root.present().unwrap();
        assert!(File::open(out_path).is_ok());
    }

    #[test]
    #[ignore]
    fn plot_potential_r_from_log2_spectrum_delta_input() -> Result<(), Box<dyn std::error::Error>> {
        use crate::core::erb::hz_to_erb;
        use crate::core::log2space::Log2Space;
        use plotters::prelude::*;

        let k = RoughnessKernel::new(KernelParams::default(), 0.005);
        let space = Log2Space::new(20.0, 8000.0, 144);

        let mut amps = vec![0.0f32; space.centers_hz.len()];
        let mid = amps.len() / 2;
        amps[mid] = 1.0;

        let (r_vec, _) = k.potential_r_from_log2_spectrum(&amps, &space);

        let mid = amps.len() / 2;
        let f0_erb = hz_to_erb(space.centers_hz[mid]);
        let erb_per_bin = hz_to_erb(space.centers_hz[mid + 1]) - hz_to_erb(space.centers_hz[mid]);
        let d_erb_r: Vec<f32> = (0..amps.len())
            .map(|i| (i as f32 - mid as f32) * erb_per_bin)
            .collect();

        let g_ref = &k.lut;
        let hw = k.hw;
        let d_erb_kernel: Vec<f32> = (-(hw as i32)..=hw as i32)
            .map(|i| i as f32 * k.erb_step)
            .collect();

        let r_norm: Vec<f32> = r_vec
            .iter()
            .map(|&v| v / r_vec.iter().cloned().fold(0.0, f32::max))
            .collect();
        let g_norm: Vec<f32> = g_ref
            .iter()
            .map(|&v| v / g_ref.iter().cloned().fold(0.0, f32::max))
            .collect();

        let out_path = "target/test_potential_r_from_log2_spectrum_delta.png";
        let root = BitMapBackend::new(out_path, (1500, 1000)).into_drawing_area();
        root.fill(&WHITE)?;

        let mut chart = ChartBuilder::on(&root)
            .caption(
                "Potential R from Log2 Spectrum (δ input)",
                ("sans-serif", 30),
            )
            .margin(10)
            .x_label_area_size(40)
            .y_label_area_size(50)
            .build_cartesian_2d(-5.0f32..5.0f32, 0.0f32..1.05f32)
            .unwrap();

        chart
            .configure_mesh()
            .x_desc("ΔERB")
            .y_desc("Normalized Amplitude")
            .draw()?;
        chart
            .draw_series(LineSeries::new(
                d_erb_r.iter().zip(r_norm.iter()).map(|(&x, &y)| (x, y)),
                &BLUE,
            ))?
            .label("R(log2 input)")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &BLUE));
        chart
            .draw_series(LineSeries::new(
                d_erb_kernel
                    .iter()
                    .zip(g_norm.iter())
                    .map(|(&x, &y)| (-x, y)),
                &GREEN,
            ))?
            .label("Kernel g(ΔERB), flipped")
            .legend(|(x, y)| PathElement::new([(x, y), (x + 20, y)], &GREEN));
        chart
            .configure_series_labels()
            .border_style(&BLACK)
            .draw()?;
        root.present()?;
        assert!(std::path::Path::new(out_path).exists());
        Ok(())
    }

    #[test]
    #[ignore]
    fn plot_potential_r_delta_input_all_methods() -> Result<(), Box<dyn std::error::Error>> {
        use crate::core::erb::hz_to_erb;
        use crate::core::fft::hilbert;
        use crate::core::log2space::Log2Space;
        use plotters::prelude::*;
        use rustfft::{FftPlanner, num_complex::Complex32};
        use std::f32::consts::PI;

        let fs = 48_000.0;
        let params = KernelParams::default();
        let k = RoughnessKernel::new(params, 0.005);
        let space = Log2Space::new(20.0, 8000.0, 144);
        let nfft = 163_84;

        let mut amps_log2 = vec![0.0f32; space.centers_hz.len()];
        let mid = amps_log2.len() / 2;
        amps_log2[mid] = 1.0;

        let (r_log2, _) = k.potential_r_from_log2_spectrum(&amps_log2, &space);

        let df = fs / nfft as f32;
        let mut amps_lin = vec![0.0f32; nfft / 2];
        for (kidx, &f) in space.centers_hz.iter().enumerate() {
            let bin = (f / df).round() as usize;
            if bin < amps_lin.len() {
                amps_lin[bin] += amps_log2[kidx];
            }
        }
        let (r_spec, _) = k.potential_r_from_spectrum(&amps_lin, fs);

        let mut buf = vec![Complex32::new(0.0, 0.0); nfft];
        for (i, &amp) in amps_lin.iter().enumerate() {
            buf[i] = Complex32::new(amp, 0.0);
        }
        for i in 1..(nfft / 2) {
            buf[nfft - i] = buf[i].conj();
        }
        let mut planner = FftPlanner::new();
        let ifft = planner.plan_fft_inverse(nfft);
        ifft.process(&mut buf);
        let sig: Vec<f32> = buf.iter().map(|z| z.re / nfft as f32).collect();
        let (r_analytic, _) = k.potential_r_from_analytic(&hilbert(&sig), fs);

        // plotting same as original (omitted for brevity)
        Ok(())
    }
}
</file>

<file path="src/app.rs">
use egui::{Order, ViewportCommand};
use std::sync::{
    Arc,
    atomic::{AtomicBool, Ordering},
};
use std::thread;
use std::time::{Duration, Instant};
use tracing::*;

use crossbeam_channel::{Receiver, Sender, bounded};

use crate::audio::writer::WavOutput;
use crate::core::harmonicity_kernel::HarmonicityKernel;
use crate::core::landscape::{Landscape, LandscapeFrame, LandscapeParams};
use crate::core::log2space::Log2Space;
use crate::core::nsgt_kernel::{BandCoeffs, NsgtKernelLog2, NsgtLog2Config};
use crate::core::nsgt_rt::RtNsgtKernelLog2;
use crate::core::roughness_kernel::{KernelParams, RoughnessKernel};
use crate::life::population::{Population, PopulationParams};
use crate::synth::engine::{SynthConfig, SynthEngine};
use crate::ui::viewdata::{SpecFrame, UiFrame, WaveFrame};
use crate::{audio::output::AudioOutput, core::harmonicity_kernel::HarmonicityParams};

pub struct App {
    ui_frame_rx: Receiver<UiFrame>,
    _ctrl_tx: Sender<()>, // placeholder
    last_frame: UiFrame,
    _audio: Option<AudioOutput>,
    wav_tx: Option<Sender<Vec<f32>>>,
    worker_handle: Option<std::thread::JoinHandle<()>>,
    wav_handle: Option<std::thread::JoinHandle<()>>,
    exiting: Arc<AtomicBool>,
}

impl App {
    pub fn new(
        cc: &eframe::CreationContext<'_>,
        args: crate::Args,
        stop_flag: Arc<AtomicBool>,
        tones: Vec<(f32, f32)>,
    ) -> Self {
        // Channels
        let (ui_frame_tx, ui_frame_rx) = bounded::<UiFrame>(8);
        let (ctrl_tx, _ctrl_rx) = bounded::<()>(1);

        // Audio
        let (audio_out, audio_prod) = if args.play {
            let (out, prod) = AudioOutput::new(50.0);
            (Some(out), Some(prod))
        } else {
            (None, None)
        };

        // WAV
        let (wav_tx, wav_rx) = bounded::<Vec<f32>>(16);
        let wav_handle = if let Some(path) = args.wav.clone() {
            Some(WavOutput::run(wav_rx, path, 48000))
        } else {
            None
        };

        let initial_tones_hz: Vec<f32> = tones.iter().map(|(f, _)| *f).collect();
        let amplitude = tones.iter().map(|(_, a)| *a).fold(0.0, f32::max);

        // Population (life)
        let mut pop = Population::new(PopulationParams {
            initial_tones_hz,
            amplitude,
        });

        // worker に渡すのは wav_tx.clone()
        let wav_tx_for_worker = if args.wav.is_some() {
            Some(wav_tx.clone())
        } else {
            None
        };

        // Spawn worker thread
        let stop_flag_worker = stop_flag.clone();
        let worker_handle = Some(
            thread::Builder::new()
                .name("worker".into())
                .spawn(move || {
                    worker_loop(
                        ui_frame_tx,
                        pop,
                        audio_prod,
                        wav_tx_for_worker,
                        stop_flag_worker,
                    )
                })
                .expect("spawn worker"),
        );

        // Egui visuals tweak (dark)
        cc.egui_ctx.set_pixels_per_point(1.25);

        Self {
            ui_frame_rx,
            _ctrl_tx: ctrl_tx,
            last_frame: UiFrame::default(),
            _audio: audio_out,
            wav_tx: Some(wav_tx),
            wav_handle,
            worker_handle,
            exiting: stop_flag,
        }
    }
}

impl eframe::App for App {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        if self.exiting.load(Ordering::SeqCst) {
            eprintln!("SIGINT received: closing window.");
            ctx.send_viewport_cmd(egui::ViewportCommand::Close);
            return;
        }

        // Pull newest frame (drain to latest)
        while let Ok(f) = self.ui_frame_rx.try_recv() {
            self.last_frame = f;
        }
        crate::ui::windows::main_window(ctx, &self.last_frame);
        ctx.request_repaint_after(std::time::Duration::from_millis(16));
    }
}

impl Drop for App {
    fn drop(&mut self) {
        eprintln!("App drop. Finalizing..");

        self.wav_tx.take();

        if let Some(handle) = self.worker_handle.take() {
            let _ = handle.join();
        }
        if let Some(handle) = self.wav_handle.take() {
            let _ = handle.join();
        }
    }
}

fn worker_loop(
    ui_tx: Sender<UiFrame>,
    pop: Population,
    mut audio_prod: Option<ringbuf::HeapProd<f32>>,
    wav_tx: Option<Sender<Vec<f32>>>,
    exiting: Arc<AtomicBool>,
) {
    // --- Parameters ---
    let fs: f32 = 48_000.0;

    // === NSGT (log2) analyzer & Landscape parameters ===
    let space = Log2Space::new(100.0, 8000.0, 200);

    let lparams = LandscapeParams {
        fs,
        max_hist_cols: 256,
        alpha: 0.0,
        roughness_kernel: RoughnessKernel::new(KernelParams::default(), 0.005), // ΔERB LUT step
        harmonicity_kernel: HarmonicityKernel::new(&space, HarmonicityParams::default()),
        loudness_exp: 0.23, // Zwicker
        tau_ms: 80.0,
        ref_power: 1e-6,
        roughness_k: 0.1,
    };

    let mut nsgt = RtNsgtKernelLog2::new(NsgtKernelLog2::new(
        NsgtLog2Config {
            fs,
            overlap: 0.5,
            nfft_override: Some(16384),
        },
        space,
    ));

    let mut next_deadline = Instant::now();

    let nfft = nsgt.nfft();
    let hop = nsgt.hop();
    let n_bins = nfft / 2 + 1;

    println!("nfft {nfft}, hop {hop}");

    let hop_duration = Duration::from_secs_f32(hop as f32 / fs);

    let mut landscape = Landscape::new(lparams, nsgt);

    // Synth engine
    let mut synth = SynthEngine::new(SynthConfig {
        fs,
        hop,
        n_bins,
        fft_size: nfft,
    });

    println!("nfft = {nfft}, hop = {hop},");

    loop {
        if exiting.load(Ordering::SeqCst) {
            eprintln!("Stopping worker thread.");
            break;
        }

        next_deadline += hop_duration;

        // 1) population → spectral amplitude A[k]
        let amps = pop.project_spectrum(n_bins, fs, nfft);

        // 2) synth: render hop
        let time_chunk = synth.render_hop(&amps);

        // send out audio signal
        if let Some(prod) = audio_prod.as_mut() {
            AudioOutput::push_samples(prod, &time_chunk);
        }

        if let Some(tx) = &wav_tx {
            let _ = tx.try_send(time_chunk.clone());
        }

        // 3) landscape update
        let lframe = landscape.process_frame(&time_chunk);

        // 4) package for UI
        let ui_frame = UiFrame {
            wave: WaveFrame {
                fs,
                samples: time_chunk,
            },
            spec: SpecFrame {
                spec_hz: synth.bin_freqs_hz(),
                amps,
            },
            landscape: lframe,
        };
        let _ = ui_tx.try_send(ui_frame);

        // Simple timing
        let now = Instant::now();
        if now < next_deadline {
            std::thread::sleep(next_deadline - now);
        } else {
            next_deadline = now;
            trace!("worker overrun");
        }
    }
}
</file>

<file path="src/core/landscape.rs">
//! core/landscape.rs — Landscape computed on log2(NSGT-RT) domain.
//!
//! Each incoming hop updates the potential roughness (R) and harmonicity (H)
//! using a real-time NSGT analyzer with leaky temporal integration.
//! Psychoacoustic normalization (subjective intensity + leaky smoothing)
//! runs before applying the R/H kernels.

use crate::core::harmonicity_kernel::HarmonicityKernel;
use crate::core::log2space::Log2Space;
use crate::core::nsgt_rt::RtNsgtKernelLog2;
use crate::core::roughness_kernel::RoughnessKernel;

#[derive(Clone, Debug)]
pub struct LandscapeParams {
    pub fs: f32,
    pub max_hist_cols: usize,
    pub alpha: f32,
    pub roughness_kernel: RoughnessKernel,
    pub harmonicity_kernel: HarmonicityKernel,

    /// Exponent for subjective intensity (≈ specific loudness). Typical: 0.23
    pub loudness_exp: f32,
    /// Reference power for normalization. Tune to your signal scale.
    pub ref_power: f32,
    /// Leaky integration time constant [ms]. Typical: 60–120 ms.
    pub tau_ms: f32,

    /// Roughness normalization constant (k).
    /// Controls the saturation curve: D_index = R / (R_total + k).
    pub roughness_k: f32,
}

#[derive(Clone, Debug)]
pub struct LandscapeFrame {
    pub fs: f32,
    pub space: Log2Space,
    pub r_last: Vec<f32>,
    pub h_last: Vec<f32>,
    pub c_last: Vec<f32>,
    /// Preprocessed subjective intensity (after normalize()) on log2 bins.
    pub amps_last: Vec<f32>,
}

/// Maintains real-time psychoacoustic landscape (R/C/K) driven by NSGT-RT.
pub struct Landscape {
    nsgt_rt: RtNsgtKernelLog2,
    params: LandscapeParams,
    last_r: Vec<f32>,
    last_h: Vec<f32>,
    last_c: Vec<f32>,
    /// State of the leaky integrator per bin (subjective intensity domain).
    norm_state: Vec<f32>,
    /// Last preprocessed amplitudes (subjective intensity).
    amps_last: Vec<f32>,
}

impl Landscape {
    pub fn new(params: LandscapeParams, nsgt_rt: RtNsgtKernelLog2) -> Self {
        let n_ch = nsgt_rt.space().n_bins();
        Self {
            nsgt_rt,
            params,
            last_r: vec![0.0; n_ch],
            last_h: vec![0.0; n_ch],
            last_c: vec![0.0; n_ch],
            norm_state: vec![0.0; n_ch],
            amps_last: vec![0.0; n_ch],
        }
    }

    /// Convert magnitude envelope → subjective intensity (power law)
    /// and apply a leaky integrator to stabilize dynamics.
    fn normalize(&mut self, envelope: &[f32], dt_sec: f32) -> Vec<f32> {
        let exp = self.params.loudness_exp.max(0.01);
        let tau_s = (self.params.tau_ms.max(1.0)) * 1e-3;
        let a = (-dt_sec / tau_s).exp();
        let mut out = vec![0.0f32; envelope.len()];

        for (i, &mag) in envelope.iter().enumerate() {
            let pow = mag * mag;
            let subj = (pow / self.params.ref_power).powf(exp);
            let y_prev = self.norm_state[i];
            let y = a * y_prev + (1.0 - a) * subj;
            self.norm_state[i] = y;
            out[i] = y;
        }
        out
    }

    /// Process one hop of samples (length = hop). Real-time streaming entry point.
    pub fn process_frame(&mut self, x_frame: &[f32]) -> LandscapeFrame {
        let fs = self.params.fs;
        let dt_sec = (x_frame.len() as f32) / fs;

        // === 1. NSGT-RT analysis (streaming hop) ===
        let envelope: Vec<f32> = self.nsgt_rt.process_hop(x_frame).to_vec();

        // === 2. Psychoacoustic normalization ===
        let norm_env = self.normalize(&envelope, dt_sec);
        self.amps_last.clone_from(&norm_env);

        // === 3. Roughness potential R ===
        let space = self.nsgt_rt.space();
        let (r, r_total) = self
            .params
            .roughness_kernel
            .potential_r_from_log2_spectrum(&norm_env, space);

        println!("{r_total}");

        // === 4. Harmonicity potential C ===
        let (h, _norm) = self
            .params
            .harmonicity_kernel
            .potential_h_from_log2_spectrum(&norm_env, space);
        //.potential_h_with_freq_gate(&norm_env, space);

        // === 5. Combined potential K ===
        //let c: Vec<f32> = r.iter().zip(&h).map(|(ri, hi)| hi * (1.0 - ri)).collect();
        //        let c: Vec<f32> = r.iter().zip(&h).map(|(ri, hi)| hi - ri).collect();

        let k = self.params.roughness_k.max(1e-6);
        let denom_inv = 1.0 / (r_total + k);

        let c: Vec<f32> = r
            .iter()
            .zip(&h)
            .map(|(ri, hi)| {
                let d_index = ri * denom_inv;
                //hi * (1.0 - d_index)
                hi - d_index
            })
            .collect();

        // === 6. Update state ===
        self.last_r.clone_from(&r);
        self.last_h.clone_from(&h);
        self.last_c.clone_from(&c);

        LandscapeFrame {
            fs,
            space: space.clone(),
            r_last: r,
            h_last: h,
            c_last: c,
            amps_last: self.amps_last.clone(),
        }
    }

    pub fn snapshot(&self) -> LandscapeFrame {
        LandscapeFrame {
            fs: self.params.fs,
            space: self.nsgt_rt.space().clone(),
            r_last: self.last_r.clone(),
            h_last: self.last_h.clone(),
            c_last: self.last_c.clone(),
            amps_last: self.amps_last.clone(),
        }
    }

    pub fn params(&self) -> &LandscapeParams {
        &self.params
    }

    pub fn reset(&mut self) {
        self.nsgt_rt.reset();
        for x in &mut self.norm_state {
            *x = 0.0;
        }
        for x in &mut self.amps_last {
            *x = 0.0;
        }
        for x in &mut self.last_r {
            *x = 0.0;
        }
        for x in &mut self.last_h {
            *x = 0.0;
        }
        for x in &mut self.last_c {
            *x = 0.0;
        }
    }
}

impl Default for LandscapeFrame {
    fn default() -> Self {
        let space = Log2Space::new(1.0, 2.0, 1);
        let n = space.n_bins();
        Self {
            fs: 0.0,
            space,
            r_last: vec![0.0; n],
            h_last: vec![0.0; n],
            c_last: vec![0.0; n],
            amps_last: vec![0.0; n],
        }
    }
}
</file>

</files>
