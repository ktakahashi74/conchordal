// R via ERB-domain kernel convolution.

use crate::core::erb::{erb_to_hz, hz_to_erb};
use rustfft::{FftPlanner, num_complex::Complex32};

/// Linear interp on monotonic x.
fn lerp_samples(x: &[f32], y: &[f32], xq: f32) -> f32 {
    let n = x.len();
    if xq <= x[0] {
        return y[0];
    }
    if xq >= x[n - 1] {
        return y[n - 1];
    }
    // binary search
    let mut lo = 0usize;
    let mut hi = n - 1;
    while hi - lo > 1 {
        let mid = (lo + hi) / 2;
        if x[mid] <= xq {
            lo = mid;
        } else {
            hi = mid;
        }
    }
    let t = (xq - x[lo]) / (x[hi] - x[lo]);
    y[lo] * (1.0 - t) + y[hi] * t
}

/// Build asymmetric ERB kernel g(ΔERB).
pub struct KernelParams {
    pub sigma_erb: f32,      // Gaussian width
    pub tau_erb: f32,        // high-side exponential tail
    pub mix_tail: f32,       // tail mix [0..1]
    pub half_width_erb: f32, // kernel radius in ERB units
}

impl Default for KernelParams {
    fn default() -> Self {
        Self {
            sigma_erb: 0.6,
            tau_erb: 1.2,
            mix_tail: 0.25,
            half_width_erb: 4.0,
        }
    }
}

/// Returns g centered at 0 with ERB step `erb_step`. Length is odd.
fn build_kernel(params: &KernelParams, erb_step: f32) -> (Vec<f32>, usize) {
    let hw = (params.half_width_erb / erb_step).ceil() as i32;
    let len = (2 * hw + 1) as usize;
    let mut g = vec![0.0f32; len];
    for i in 0..len {
        let d_idx = i as i32 - hw;
        let d_erb = d_idx as f32 * erb_step;
        let g_gauss = (-(d_erb * d_erb) / (params.sigma_erb * params.sigma_erb)).exp();
        let g_tail = if d_erb >= 0.0 {
            (-d_erb.abs() / params.tau_erb).exp()
        } else {
            0.0
        };
        g[i] = (1.0 - params.mix_tail) * g_gauss + params.mix_tail * g_tail;
    }
    // L1 normalize (sum to 1)
    let sum: f32 = g.iter().sum();
    if sum > 0.0 {
        for v in &mut g {
            *v /= sum;
        }
    }
    (g, hw as usize)
}

/// Convolution (same-size) on ERB grid via FFT. Real-only.
fn fft_convolve_same(x: &[f32], h: &[f32]) -> Vec<f32> {
    let n = x.len();
    let m = h.len();
    let n_conv = n + m - 1;
    let n_fft = n_conv.next_power_of_two();

    let mut planner = FftPlanner::new();
    let fft = planner.plan_fft_forward(n_fft);
    let ifft = planner.plan_fft_inverse(n_fft);

    let mut X = vec![Complex32::new(0.0, 0.0); n_fft];
    let mut H = vec![Complex32::new(0.0, 0.0); n_fft];

    for (i, &v) in x.iter().enumerate() {
        X[i].re = v;
    }
    for (i, &v) in h.iter().enumerate() {
        H[i].re = v;
    }

    fft.process(&mut X);
    fft.process(&mut H);
    for i in 0..n_fft {
        X[i] *= H[i];
    }
    ifft.process(&mut X);

    // scale by n_fft (rustfft unnormalized inverse)
    let scale = 1.0 / n_fft as f32;
    for xi in &mut X {
        *xi *= scale;
    }

    // center “same”: take indices [ (m-1)/2 .. (m-1)/2 + n )
    let offset = (m - 1) / 2;
    (0..n).map(|i| X[i + offset].re).collect()
}

/// Public API: compute roughness R by ERB-kernel convolution (ERB-uniform grid).
/// Assumes `freqs_hz` was generated by `erb_space()`, i.e. ERB-rate is uniform.
///
/// - `e_ch`: per-channel energy/envelope (≥0)
/// - `freqs_hz`: center frequencies (ERB-uniform)
/// - `erb_step`: ERB grid step used in erb_space()
/// - `params`: kernel params
pub fn compute_r_kernelconv(
    e_ch: &[f32],
    freqs_hz: &[f32],
    erb_step: f32,
    params: &KernelParams,
) -> Vec<f32> {
    let n_ch = e_ch.len();
    if n_ch == 0 {
        return vec![];
    }

    // --- 1. build kernel (ΔERB domain) ---
    let (g, _halfw) = build_kernel(params, erb_step);

    // --- 2. convolve envelope along ERB axis ---
    let r_conv = fft_convolve_same(e_ch, &g);

    // --- 3. optional local weighting by sqrt(energy) ---
    let mut r_ch = Vec::with_capacity(n_ch);
    for (r, &e) in r_conv.iter().zip(e_ch) {
        r_ch.push(r * (e.abs() + 1e-12).sqrt());
    }

    r_ch
}
#[cfg(test)]
mod tests {
    use super::*;

    use rand::random;

    // === 基本特性 ===========================================================

    #[test]
    fn kernel_is_l1_normalized() {
        let (g, _) = build_kernel(&KernelParams::default(), 0.1);
        let sum: f32 = g.iter().sum();
        assert!((sum - 1.0).abs() < 1e-4, "kernel sum = {sum}");
    }

    #[test]
    fn kernel_has_central_peak() {
        let (g, _) = build_kernel(&KernelParams::default(), 0.1);
        let mid = g.len() / 2;
        assert!(
            g[mid] >= g[mid - 1] && g[mid] >= g[mid + 1],
            "center not peak"
        );
    }

    // === FFT畳み込みの整合性 ===============================================

    #[test]
    fn impulse_response_matches_kernel_shape() {
        // インパルス畳み込み → 出力はほぼカーネル形になる
        let n = 129;
        let mut x = vec![0.0f32; n];
        x[n / 2] = 1.0;
        let (g, _) = build_kernel(&KernelParams::default(), 0.1);
        let y = fft_convolve_same(&x, &g);
        let mid = n / 2;
        assert!(
            y[mid] > y[mid - 2] && y[mid] > y[mid + 2],
            "impulse conv not centered peak"
        );
    }

    // === compute_r_kernelconv の動作 =======================================

    #[test]
    fn zero_energy_returns_zero() {
        let freqs: Vec<f32> = (0..32).map(|i| 100.0 * 1.06f32.powi(i as i32)).collect();
        let e = vec![0.0; freqs.len()];
        let r = compute_r_kernelconv(&e, &freqs, 0.1, &KernelParams::default());
        assert!(
            r.iter().all(|&v| v.abs() < 1e-9),
            "nonzero output for zero input"
        );
    }

    #[test]
    fn narrowband_energy_yields_local_peak() {
        // 400–600 Hzにエネルギを集中 → 同帯域付近でRが最大
        let freqs: Vec<f32> = (0..64).map(|i| 50.0 * 1.06f32.powi(i as i32)).collect();
        let e: Vec<f32> = freqs
            .iter()
            .map(|&f| if (f > 400.0 && f < 600.0) { 1.0 } else { 0.0 })
            .collect();
        let r = compute_r_kernelconv(&e, &freqs, 0.1, &KernelParams::default());

        let imax = r
            .iter()
            .enumerate()
            .max_by(|a, b| a.1.partial_cmp(b.1).unwrap())
            .unwrap()
            .0;
        let fmax = freqs[imax];
        assert!(
            (fmax > 300.0) && (fmax < 700.0),
            "peak at unexpected freq: {fmax}"
        );
    }

    #[test]
    fn monotonically_increasing_freqs_are_ok() {
        // 非単調freqsを与えるとpanicしないかを確認
        let freqs: Vec<f32> = vec![100.0, 200.0, 400.0, 800.0];
        let e: Vec<f32> = vec![1.0, 0.5, 0.2, 0.1];
        let r = compute_r_kernelconv(&e, &freqs, 0.2, &KernelParams::default());
        assert_eq!(r.len(), freqs.len());
    }

    #[test]
    fn stable_under_small_perturbations() {
        // エネルギに微小ノイズを加えても大きく揺れないこと
        let freqs: Vec<f32> = (0..64).map(|i| 100.0 * 1.07f32.powi(i as i32)).collect();
        let mut e: Vec<f32> = freqs
            .iter()
            .map(|&f| (f > 500.0 && f < 1500.0) as i32 as f32)
            .collect();
        let r1 = compute_r_kernelconv(&e, &freqs, 0.1, &KernelParams::default());
        for v in &mut e {
            *v += (rand::random::<f32>() - 0.5) * 1e-3;
        }
        let r2 = compute_r_kernelconv(&e, &freqs, 0.1, &KernelParams::default());
        let diff: f32 =
            r1.iter().zip(&r2).map(|(a, b)| (a - b).abs()).sum::<f32>() / r1.len() as f32;
        assert!(diff < 1e-2, "unstable output diff={diff}");
    }
}
